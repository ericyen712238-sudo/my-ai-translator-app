<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini AI 文件助手 (Pro)</title>
    
    <!-- Favicon (Logo) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22%232563eb%22 stroke-width=%222%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22><path d=%22m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z%22/></svg>">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    animation: { 
                        'slide-up': 'slideUp 0.3s ease-out forwards', 
                        'fade-out': 'fadeOut 0.3s ease-in forwards',
                        'pop-in': 'popIn 0.2s ease-out forwards' 
                    },
                    keyframes: {
                        slideUp: { '0%': { transform: 'translate(-50%, 100%)', opacity: '0' }, '100%': { transform: 'translate(-50%, -1rem)', opacity: '1' } },
                        fadeOut: { '0%': { opacity: '1' }, '100%': { opacity: '0' } },
                        popIn: { '0%': { opacity: '0', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' } }
                    }
                }
            }
        }
    </script>
    
    <!-- KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Fonts & Libs -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Mermaid -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

    <style>
        body { font-family: 'Zen Maru Gothic', sans-serif; -webkit-tap-highlight-color: transparent; overscroll-behavior-y: none; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 3px; }
        .dark ::-webkit-scrollbar-thumb { background-color: #475569; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .visual-text-box { touch-action: none; backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center; overflow: hidden; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .mermaid { display: flex; justify-content: center; padding: 20px; background: white; border-radius: 10px; overflow-x: auto; }
        .dark .mermaid { background: #1e293b; }
        .prose { max-width: none; }
        .crop-modal { touch-action: none; }
        input[type=range] { accent-color: #2563eb; }

        /* Force dark mode overrides */
        .dark .prose { color: #e2e8f0 !important; }
        .dark .prose h1, .dark .prose h2, .dark .prose h3, .dark .prose h4, .dark .prose h5, .dark .prose h6 { color: #f1f5f9 !important; }
        .dark .prose strong { color: #fcd34d !important; background-color: rgba(255,255,255,0.1); padding: 0 4px; border-radius: 4px; }
        .dark .prose li { color: #e2e8f0 !important; }
        .dark .prose ul > li::marker { color: #94a3b8 !important; }
        .dark .prose ol > li::marker { color: #94a3b8 !important; }
        .dark .prose code { color: #fca5a5 !important; background-color: #1e293b !important; border: 1px solid #334155; }
        .dark .prose a { color: #60a5fa !important; }
        .dark .prose blockquote { color: #cbd5e1 !important; border-left-color: #60a5fa !important; background-color: #1e293b !important; }
        
        /* Chat Input Styling */
        .chat-input { min-height: 40px; max-height: 120px; line-height: 1.5; }
        
        /* Dashed Border Animation */
        .dashed-border {
            background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='8' ry='8' stroke='%23333' stroke-width='2' stroke-dasharray='10%2c 10' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
        }
        
        /* Safe Area for Mobile */
        .safe-area-pb { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body class="bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-100 min-h-screen transition-colors duration-300">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        if (typeof mermaid !== 'undefined') mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose', fontFamily: 'Zen Maru Gothic' });

        // --- Global Helper Functions ---
        
        // 1. Load PDF with Password Support
        const loadPdfWithPassword = (data) => {
            const loadingTask = window.pdfjsLib.getDocument({ data });
            loadingTask.onPassword = (updatePassword, reason) => {
                let msg = '此 PDF 受密碼保護，請輸入密碼：';
                if (reason === window.pdfjsLib.PasswordResponses.INCORRECT_PASSWORD) {
                    msg = '密碼錯誤，請重新輸入：';
                }
                const password = prompt(msg);
                if (password) {
                    updatePassword(password);
                } else {
                    loadingTask.destroy();
                }
            };
            return loadingTask.promise;
        };

        // 2. Compress Image
        const compressImage = (file) => new Promise((resolve, reject) => {
            const r = new FileReader(); r.readAsDataURL(file);
            r.onload = e => {
                const img = new Image(); img.src = e.target.result;
                img.onload = () => {
                    const c = document.createElement('canvas');
                    let w=img.width, h=img.height, m=1500;
                    if(w>h && w>m){h*=m/w;w=m;} else if(h>m){w*=m/h;h=m;}
                    c.width=w; c.height=h; c.getContext('2d').drawImage(img,0,0,w,h);
                    resolve(c.toDataURL('image/jpeg',0.8).split(',')[1]);
                };
                img.onerror = reject;
            };
            r.onerror = reject;
        });

        // 3. Render PDF Pages to Images
        const renderPdfToImages = async (ab) => {
            const pdf = await loadPdfWithPassword(ab); // Use password helper
            const imgs = [];
            const count = Math.min(pdf.numPages, 5); 
            for(let i=1;i<=count;i++){
                const p = await pdf.getPage(i);
                const v = p.getViewport({scale:1.5});
                const c = document.createElement('canvas'); c.width=v.width; c.height=v.height;
                await p.render({canvasContext:c.getContext('2d'),viewport:v}).promise;
                imgs.push(c.toDataURL('image/jpeg',0.8).split(',')[1]);
            }
            return imgs;
        };

        // 4. Robust Fetch with Retry
        const fetchWithRetry = async (url, options, retries = 5, delay = 2000, onRetry) => {
            try {
                const res = await fetch(url, options);
                if (res.status === 429) {
                    if (retries > 0) {
                        if(onRetry) onRetry(delay / 1000);
                        await new Promise(r => setTimeout(r, delay));
                        const nextDelay = Math.min(delay * 2, 16000);
                        return fetchWithRetry(url, options, retries - 1, nextDelay, onRetry);
                    }
                    throw new Error("429_TOO_MANY_REQUESTS");
                }
                if (!res.ok) {
                    if (res.status === 404) throw new Error("404_NOT_FOUND");
                    throw new Error(`HTTP ${res.status}`);
                }
                return await res.json();
            } catch (e) {
                if (e.message === "404_NOT_FOUND" || e.message === "429_TOO_MANY_REQUESTS") throw e;
                if (retries > 0) {
                    if(onRetry) onRetry(delay / 1000);
                    await new Promise(r => setTimeout(r, delay));
                    return fetchWithRetry(url, options, retries - 1, delay * 1.5, onRetry);
                }
                throw e;
            }
        };

        // --- Components ---

        const SafeMarkdown = ({ content, fontSize, isUser }) => {
            const [html, setHtml] = useState('');
            const containerRef = useRef(null);

            useEffect(() => {
                try {
                    if (typeof marked === 'function') setHtml(marked(content));
                    else if (typeof marked !== 'undefined' && typeof marked.parse === 'function') setHtml(marked.parse(content));
                    else setHtml(content);
                } catch (e) { setHtml(content); }
            }, [content]);
            
            useEffect(() => {
                if(containerRef.current && typeof renderMathInElement === 'function') {
                    try {
                        renderMathInElement(containerRef.current, {
                            delimiters: [
                                {left: "$$", right: "$$", display: true},
                                {left: "$", right: "$", display: false},
                                {left: "\\(", right: "\\)", display: false},
                                {left: "\\[", right: "\\]", display: true}
                            ],
                            throwOnError: false
                        });
                    } catch(e) { console.error("KaTeX render error", e); }
                }
            }, [html]);

            const userClasses = "text-white [&_*]:text-white";
            const aiClasses = "prose prose-sm dark:prose-invert max-w-none leading-relaxed";
            
            return <div ref={containerRef} className={isUser ? userClasses : aiClasses} style={{ fontSize: `${fontSize}px` }} dangerouslySetInnerHTML={{__html: html}} />;
        };

        const MermaidDiagram = ({code, darkMode}) => {
            const [svg, setSvg] = useState('');
            const [err, setErr] = useState(null);
            useEffect(() => {
                setSvg(''); setErr(null);
                if(code && typeof mermaid !== 'undefined') {
                    const id = `mermaid-${Date.now()}`;
                    const run = async () => {
                        try {
                            mermaid.initialize({startOnLoad:true, theme:darkMode?'dark':'default', securityLevel:'loose', fontFamily:'Zen Maru Gothic', darkMode});
                            const {svg} = await mermaid.render(id, code);
                            setSvg(svg);
                        } catch(e) { console.error(e); setErr('無法繪製圖表'); const el=document.getElementById(id); if(el)el.remove(); }
                    };
                    setTimeout(run, 100);
                }
            }, [code, darkMode]);
            if(err) return <div className="text-red-500 text-sm p-4 bg-red-50 rounded">{err}<br/><span className="text-xs text-gray-500">Code: {code.substring(0,50)}...</span></div>;
            return <div className="w-full overflow-x-auto flex justify-center bg-white dark:bg-slate-800 p-4 rounded-lg" dangerouslySetInnerHTML={{__html:svg}}/>;
        };

        const Icon = ({ children, className = "w-6 h-6" }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>;
        
        const Icons = {
            Languages: () => <Icon><path d="m5 8 6 6"/><path d="m4 14 6-6 2-3"/><path d="M2 5h12"/><path d="M7 2h1"/><path d="m22 22-5-10-5 10"/><path d="M14 18h6"/></Icon>,
            FileText: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></Icon>,
            Type: () => <Icon><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></Icon>,
            UploadCloud: () => <Icon><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></Icon>,
            ArrowRightLeft: () => <Icon><path d="m16 3 4 4-4 4"/><path d="M20 7H4"/><path d="m8 21-4-4 4-4"/><path d="M4 17h16"/></Icon>,
            ArrowLeft: () => <Icon><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></Icon>,
            Copy: () => <Icon><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></Icon>,
            Paste: () => <Icon><rect width="8" height="4" x="8" y="2" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/></Icon>,
            Check: () => <Icon className="w-4 h-4 text-green-500"><polyline points="20 6 9 17 4 12"/></Icon>,
            Volume2: () => <Icon><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></Icon>,
            X: () => <Icon><path d="M18 6 6 18"/><path d="m6 6 12 12"/></Icon>,
            RotateCw: () => <Icon className="w-5 h-5 animate-spin"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 12"/><path d="M21 3v9h-9"/></Icon>,
            Sparkles: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/></Icon>,
            AlertCircle: () => <Icon><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></Icon>,
            Mic: () => <Icon><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="22"/></Icon>,
            Settings: () => <Icon><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Save: () => <Icon><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></Icon>,
            Camera: () => <Icon><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></Icon>,
            Magic: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H1"/><path d="M19 18v4"/><path d="M21 20h-4"/></Icon>,
            List: () => <Icon><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></Icon>,
            Search: () => <Icon><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></Icon>,
            Eye: () => <Icon><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Clock: () => <Icon><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></Icon>,
            Trash: () => <Icon><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></Icon>,
            Zap: () => <Icon><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></Icon>,
            Scissors: () => <Icon><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></Icon>,
            MessageSquare: () => <Icon><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><line x1="9" y1="10" x2="15" y2="10"/><line x1="12" y1="7" x2="12" y2="13"/></Icon>,
            Maximize: () => <Icon><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></Icon>,
            CPU: () => <Icon><rect width="16" height="16" x="4" y="4" rx="2"/><rect width="6" height="6" x="9" y="9"/><path d="M9 1v3"/><path d="M15 1v3"/><path d="M9 20v3"/><path d="M15 20v3"/><path d="M20 9h3"/><path d="M20 14h3"/><path d="M1 9h3"/><path d="M1 14h3"/></Icon>,
            Image: () => <Icon><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></Icon>,
            Code: () => <Icon><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></Icon>,
            Download: () => <Icon><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></Icon>,
            MessageSquarePlus: () => <Icon><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><line x1="9" y1="10" x2="15" y2="10"/><line x1="12" y1="7" x2="12" y2="13"/></Icon>,
            Book: () => <Icon><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></Icon>,
            Columns: () => <Icon><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="12" y1="3" x2="12" y2="21"/></Icon>,
            Monitor: () => <Icon><rect width="20" height="14" x="2" y="3" rx="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></Icon>,
            FileDown: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m9 15 3 3 3-3"/></Icon>,
            FileUp: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 12v6"/><path d="m9 15 3-3 3 3"/></Icon>,
            Palette: () => <Icon><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></Icon>,
            Scaling: () => <Icon><path d="M16 16l5 5"/><path d="M15 21h6v-6"/><path d="M21 9v-6h-6"/><path d="M21 3l-5 5"/><path d="M3 9v-6h6"/><path d="M3 3l5 5"/><path d="M9 21h-6v-6"/><path d="M3 21l5-5"/></Icon>,
            Moon: () => <Icon><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></Icon>,
            Sun: () => <Icon><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></Icon>,
            Brain: () => <Icon><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"/></Icon>,
            ExternalLink: () => <Icon><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></Icon>,
            Notebook: () => <Icon><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></Icon>,
            Send: () => <Icon><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></Icon>
        };

        const GEMINI_MODELS = [
            {id:'gemini-2.5-flash-preview-09-2025',name:'Flash 2.5 (Preview)'},
            {id:'gemini-1.5-flash',name:'Flash 1.5'},
            {id:'gemini-1.5-pro',name:'Pro 1.5'},
            {id:'gemini-3.0-pro-preview',name:'Pro 3.0 (Preview)'}
        ];
        
        const LANGUAGES = [
            {code:'auto',name:'自動'},
            {code:'zh-TW',name:'繁中'},
            {code:'en',name:'English'},
            {code:'ja',name:'日本語'},
            {code:'ko',name:'韓語'},
            {code:'vi',name:'越南'},
            {code:'th',name:'泰文'},
            {code:'nan',name:'台語'},
            {code:'yue',name:'粵語'},
            {code:'fr',name:'法文'},
            {code:'de',name:'德文'},
            {code:'nl',name:'荷蘭文'}
        ];
        const TASKS = [
            {id:'notes',name:'筆記',icon:<Icons.Notebook/>,btnColor:'bg-teal-600'},
            {id:'translate',name:'翻譯',icon:<Icons.Languages/>,btnColor:'bg-blue-600'},
            {id:'summarize',name:'摘要',icon:<Icons.List/>,btnColor:'bg-orange-500'},
            {id:'polish',name:'潤飾',icon:<Icons.Magic/>,btnColor:'bg-purple-600'},
            {id:'grammar',name:'文法',icon:<Icons.Search/>,btnColor:'bg-emerald-600'},
            {id:'analyze',name:'分析',icon:<Icons.Brain/>,btnColor:'bg-pink-600'},
            {id:'mindmap',name:'心智圖',icon:<Icons.Brain/>,btnColor:'bg-indigo-600'}
        ];
        const TONES = [{id:'standard',name:'標準'},{id:'formal',name:'禮貌'},{id:'casual',name:'輕鬆'},{id:'academic',name:'專業'},{id:'creative',name:'優美'}];
        
        const FALLBACK_MODEL = 'gemini-2.5-flash-preview-09-2025';

        const Toast = ({ message, type, onClose }) => {
            useEffect(() => { const timer = setTimeout(onClose, 3000); return () => clearTimeout(timer); }, [onClose]);
            return <div className={`fixed bottom-4 left-1/2 -translate-x-1/2 px-4 py-2 rounded-full shadow-lg text-white text-sm font-bold flex items-center gap-2 z-[100] animate-slide-up ${type==='success'?'bg-slate-800/90':'bg-red-500/90'}`}>{type==='success'?<Icons.Check className="w-4 h-4 text-green-400"/>:<Icons.AlertCircle className="w-4 h-4 text-white"/>}{message}</div>;
        };

        function App() {
            const [mode, setMode] = useState('text');
            const [currentTask, setCurrentTask] = useState('notes');
            const [sourceText, setSourceText] = useState('');
            const [translatedText, setTranslatedText] = useState('');
            const [sourceLang, setSourceLang] = useState('auto');
            const [targetLang, setTargetLang] = useState('zh-TW');
            const [selectedTone, setSelectedTone] = useState('standard');
            const [isLoading, setIsLoading] = useState(false);
            const [loadingStatus, setLoadingStatus] = useState('');
            const [errorMsg, setErrorMsg] = useState('');
            const [fileName, setFileName] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [showHistory, setShowHistory] = useState(false);
            const [showBigText, setShowBigText] = useState(false);
            const [isRealTime, setIsRealTime] = useState(false);
            const [isMarkdownMode, setIsMarkdownMode] = useState(true);
            const [usePdfVision, setUsePdfVision] = useState(false);
            const [fsSize, setFsSize] = useState(24);
            const [globalFontSize, setGlobalFontSize] = useState(16);
            const [fsWidth, setFsWidth] = useState(1000); // Increased default width
            const [aiTemperature, setAiTemperature] = useState(0.7);
            const [bilingualMode, setBilingualMode] = useState(false);
            const [darkMode, setDarkMode] = useState(()=>localStorage.getItem('gemini_dark_mode')==='true');
            const [geminiKey, setGeminiKey] = useState(localStorage.getItem('gemini_api_key')||'');
            const [geminiModel, setGeminiModel] = useState(localStorage.getItem('gemini_model')||'gemini-2.5-flash-preview-09-2025');
            const [history, setHistory] = useState(() => { try { return JSON.parse(localStorage.getItem('translate_history') || '[]'); } catch(e) { return []; } });
            const [chatMessages, setChatMessages] = useState([]);
            const [chatInput, setChatInput] = useState('');
            const [showCropModal, setShowCropModal] = useState(false);
            const [cropImageSrc, setCropImageSrc] = useState(null);
            const [cropSelection, setCropSelection] = useState(null);
            const [showVisualMode, setShowVisualMode] = useState(false);
            const [displayImage, setDisplayImage] = useState(null);
            const [visualBox, setVisualBox] = useState({ x: 50, y: 50, w: 300, h: 'auto' });
            const [visualFontSize, setVisualFontSize] = useState(18);
            const [visualDragging, setVisualDragging] = useState(false);
            const [visualResizing, setVisualResizing] = useState(false);
            const [visualStyle, setVisualStyle] = useState({ color: 'white', bg: 'rgba(0,0,0,0.6)' });
            const dragStartRef = useRef(null);
            const isDraggingRef = useRef(false);
            const imageRef = useRef(null);
            const visualContainerRef = useRef(null);
            const visualDragStartRef = useRef(null);
            const visualResizeStartRef = useRef(null);
            const fileInputRef = useRef(null);
            const cameraInputRef = useRef(null);
            const requestCounter = useRef(0);
            const chatEndRef = useRef(null);
            const [apiProvider, setApiProvider] = useState('gemini');
            const [ollamaUrl, setOllamaUrl] = useState("http://localhost:11434/api/generate");
            const [isListening, setIsListening] = useState(false);
            const [selectionMenu, setSelectionMenu] = useState({ visible: false, x: 0, y: 0, text: '' });
            const [historySearchQuery, setHistorySearchQuery] = useState('');
            const [activeTab, setActiveTab] = useState('general');
            const [toast, setToast] = useState(null);
            const [availableVoices, setAvailableVoices] = useState([]);
            const [selectedVoiceURI, setSelectedVoiceURI] = useState('');
            const [voiceRate, setVoiceRate] = useState(1);
            const [voicePitch, setVoicePitch] = useState(1);
            const [glossary, setGlossary] = useState(() => { try { return JSON.parse(localStorage.getItem('gemini_glossary') || '[]'); } catch(e) { return []; } });
            const [newGlossaryTerm, setNewGlossaryTerm] = useState('');
            const [newGlossaryTrans, setNewGlossaryTrans] = useState('');
            const [customInstruction, setCustomInstruction] = useState(localStorage.getItem('gemini_custom_instruction') || '');
            const [isDragOver, setIsDragOver] = useState(false);
            const fsContentRef = useRef(null);
            const fsInnerRef = useRef(null);
            const recognitionRef = useRef(null);

            // All Helper Functions Defined BEFORE useEffect
            const addToHistory = (src, res, s, t) => setHistory(prev => [{ id: Date.now(), src, res, s, t, timestamp: new Date().toLocaleString() }, ...prev].slice(0, 50));
            const clearHistory = () => { if(confirm("確定要清除所有歷史紀錄嗎？")) { setHistory([]); } };
            const addGlossaryTerm = () => { if(newGlossaryTerm && newGlossaryTrans) { setGlossary([...glossary, { term: newGlossaryTerm, trans: newGlossaryTrans }]); setNewGlossaryTerm(''); setNewGlossaryTrans(''); } };
            const removeGlossaryTerm = (index) => { const newG = [...glossary]; newG.splice(index, 1); setGlossary(newG); };
            
            const showToast = (msg, type = 'success') => { setToast({ message: msg, type }); };

            const handleClearAll = () => {
                if(confirm("確定要清除所有內容（原文、結果、對話）嗎？")) {
                    setSourceText('');
                    setTranslatedText('');
                    setChatMessages([]);
                    setFileName(null);
                    showToast("已清除所有內容", "success");
                }
            };
            
            const runGeminiRequest = async (payload, preferredModel) => {
                const attemptRequest = async (modelId) => {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${geminiKey}`;
                    const options = {
                        method: 'POST', 
                        headers: {'Content-Type': 'application/json'}, 
                        body: JSON.stringify(payload)
                    };
                    return await fetchWithRetry(url, options, 5, 2000, (seconds) => {
                        setLoadingStatus(`系統忙碌 (429)... 倒數 ${seconds} 秒後自動重試`);
                    });
                };

                try {
                    return await attemptRequest(preferredModel);
                } catch (e) {
                    if ((e.message === "404_NOT_FOUND" || e.message === "429_TOO_MANY_REQUESTS") && preferredModel !== FALLBACK_MODEL) {
                         const errorType = e.message === "404_NOT_FOUND" ? "模型不支援" : "系統忙碌";
                         showToast(`${errorType}，自動切換至 Flash 2.5`, "error");
                         return await attemptRequest(FALLBACK_MODEL);
                    }
                    throw e;
                }
            };

            const callAI = async (promptType, textOverride = null) => {
                const textToUse = textOverride !== null ? textOverride : sourceText;
                if (!textToUse.trim()) return;
                
                if (apiProvider === 'mymemory' && promptType !== 'translate') { setErrorMsg("MyMemory 僅支援基礎翻譯"); return; }
                
                const currentRequestId = ++requestCounter.current;
                setIsLoading(true);
                setErrorMsg('');
                if (!isRealTime && textOverride === null) setTranslatedText('');
                
                const tName = LANGUAGES.find(l=>l.code===targetLang)?.name || targetLang;
                const sName = sourceLang === 'auto' ? 'Auto Detect' : LANGUAGES.find(l => l.code === sourceLang)?.name;
                const toneInfo = TONES.find(t => t.id === selectedTone)?.name || 'Standard';
                
                const now = new Date().toLocaleString('zh-TW', { timeZone: 'Asia/Taipei' });
                let sys = `Current DateTime: ${now}. Task: ${promptType}. Target: ${tName}. Tone: ${toneInfo}. Input: ${textToUse}.`;
                
                if(promptType==='translate') {
                    if (targetLang === 'nan') {
                        sys = `Current DateTime: ${now}. Translate the following text to Taiwanese Hokkien (台語). You may use Traditional Chinese characters (漢字) or Pe̍h-ōe-jī (POJ) mixed as appropriate for natural Taiwanese reading. Source: Auto. Tone: ${toneInfo}. Output ONLY the translated result in Markdown. Text:\n${textToUse}`;
                    } else if (targetLang === 'yue') {
                        sys = `Current DateTime: ${now}. Translate the following text to Cantonese (粵語). Use Traditional Chinese characters. Source: Auto. Tone: ${toneInfo}. Output ONLY the translated result in Markdown. Text:\n${textToUse}`;
                    } else {
                        sys = `Current DateTime: ${now}. Translate the following text to ${tName}. Source language: Auto. Tone: ${toneInfo}. Output ONLY the translated result in Markdown format. Text to translate:\n${textToUse}`;
                    }
                } else if(promptType==='mindmap') {
                    sys = `Current DateTime: ${now}. Generate a Mind Map for the following text using Mermaid JS syntax (mindmap). Output ONLY the code block starting with \`\`\`mermaid. Do NOT include intro/outro. Use ${tName} for node labels. Text to analyze:\n${textToUse}`;
                }
                
                if(glossary.length>0) sys += `\nGlossary:${JSON.stringify(glossary)}`;
                if(customInstruction) sys += `\nSystem Instruction:${customInstruction}`;

                try {
                    let out = "";
                    if(apiProvider === 'gemini') {
                        if(!geminiKey) { setShowSettings(true); throw new Error("請輸入 API Key"); }
                        
                        const safetySettings = [
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
                        ];

                        const payload = {
                            contents:[{parts:[{text:sys}]}], 
                            generationConfig:{temperature:aiTemperature},
                            safetySettings: safetySettings
                        };

                        const res = await runGeminiRequest(payload, geminiModel);
                        
                        const candidate = res.candidates?.[0];
                        if (!candidate) {
                           throw new Error("No response from AI. Please check API Key or Model.");
                        }
                        if (candidate.finishReason !== "STOP" && !candidate.content) {
                           throw new Error(`AI response blocked. Reason: ${candidate.finishReason}`);
                        }
                        
                        out = candidate.content?.parts?.[0]?.text || "Error: Empty content";
                    } else if (apiProvider === 'mymemory' && promptType === 'translate') {
                        out = await performTranslation(textToUse, sourceLang, targetLang);
                    } else if (apiProvider === 'ollama') {
                        const res = await fetch(ollamaUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ model: 'gemma:2b', prompt: sys, stream: false }) });
                        const data = await res.json();
                        out = data.response;
                    }
                    
                    if(currentRequestId === requestCounter.current) {
                        if(promptType==='mindmap') {
                            let cleaned = out;
                            if(cleaned.includes('```mermaid')) {
                                cleaned = cleaned.split('```mermaid')[1];
                            } else if(cleaned.includes('```')) {
                                cleaned = cleaned.split('```')[1]; 
                            }
                            if(cleaned.includes('```')) {
                                cleaned = cleaned.split('```')[0];
                            }
                            cleaned = cleaned.trim();
                            if (!cleaned.startsWith('mindmap')) {
                                cleaned = 'mindmap\n' + cleaned;
                            } else {
                                const firstLineEnd = cleaned.indexOf('\n');
                                if (firstLineEnd === -1) {
                                    cleaned = cleaned.replace('mindmap', 'mindmap\n');
                                } else {
                                    const firstLine = cleaned.substring(0, firstLineEnd).trim();
                                    if (firstLine !== 'mindmap') {
                                         cleaned = cleaned.replace('mindmap', 'mindmap\n');
                                    }
                                }
                            }
                            setTranslatedText(cleaned);
                        } else {
                            setTranslatedText(out);
                        }
                        if(!out.startsWith('Error') && !out.startsWith('此模式')) addToHistory(textToUse, out, sourceLang, targetLang);
                    }
                } catch(e) { 
                    if(currentRequestId === requestCounter.current) {
                        setErrorMsg(e.message); 
                        setTranslatedText(`錯誤: ${e.message}\n請嘗試更換模型或檢查設定。`);
                    }
                }
                if(currentRequestId === requestCounter.current) setIsLoading(false);
            };

            const processFile = async (f) => {
                if(!f)return; setFileName(f.name); 
                if(f.type.startsWith('image/')) {
                      const r = new FileReader(); r.onload = e => { setCropImageSrc(e.target.result); setDisplayImage(e.target.result); setShowCropModal(true); }; r.readAsDataURL(f);
                      return;
                }
                setMode('text'); setIsLoading(true); setLoadingStatus('讀取中...'); setErrorMsg('');
                try {
                    let text = "";
                    if(f.name.endsWith('.pdf')) {
                        const ab = await f.arrayBuffer();
                        if(usePdfVision && geminiKey) {
                            setLoadingStatus('AI 視覺讀取 PDF...');
                            const imgs = await renderPdfToImages(ab.slice(0));
                            text = await performGeminiOCR_Multi(imgs.images || imgs); 
                        } else {
                            const pdf = await loadPdfWithPassword(ab.slice(0));
                            for(let i=1;i<=pdf.numPages;i++) text += (await (await pdf.getPage(i)).getTextContent()).items.map(s=>s.str).join(' ')+'\n';
                            if((!text || text.length<50) && geminiKey) {
                                setLoadingStatus('文字過少，切換至 AI 視覺讀取...');
                                const imgs = await renderPdfToImages(ab.slice(0));
                                text = await performGeminiOCR_Multi(imgs.images || imgs);
                            }
                        }
                    } else if(f.name.endsWith('.docx')) {
                        text = (await window.mammoth.extractRawText({arrayBuffer:await f.arrayBuffer()})).value;
                    } else {
                        text = await new Promise(r=>{const rd=new FileReader(); rd.onload=e=>r(e.target.result); rd.readAsText(f);});
                    }
                    if(!text.trim()) throw new Error("無法讀取文字");
                    setSourceText(text);
                    callAI(currentTask, text);
                } catch(e) { console.error(e); setErrorMsg(e.message||"讀取失敗"); setIsLoading(false); }
            };
            
            const handleFileChange = (e) => { 
                const f = e.target.files[0]; 
                if(f) processFile(f); 
                e.target.value = ''; 
            };

            const performGeminiOCR = async (file, task) => {
                const b64 = await compressImage(file);
                let promptText = "OCR this image. Output text only.";
                if (task === 'analyze') promptText = "Describe this image in detail in Traditional Chinese. If there is text, transcribe it.";
                
                const payload = {contents:[{parts:[{text: promptText},{inline_data:{mime_type:'image/jpeg',data:b64}}]}]};
                const res = await runGeminiRequest(payload, geminiModel);
                return res.candidates?.[0]?.content?.parts?.[0]?.text || "";
            };

            const performGeminiOCR_Multi = async (imgs) => {
                const parts = [{text:"OCR these pages sequentially. Output text only."}];
                imgs.forEach(b64 => parts.push({inline_data:{mime_type:'image/jpeg',data:b64}}));
                const payload = {contents:[{parts}]};
                const res = await runGeminiRequest(payload, geminiModel);
                return res.candidates?.[0]?.content?.parts?.[0]?.text || "";
            };
            
            const performLegacyOCR = async (file) => {
                 setLoadingStatus('Tesseract 辨識中...');
                 const { data: { text } } = await Tesseract.recognize(file, 'chi_tra+eng');
                 return text;
            };

            const runOCR = async (file) => {
                setShowCropModal(false); setIsLoading(true); setSourceText(''); setErrorMsg('');
                try {
                    let text = "";
                    if(geminiKey) {
                        text = await performGeminiOCR(file, currentTask); // Use updated performGeminiOCR with task
                    } else {
                        text = await performLegacyOCR(file);
                    }
                    
                    if(!text.trim()) throw new Error("無法辨識文字或圖片內容");
                    setSourceText(text);
                    callAI(currentTask, text);
                } catch(e) { setErrorMsg(e.message); setIsLoading(false); }
            };

            const performTranslation = async (text, sLangCode, tLangCode) => { 
                const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${sLangCode}|${tLangCode}`; 
                const res = await fetch(url); 
                const data = await res.json(); 
                return data.responseData.translatedText; 
            };

            const switchToChat = () => {
                setMode('conversation');
                if(translatedText && chatMessages.length===0) setChatMessages([{role:'model', text:`已為您準備好內容。您可以針對剛才的分析結果提問。`}]);
            };

            const sendChat = async () => {
                if(!chatInput.trim())return;
                if(apiProvider === 'gemini' && !geminiKey) {
                    setChatMessages(p=>[...p, {role:'user',text:chatInput}, {role:'model',text:"請先在設定中輸入 API Key 才能使用對話功能。"}]);
                    setChatInput('');
                    return;
                }

                const newUserMsg = {role:'user',text:chatInput}; 
                setChatMessages(prev => [...prev, newUserMsg]); 
                setChatInput(''); 
                setIsLoading(true);

                try {
                    const now = new Date().toLocaleString('zh-TW', { timeZone: 'Asia/Taipei' });
                    
                    let historyStr = '';
                    chatMessages.forEach(m => {
                        historyStr += `${m.role === 'user' ? 'User' : 'Model'}: ${m.text}\n`;
                    });

                    let ctx = `Current DateTime: ${now}.\nContext:\nSource:${sourceText}\nResult:${translatedText}`;
                    if(customInstruction) ctx += `\nSystem Instruction:${customInstruction}`;
                    ctx += `\n\nConversation History:\n${historyStr}`;
                    ctx += `User: ${newUserMsg.text}\nModel:`;
                    
                    const safetySettings = [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
                    ];

                    const payload = {
                        contents:[{parts:[{text:ctx}]}],
                        safetySettings: safetySettings
                    };

                    const res = await runGeminiRequest(payload, geminiModel);
                    
                    const candidate = res.candidates?.[0];
                    let responseText = "Error";
                    if (!candidate) {
                        responseText = "Error: No response from AI.";
                    } else if (candidate.finishReason !== "STOP" && !candidate.content) {
                        responseText = `Error: Blocked by safety settings (${candidate.finishReason})`;
                    } else {
                        responseText = candidate.content?.parts?.[0]?.text || "Error";
                    }

                    setChatMessages(p=>[...p,{role:'model',text:responseText}]);
                } catch(e) { 
                    let errMsg = "Error: " + e.message;
                    if (e.message === "429_TOO_MANY_REQUESTS") {
                        errMsg = "系統目前流量過大，請稍後再試。";
                    }
                    setChatMessages(p=>[...p,{role:'model',text:errMsg}]); 
                }
                setIsLoading(false);
            };

             const getClientCoordinates = (e) => { const r = imageRef.current.getBoundingClientRect(); const c = e.touches?e.touches[0]:e; return {x: c.clientX-r.left, y: c.clientY-r.top}; };
            const handleCropStart = (e) => { const coords = getClientCoordinates(e); setCropSelection({x:coords.x,y:coords.y,w:0,h:0}); isDraggingRef.current=true; dragStartRef.current=coords; };
            const handleCropMove = (e) => { if(!isDraggingRef.current)return; const coords = getClientCoordinates(e); const r = imageRef.current.getBoundingClientRect(); const cx = Math.min(Math.max(0, coords.x), r.width); const cy = Math.min(Math.max(0, coords.y), r.height); setCropSelection({x:Math.min(dragStartRef.current.x,cx),y:Math.min(dragStartRef.current.y,cy),w:Math.abs(cx-dragStartRef.current.x),h:Math.abs(cy-dragStartRef.current.y)}); };
            const handleCropEnd = () => isDraggingRef.current = false;
            const handleFullImageConfirm = async () => { const res = await fetch(cropImageSrc); const blob = await res.blob(); const file = new File([blob], "full.jpg", {type:'image/jpeg'}); runOCR(file); };
            const handleCropConfirm = () => {
                if(!cropSelection) return;
                const img = imageRef.current; const canvas = document.createElement('canvas');
                const scaleX = img.naturalWidth / img.clientWidth; const scaleY = img.naturalHeight / img.clientHeight;
                canvas.width = cropSelection.w * scaleX; canvas.height = cropSelection.h * scaleY;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, cropSelection.x*scaleX, cropSelection.y*scaleY, cropSelection.w*scaleX, cropSelection.h*scaleY, 0, 0, canvas.width, canvas.height);
                canvas.toBlob(blob => { runOCR(new File([blob], "crop.jpg", {type:'image/jpeg'})); }, 'image/jpeg');
            };
            
             const handleVisualDragStart = (e) => {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                visualDragStartRef.current = { x: clientX, y: clientY };
                setVisualDragging(true);
            };
            const handleVisualResizeStart = (e) => {
                e.preventDefault(); e.stopPropagation();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                visualResizeStartRef.current = { startX: clientX, startY: clientY, startW: visualBox.w, startH: typeof visualBox.h === 'number' ? visualBox.h : 200, fontSize: visualFontSize };
                setVisualResizing(true);
            };
            const handleVisualMove = (e) => {
                if (visualDragging && visualDragStartRef.current && visualContainerRef.current) {
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const containerRect = visualContainerRef.current.getBoundingClientRect();
                    const deltaX = ((clientX - visualDragStartRef.current.x) / containerRect.width) * 100;
                    const deltaY = ((clientY - visualDragStartRef.current.y) / containerRect.height) * 100;
                    setVisualBox(prev => ({ ...prev, x: Math.max(0, Math.min(100, prev.x + deltaX)), y: Math.max(0, Math.min(100, prev.y + deltaY)) }));
                    visualDragStartRef.current = { x: clientX, y: clientY };
                } else if (visualResizing && visualResizeStartRef.current) {
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const deltaX = clientX - visualResizeStartRef.current.startX;
                    const deltaY = clientY - visualResizeStartRef.current.startY;
                    const newWidth = Math.max(100, visualResizeStartRef.current.startW + deltaX);
                    const newHeight = Math.max(50, visualResizeStartRef.current.startH + deltaY);
                    const scaleRatio = newWidth / visualResizeStartRef.current.startW;
                    const newFontSize = Math.max(10, Math.min(100, visualResizeStartRef.current.fontSize * scaleRatio));
                    setVisualBox(prev => ({ ...prev, w: newWidth, h: newHeight }));
                    setVisualFontSize(newFontSize);
                }
            };
            const handleVisualEnd = () => { setVisualDragging(false); setVisualResizing(false); visualDragStartRef.current = null; visualResizeStartRef.current = null; };
            const handleSaveVisualImage = async () => {
                if (!visualContainerRef.current) return;
                try {
                    const canvas = await html2canvas(visualContainerRef.current, { useCORS: true, backgroundColor: '#000000' });
                    const link = document.createElement('a'); link.download = `visual_translation_${new Date().getTime()}.png`; link.href = canvas.toDataURL('image/png'); link.click();
                    showToast("圖片已儲存", "success");
                } catch (err) { showToast("儲存失敗", "error"); }
            };
            
            const toggleListening = () => {
                if (isListening) {
                    if (recognitionRef.current) {
                        recognitionRef.current.stop();
                    }
                    setIsListening(false);
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    setErrorMsg("瀏覽器不支援語音辨識");
                    return;
                }

                const recognition = new SpeechRecognition();
                recognitionRef.current = recognition;
                
                let langCode = sourceLang;
                if (langCode === 'auto' || langCode === 'nan' || langCode === 'yue') langCode = 'zh-TW'; 
                
                recognition.lang = langCode;
                recognition.continuous = true;
                recognition.interimResults = true;

                recognition.onstart = () => setIsListening(true);
                recognition.onend = () => setIsListening(false);
                recognition.onerror = (e) => {
                    console.error("Speech recognition error", e);
                    setIsListening(false);
                    showToast("語音辨識錯誤: " + e.error, "error");
                };

                recognition.onresult = (e) => {
                    let final = '';
                    for (let i = e.resultIndex; i < e.results.length; ++i) {
                        if (e.results[i].isFinal) {
                            final += e.results[i][0].transcript;
                        }
                    }
                    
                    if (final) {
                        if (mode === 'conversation') {
                            setChatInput(prev => prev + final);
                        } else {
                            setSourceText(prev => prev + (prev ? ' ' : '') + final);
                        }
                    }
                };

                recognition.start();
            };
            
             const handleSelection = () => { 
                 const selection = window.getSelection(); 
                 const text = selection.toString().trim(); 
                 if (text.length > 0 && (selection.anchorNode.parentElement.tagName === 'TEXTAREA' || selection.anchorNode.parentElement.closest('.prose'))) { 
                     const range = selection.getRangeAt(0); 
                     const rect = range.getBoundingClientRect(); 
                     setSelectionMenu({ visible: true, x: rect.left + window.scrollX + rect.width / 2, y: rect.top + window.scrollY - 10, text: text }); 
                 } else { 
                     setSelectionMenu({ ...selectionMenu, visible: false }); 
                 } 
             };
            
            const handleSelectionAction = async (action) => { 
                setSelectionMenu({ ...selectionMenu, visible: false }); 
                const text = selectionMenu.text; 
                if (action === 'explain') { await callAI('grammar', `Explain: "${text}"`); } 
                else if (action === 'glossary') { setNewGlossaryTerm(text); setShowSettings(true); setActiveTab('data'); } 
                else if (action === 'speak') { speak(text, targetLang); } 
            };
            
            const copy = (t, isS) => { if(!t)return; navigator.clipboard.writeText(t); showToast(isS?"已複製原文":"已複製譯文", 'success'); };
            const speak = (t, l) => { if(!t)return; window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(t); u.lang = LANGUAGES.find(lang => lang.code === l)?.codeFull || l; u.rate = voiceRate; u.pitch = voicePitch; if (selectedVoiceURI) { const v = availableVoices.find(v => v.voiceURI === selectedVoiceURI); if (v) u.voice = v; } window.speechSynthesis.speak(u); };
            
            const handleDownload = () => { 
                if (!translatedText) return; 
                const blob = new Blob([translatedText], { type: 'text/plain' }); 
                const url = window.URL.createObjectURL(blob); 
                const a = document.createElement('a'); 
                a.href = url; 
                a.download = `translation_${new Date().toISOString().slice(0,10)}.md`; 
                document.body.appendChild(a); 
                a.click(); 
                document.body.removeChild(a); 
                window.URL.revokeObjectURL(url); 
            };

            const handleExportData = () => {
                const data = { settings: { geminiKey, geminiModel, customInstruction, voiceRate, voicePitch, fsSize, globalFontSize, aiTemperature }, glossary, history, chatMessages };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `gemini_backup_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); window.URL.revokeObjectURL(url);
                showToast("備份已下載", "success");
            };

            const handleImportData = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.settings) {
                            if (data.settings.geminiKey) setGeminiKey(data.settings.geminiKey);
                            if (data.settings.geminiModel) setGeminiModel(data.settings.geminiModel);
                            if (data.settings.customInstruction) setCustomInstruction(data.settings.customInstruction);
                            if (data.settings.voiceRate) setVoiceRate(data.settings.voiceRate);
                            if (data.settings.voicePitch) setVoicePitch(data.settings.voicePitch);
                            if (data.settings.fsSize) setFsSize(data.settings.fsSize);
                            if (data.settings.globalFontSize) setGlobalFontSize(data.settings.globalFontSize);
                            if (data.settings.aiTemperature) setAiTemperature(data.settings.aiTemperature);
                        }
                        if (data.glossary) setGlossary(data.glossary);
                        if (data.history) setHistory(data.history);
                        if (data.chatMessages) setChatMessages(data.chatMessages);
                        showToast("設定與資料匯入成功！", "success");
                    } catch (err) { showToast("匯入失敗：檔案格式錯誤", "error"); }
                };
                reader.readAsText(file);
            };
            
            const handleScreenCapture = async () => {
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "never" }, audio: false });
                    const video = document.createElement('video'); video.srcObject = stream; await video.play();
                    const canvas = document.createElement('canvas'); canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d'); ctx.drawImage(video, 0, 0);
                    stream.getTracks().forEach(track => track.stop());
                    canvas.toBlob(blob => { const file = new File([blob], "screenshot.png", { type: 'image/png' }); processFile(file); });
                } catch (e) { showToast("截圖取消或失敗", "error"); }
            };
            
            const handleFullScreenDownload = async () => {
                if (!fsInnerRef.current) return; 
                setIsLoading(true);
                setLoadingStatus('正在產生全螢幕截圖...');
                
                try {
                    const canvas = await html2canvas(fsInnerRef.current, {
                        useCORS: true,
                        backgroundColor: darkMode ? '#0f172a' : '#ffffff',
                        scale: 6, // Increased scale for high resolution
                        logging: false,
                        allowTaint: true,
                        scrollY: -window.scrollY
                    });
                    const link = document.createElement('a');
                    link.download = `fullscreen_capture_${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    showToast("全螢幕截圖已下載", "success");
                } catch (err) {
                    console.error("FS Download Error:", err);
                    showToast("截圖失敗，內容可能過長", "error");
                } finally {
                    setIsLoading(false);
                    setLoadingStatus('');
                }
            };

            const handleScreenshotMsg = async (id) => {
                const element = document.getElementById(id);
                if (!element) return;
                try {
                    const canvas = await html2canvas(element, { useCORS: true, backgroundColor: null, scale: 3 });
                    const link = document.createElement('a');
                    link.download = `chat_capture_${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    showToast("截圖已下載", "success");
                } catch (err) {
                    showToast("截圖失敗", "error");
                }
            };

            const handlePasteClick = async () => {
                try {
                    try {
                        const items = await navigator.clipboard.read();
                        for (const item of items) {
                            if (item.types.some(type => type.startsWith('image/'))) {
                                const type = item.types.find(type => type.startsWith('image/'));
                                const blob = await item.getType(type);
                                const file = new File([blob], "pasted_image.png", { type });
                                processFile(file);
                                showToast("已貼上剪貼簿圖片", "success");
                                return;
                            }
                        }
                    } catch (err) {
                        console.log("Clipboard read() failed or denied, falling back to text.");
                    }

                    const text = await navigator.clipboard.readText();
                    if (text) {
                        setSourceText(prev => prev + text);
                        showToast("已貼上剪貼簿內容", "success");
                    } else {
                        showToast("無法讀取剪貼簿內容", "error");
                    }
                } catch (err) {
                    console.error('Clipboard Error: ', err);
                    showToast("無法讀取剪貼簿，請嘗試使用 Ctrl+V", "error");
                }
            };

            const processFileRef = useRef(processFile);
            useEffect(() => { processFileRef.current = processFile; }, [processFile]);

            useEffect(() => {
                const handleGlobalPaste = (e) => {
                    if (e.clipboardData && e.clipboardData.files.length > 0) {
                        const file = e.clipboardData.files[0];
                        if (file.type.startsWith('image/')) {
                            e.preventDefault();
                            processFileRef.current(file);
                            showToast("已偵測到圖片貼上", "success");
                        }
                    }
                };
                window.addEventListener('paste', handleGlobalPaste);
                return () => window.removeEventListener('paste', handleGlobalPaste);
            }, []);

            useEffect(() => { document.addEventListener('mouseup', handleSelection); document.addEventListener('touchend', handleSelection); return () => { document.removeEventListener('mouseup', handleSelection); document.removeEventListener('touchend', handleSelection); }; }, [selectionMenu]);

            return (
                <div className="pb-12 dark:bg-slate-900 min-h-screen transition-colors flex flex-col">
                    {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
                    <header className="bg-white/90 dark:bg-slate-900/90 backdrop-blur shadow-sm border-b dark:border-slate-800 sticky top-0 z-20 h-14 flex items-center justify-between px-4">
                        <div className="flex items-center gap-2 font-bold text-lg text-slate-800 dark:text-white"><Icons.Languages className="text-blue-600"/> Gemini 助手 <span className="text-xs font-normal text-slate-400 bg-slate-100 dark:bg-slate-800 px-1.5 py-0.5 rounded">Pro</span></div>
                        <div className="flex gap-2">
                            <button onClick={handleClearAll} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800" title="清除所有內容"><Icons.Trash className="text-red-500"/></button>
                            <button onClick={()=>setDarkMode(!darkMode)} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800">{darkMode?<Icons.Sun className="text-yellow-400"/>:<Icons.Moon className="text-slate-600"/>}</button>
                            <button onClick={()=>setShowHistory(true)} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800"><Icons.Clock/></button>
                            <button onClick={()=>setShowSettings(true)} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800"><Icons.Settings/></button>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto px-4 py-6 gap-4 flex-1 flex flex-col w-full">
                          <div className="flex flex-col gap-3">
                            <div className="flex bg-white dark:bg-slate-800 p-1 rounded-lg border dark:border-slate-700 w-full md:w-fit">
                                <button onClick={()=>setMode('text')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='text'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.Type className="w-4 h-4"/>文字</button>
                                <button onClick={()=>setMode('file')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='file'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.FileText className="w-4 h-4"/>文件</button>
                                <button onClick={()=>setMode('conversation')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='conversation'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.MessageSquare className="w-4 h-4"/>對話</button>
                            </div>
                            {mode!=='conversation' && <div className="grid grid-cols-4 md:grid-cols-7 gap-2 bg-white dark:bg-slate-800 p-1 rounded-lg border dark:border-slate-700 w-full">
                                {TASKS.map(t => (
                                    <button 
                                        key={t.id} 
                                        onClick={() => { setCurrentTask(t.id); setTranslatedText(''); setErrorMsg(''); }} 
                                        className={`px-1 py-2 md:px-3 text-xs md:text-sm font-bold rounded-md flex flex-col md:flex-row items-center justify-center gap-1 md:gap-2 transition-all ${currentTask === t.id ? 'bg-slate-800 text-white' : 'text-slate-500 hover:bg-slate-50 dark:hover:bg-slate-700'}`}
                                    >
                                        {t.icon} 
                                        <span>{t.name}</span>
                                    </button>
                                ))}
                            </div>}
                        </div>

                        {mode !== 'conversation' && (
                            <div className="bg-white dark:bg-slate-800 p-2 rounded-lg border dark:border-slate-700 flex flex-wrap gap-2 items-center justify-between">
                                <div className="flex items-center gap-2 flex-1 min-w-[200px]">
                                    <select value={sourceLang} onChange={(e)=>setSourceLang(e.target.value)} className="p-1.5 rounded-md border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white flex-1">
                                        {LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name}</option>)}
                                    </select>
                                    <button onClick={()=>{const t=targetLang; setTargetLang(sourceLang==='auto'?'en':sourceLang); setSourceLang(t);}} className="p-1.5 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-full text-slate-400"><Icons.ArrowRightLeft className="w-4 h-4"/></button>
                                    <select value={targetLang} onChange={(e)=>setTargetLang(e.target.value)} className="p-1.5 rounded-md border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white flex-1">
                                        {LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name}</option>)}
                                    </select>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-xs text-slate-400 font-bold hidden md:inline">語氣:</span>
                                    <select value={selectedTone} onChange={(e)=>setSelectedTone(e.target.value)} className="p-1.5 rounded-md border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white min-w-[100px]">
                                        {TONES.map(t=><option key={t.id} value={t.id}>{t.name}</option>)}
                                    </select>
                                </div>
                            </div>
                        )}

                        {mode!=='conversation' && (
                            <div className="grid md:grid-cols-2 gap-4 flex-1 min-h-[500px]">
                                <div className="flex flex-col bg-white dark:bg-slate-800 rounded-xl border dark:border-slate-700 overflow-hidden relative">
                                    <div className="px-3 py-2 bg-slate-50 dark:bg-slate-800 border-b dark:border-slate-700 flex justify-between items-center">
                                        <div className="flex items-center gap-2">
                                            <span className="text-xs font-bold text-slate-500">原文</span>
                                            {isListening && <span className="text-xs text-red-500 animate-pulse">● 聽寫中</span>}
                                        </div>
                                        <div className="flex gap-1">
                                            <input type="file" ref={cameraInputRef} className="hidden" accept="image/*" onChange={handleFileChange} />
                                            <button onClick={handlePasteClick} className="p-1 text-slate-400 hover:text-blue-600" title="貼上"><Icons.Paste className="w-4 h-4"/></button>
                                            <button onClick={handleScreenCapture} className="p-1 text-slate-400 hover:text-blue-600" title="截圖"><Icons.Scissors className="w-4 h-4"/></button>
                                            <button onClick={() => cameraInputRef.current?.click()} className="p-1 text-slate-400 hover:text-blue-600" title="上傳圖片/拍照"><Icons.Camera className="w-4 h-4"/></button>
                                            <button onClick={toggleListening} className={`p-1 ${isListening ? 'text-red-500' : 'text-slate-400 hover:text-blue-600'}`} title="語音輸入"><Icons.Mic className="w-4 h-4"/></button>
                                            <button onClick={()=>setSourceText('')} className="p-1 text-slate-400 hover:text-red-500" title="清除"><Icons.X className="w-4 h-4"/></button>
                                        </div>
                                    </div>
                                    <textarea value={sourceText} onChange={e=>setSourceText(e.target.value)} className="flex-1 p-4 bg-transparent outline-none resize-none dark:text-slate-200 text-lg" placeholder="輸入文字..." style={{fontSize: `${globalFontSize}px`}}/>
                                    {mode==='file' && !sourceText && <div onClick={()=>fileInputRef.current.click()} className={`absolute inset-0 flex flex-col items-center justify-center bg-slate-50/80 dark:bg-slate-900/80 cursor-pointer border-2 border-dashed m-4 rounded-xl transition-colors ${isDragOver ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-slate-300 dark:border-slate-700'}`} onDragOver={e=>{e.preventDefault();setIsDragOver(true)}} onDragLeave={()=>{setIsDragOver(false)}} onDrop={e=>{e.preventDefault();setIsDragOver(false);processFile(e.dataTransfer.files[0])}}><Icons.UploadCloud className="w-8 h-8 text-blue-400"/><span className="text-sm text-slate-500 mt-2">上傳文件 / 圖片</span><input type="file" ref={fileInputRef} className="hidden" onChange={handleFileChange}/></div>}
                                </div>
                                <div className="flex flex-col bg-white dark:bg-slate-800 rounded-xl border dark:border-slate-700 overflow-hidden relative">
                                    <div className="px-3 py-2 bg-slate-50 dark:bg-slate-800 border-b dark:border-slate-700 flex justify-between items-center">
                                        <span className="text-xs font-bold text-slate-500">結果</span>
                                        <div className="flex gap-1">
                                            {displayImage && <button onClick={()=>setShowVisualMode(true)} className="p-1 text-slate-400 hover:text-blue-600"><Icons.Image className="w-4 h-4"/></button>}
                                            {currentTask!=='mindmap' && <button onClick={()=>setIsMarkdownMode(!isMarkdownMode)} className="p-1 text-slate-400 hover:text-blue-600"><Icons.Code className="w-4 h-4"/></button>}
                                            <button onClick={handleDownload} className="p-1 text-slate-400 hover:text-blue-600" title="下載"><Icons.Download className="w-4 h-4"/></button>
                                            <button onClick={()=>copy(translatedText, false)} className="p-1 text-slate-400 hover:text-blue-600" title="複製"><Icons.Copy className="w-4 h-4"/></button>
                                            <button onClick={()=>speak(translatedText, targetLang)} className="p-1 text-slate-400 hover:text-blue-600" title="朗讀"><Icons.Volume2 className="w-4 h-4"/></button>
                                            <button onClick={()=>setShowBigText(true)} className="p-1 text-slate-400 hover:text-blue-600" title="全螢幕"><Icons.Maximize className="w-4 h-4"/></button>
                                        </div>
                                    </div>
                                    <div className="flex-1 overflow-y-auto bg-slate-50/30 dark:bg-slate-900/30 relative">
                                        {isLoading && <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/80 dark:bg-slate-900/80 z-10"><Icons.RotateCw className="w-8 h-8 text-blue-500 animate-spin mb-2"/><span className="text-xs font-bold text-blue-500">{loadingStatus}</span></div>}
                                        {currentTask==='mindmap' ? <div className="p-4"><MermaidDiagram code={translatedText} darkMode={darkMode}/></div> : isMarkdownMode ? <div className="p-4"><SafeMarkdown content={translatedText} fontSize={globalFontSize}/></div> : <textarea readOnly value={translatedText} className="w-full h-full p-4 bg-transparent outline-none resize-none text-lg dark:text-slate-200" style={{fontSize: `${globalFontSize}px`}}/>}
                                    </div>
                                    <div className="absolute bottom-3 right-3"><button onClick={switchToChat} className="bg-blue-600 text-white text-xs px-3 py-1.5 rounded-full shadow hover:bg-blue-700 flex items-center gap-1"><Icons.MessageSquare className="w-3 h-3"/> 針對結果對話</button></div>
                                </div>
                            </div>
                        )}

                        {mode === 'conversation' && (
                            <div className="bg-white dark:bg-slate-800 rounded-xl border dark:border-slate-700 flex-1 flex flex-col min-h-[500px] relative overflow-hidden">
                                {/* Header for Chat */}
                                <div className="flex items-center justify-between p-3 border-b dark:border-slate-700 bg-white/50 dark:bg-slate-800/50 backdrop-blur">
                                     <button onClick={() => setMode('text')} className="flex items-center gap-2 text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-700 px-3 py-1.5 rounded-lg transition-colors group">
                                        <Icons.ArrowLeft className="w-4 h-4 group-hover:-translate-x-1 transition-transform"/>
                                        <span className="text-sm font-bold">返回文件</span>
                                     </button>
                                </div>
                                
                                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                                    {chatMessages.map((m,i)=><div key={i} className={`flex ${m.role==='user'?'justify-end':'justify-start'}`}>
                                        <div id={`msg-${i}`} className={`max-w-[85%] p-3 rounded-2xl text-sm flex flex-col gap-1 ${m.role==='user'?'bg-blue-600 text-white':'bg-slate-100 dark:bg-slate-700 dark:text-slate-200'}`}>
                                            <SafeMarkdown content={m.text} fontSize={globalFontSize} isUser={m.role==='user'}/>
                                            {m.role==='model' && (
                                                <div className="flex items-center gap-2 mt-1 self-end">
                                                     <button onClick={() => copy(m.text)} className="text-slate-400 hover:text-blue-500" title="複製"><Icons.Copy className="w-3 h-3" /></button>
                                                     <button onClick={() => handleScreenshotMsg(`msg-${i}`)} className="text-slate-400 hover:text-blue-500" title="截圖"><Icons.Camera className="w-3 h-3" /></button>
                                                     <button onClick={() => speak(m.text, targetLang)} className="text-slate-400 hover:text-blue-500" title="朗讀"><Icons.Volume2 className="w-3 h-3" /></button>
                                                </div>
                                            )}
                                        </div>
                                    </div>)}
                                    <div ref={chatEndRef}/>
                                </div>
                                <div className="p-3 border-t dark:border-slate-700 flex gap-2 items-center">
                                    <button onClick={toggleListening} className={`p-2 rounded-full transition-colors ${isListening ? 'bg-red-100 text-red-500' : 'bg-slate-100 text-slate-500 hover:bg-slate-200 dark:bg-slate-700 dark:text-slate-300'}`} title="語音輸入"><Icons.Mic className="w-5 h-5"/></button>
                                    <textarea 
                                        value={chatInput} 
                                        onChange={e=>setChatInput(e.target.value)} 
                                        onKeyDown={e=>{if(e.key==='Enter' && !e.shiftKey){e.preventDefault();sendChat();}}} 
                                        className="flex-1 p-2 bg-slate-50 dark:bg-slate-900 border dark:border-slate-600 rounded-lg outline-none dark:text-white chat-input resize-none hide-scrollbar" 
                                        placeholder="輸入訊息..."
                                    />
                                    <button onClick={sendChat} disabled={isLoading} className="p-2 bg-blue-600 text-white rounded-lg">{isLoading?<Icons.RotateCw className="w-5 h-5 animate-spin"/>:<Icons.Send className="w-5 h-5"/>}</button>
                                </div>
                            </div>
                        )}

                        {mode!=='conversation' && <button onClick={()=>callAI(currentTask)} disabled={isLoading||!sourceText} className={`w-full py-3 rounded-xl font-bold text-white shadow transition-all active:scale-[0.99] disabled:opacity-50 ${TASKS.find(t=>t.id===currentTask)?.btnColor}`}>{isLoading?'處理中...':TASKS.find(t=>t.id===currentTask)?.name}</button>}
                        {errorMsg && <div className="text-red-500 text-xs text-center bg-red-50 p-2 rounded">{errorMsg}</div>}
                    </main>
                    
                    {showHistory && (
                        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 animate-in fade-in" onClick={() => setShowHistory(false)}>
                            <div className="bg-white dark:bg-slate-800 w-full max-w-md p-6 rounded-2xl shadow-xl max-h-[80vh] flex flex-col animate-pop-in" onClick={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4 border-b border-slate-100 dark:border-slate-700 pb-3">
                                    <h3 className="font-bold text-lg dark:text-white flex items-center gap-2"><Icons.Clock className="w-5 h-5 text-blue-500"/> 歷史紀錄</h3>
                                    <div className="flex gap-2">
                                        <button onClick={clearHistory} className="text-red-500 text-xs font-bold hover:bg-red-50 dark:hover:bg-red-900/20 px-3 py-1.5 rounded-full transition-colors">清除全部</button>
                                        <button onClick={() => setShowHistory(false)} className="p-1 rounded-full hover:bg-slate-100 dark:hover:bg-slate-700"><Icons.X className="w-5 h-5 text-slate-500" /></button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto space-y-3 pr-1 custom-scrollbar">
                                    {history.length === 0 ? (
                                        <div className="text-center text-slate-400 py-12 flex flex-col items-center">
                                            <Icons.Clock className="w-12 h-12 mb-3 opacity-20"/>
                                            <span>尚無歷史紀錄</span>
                                        </div>
                                    ) : (
                                        history.map(h => (
                                            <div key={h.id} className="group bg-slate-50 dark:bg-slate-900 p-4 rounded-xl border border-slate-100 dark:border-slate-700 cursor-pointer hover:border-blue-300 dark:hover:border-blue-700 hover:shadow-md transition-all" onClick={() => { setSourceText(h.src); setTranslatedText(h.res); setSourceLang(h.s); setTargetLang(h.t); setShowHistory(false); }}>
                                                <div className="flex justify-between text-[10px] uppercase tracking-wider text-slate-400 mb-2">
                                                    <span>{h.timestamp}</span>
                                                    <span className="bg-slate-200 dark:bg-slate-800 px-1.5 py-0.5 rounded text-slate-500 dark:text-slate-400 font-bold">{LANGUAGES.find(l=>l.code===h.s)?.name || h.s} → {LANGUAGES.find(l=>l.code===h.t)?.name || h.t}</span>
                                                </div>
                                                <div className="text-sm text-slate-600 dark:text-slate-300 line-clamp-2 mb-1.5 font-medium">{h.src}</div>
                                                <div className="text-sm text-slate-900 dark:text-slate-100 line-clamp-2 pl-2 border-l-2 border-blue-500">{h.res.substring(0, 100)}...</div>
                                            </div>
                                        ))
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {showSettings && (
                        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4" onClick={()=>setShowSettings(false)}>
                            <div className="bg-white dark:bg-slate-800 w-full max-w-md p-6 rounded-2xl shadow-xl" onClick={e=>e.stopPropagation()}>
                                <h3 className="font-bold text-lg mb-4 dark:text-white">設定</h3>
                                <div className="flex gap-2 border-b border-slate-200 dark:border-slate-700 pb-2 mb-4">
                                    {['general', 'ai', 'voice', 'glossary', 'data'].map(tab => (
                                        <button key={tab} onClick={() => setActiveTab(tab)} className={`px-3 py-1.5 rounded-lg text-sm font-bold capitalize whitespace-nowrap transition-colors ${activeTab === tab ? 'bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-300' : 'text-slate-500 hover:bg-slate-100 dark:text-slate-400 dark:hover:bg-slate-700'}`}>
                                            {tab === 'general' ? '一般' : tab === 'ai' ? 'AI 模型' : tab === 'voice' ? '語音' : tab === 'glossary' ? '術語' : '資料'}
                                        </button>
                                    ))}
                                </div>
                                <div className="space-y-4 max-h-[60vh] overflow-y-auto">
                                    {activeTab === 'general' && (
                                        <div className="space-y-2">
                                            <label className="text-xs font-bold text-slate-500 dark:text-slate-400 mb-1 block">介面字體大小: {globalFontSize}px</label>
                                            <input type="range" min="12" max="32" step="1" value={globalFontSize} onChange={(e) => setGlobalFontSize(parseInt(e.target.value))} className="w-full h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500" />
                                        </div>
                                    )}
                                    {activeTab === 'ai' && (
                                        <div className="space-y-4">
                                            <div><label className="text-xs font-bold text-slate-500 dark:text-slate-400">API Key <a href="https://aistudio.google.com/app/apikey" target="_blank" className="text-blue-500 ml-1">取得免費 Key</a></label><input type="password" value={geminiKey} onChange={e=>setGeminiKey(e.target.value)} className="w-full p-2 border rounded mt-1 dark:bg-slate-900 dark:text-white dark:border-slate-700"/></div>
                                            <div><label className="text-xs font-bold text-slate-500 dark:text-slate-400">模型</label><select value={geminiModel} onChange={e=>setGeminiModel(e.target.value)} className="w-full p-2 border rounded mt-1 dark:bg-slate-900 dark:text-white dark:border-slate-700">{GEMINI_MODELS.map(m=><option key={m.id} value={m.id}>{m.name}</option>)}</select></div>
                                            <div>
                                                <label className="text-xs font-bold text-slate-500 dark:text-slate-400">自訂規則 (System Instruction)</label>
                                                <textarea 
                                                    value={customInstruction} 
                                                    onChange={e=>setCustomInstruction(e.target.value)} 
                                                    className="w-full p-2 border rounded mt-1 dark:bg-slate-900 dark:text-white dark:border-slate-700 h-24 resize-none text-sm" 
                                                    placeholder="例如：請用有禮貌的口氣回應，並使用繁體中文。"
                                                />
                                            </div>
                                            <div><label className="text-xs font-bold text-slate-500 dark:text-slate-400">創意度: {aiTemperature}</label><input type="range" min="0" max="1" step="0.1" value={aiTemperature} onChange={e=>setAiTemperature(parseFloat(e.target.value))} className="w-full"/></div>
                                            <div><label className="text-xs font-bold text-slate-500 dark:text-slate-400">PDF 強制 AI 視覺讀取</label><input type="checkbox" checked={usePdfVision} onChange={e=>setUsePdfVision(e.target.checked)} className="ml-2"/></div>
                                        </div>
                                    )}
                                    {activeTab === 'voice' && (
                                         <div className="space-y-4">
                                            <div><label className="text-xs text-slate-500 dark:text-slate-400 mb-1 block font-bold">朗讀語音 (Voice)</label><select value={selectedVoiceURI} onChange={(e) => setSelectedVoiceURI(e.target.value)} className="w-full p-2.5 border border-slate-200 dark:border-slate-700 rounded-lg text-xs bg-white dark:bg-slate-950 outline-none dark:text-white"><option value="">預設 (Default)</option>{availableVoices.map(v => (<option key={v.voiceURI} value={v.voiceURI}>{v.name} ({v.lang})</option>))}</select></div>
                                            <div className="grid grid-cols-2 gap-4"><div><label className="text-xs text-slate-500 dark:text-slate-400 mb-1 block font-bold">語速: {voiceRate}x</label><input type="range" min="0.5" max="2" step="0.1" value={voiceRate} onChange={(e) => setVoiceRate(parseFloat(e.target.value))} className="w-full"/></div><div><label className="text-xs text-slate-500 dark:text-slate-400 mb-1 block font-bold">音調: {voicePitch}</label><input type="range" min="0.5" max="2" step="0.1" value={voicePitch} onChange={(e) => setVoicePitch(parseFloat(e.target.value))} className="w-full"/></div></div>
                                         </div>
                                    )}
                                    {activeTab === 'glossary' && (
                                        <div className="space-y-4">
                                            <div className="flex gap-2">
                                                <input value={newGlossaryTerm} onChange={e=>setNewGlossaryTerm(e.target.value)} placeholder="原文" className="flex-1 p-2 border rounded dark:bg-slate-900 dark:border-slate-700 dark:text-white text-sm"/>
                                                <input value={newGlossaryTrans} onChange={e=>setNewGlossaryTrans(e.target.value)} placeholder="譯文/定義" className="flex-1 p-2 border rounded dark:bg-slate-900 dark:border-slate-700 dark:text-white text-sm"/>
                                                <button onClick={addGlossaryTerm} className="p-2 bg-blue-600 text-white rounded"><Icons.MessageSquarePlus className="w-4 h-4"/></button>
                                            </div>
                                            <div className="max-h-40 overflow-y-auto space-y-2">
                                                {glossary.length===0 && <div className="text-center text-slate-400 text-xs">尚無術語</div>}
                                                {glossary.map((g,i)=>(
                                                    <div key={i} className="flex justify-between items-center bg-slate-50 dark:bg-slate-900 p-2 rounded text-sm border dark:border-slate-700">
                                                        <span className="dark:text-white"><span className="font-bold">{g.term}</span>: {g.trans}</span>
                                                        <button onClick={()=>removeGlossaryTerm(i)} className="text-red-400 hover:text-red-600"><Icons.X className="w-4 h-4"/></button>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                    {activeTab === 'data' && (
                                        <div className="space-y-4">
                                            <div className="grid grid-cols-2 gap-3"><button onClick={handleExportData} className="bg-slate-100 hover:bg-slate-200 dark:bg-slate-700 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-200 text-xs font-bold py-3 rounded-xl flex items-center justify-center gap-2 transition-colors"><Icons.FileDown className="w-4 h-4"/> 匯出備份</button><label className="bg-slate-100 hover:bg-slate-200 dark:bg-slate-700 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-200 text-xs font-bold py-3 rounded-xl flex items-center justify-center gap-2 cursor-pointer transition-colors"><Icons.FileUp className="w-4 h-4"/> 匯入還原<input type="file" accept=".json" onChange={handleImportData} className="hidden" /></label></div>
                                        </div>
                                    )}
                                </div>
                                <button onClick={()=>setShowSettings(false)} className="w-full py-2 mt-4 bg-slate-900 dark:bg-blue-600 text-white rounded-lg font-bold">完成設定</button>
                            </div>
                        </div>
                    )}
                    
                    {/* Crop Modal (Fixed: Re-added) */}
                    {showCropModal && (
                        <div className="fixed inset-0 z-[60] bg-black/90 flex flex-col p-4 crop-modal" onMouseUp={handleCropEnd} onTouchend={handleCropEnd}>
                            <div className="flex justify-between items-center text-white mb-4">
                                <button onClick={() => setShowCropModal(false)} className="text-slate-300 hover:text-white p-2 flex items-center gap-1"><Icons.X /> 取消</button>
                                <div className="flex gap-2">
                                    <button onClick={handleFullImageConfirm} className="bg-slate-700 hover:bg-slate-600 text-white px-3 py-1.5 rounded-lg text-sm">全圖使用</button>
                                    <button onClick={handleCropConfirm} className="bg-blue-600 hover:bg-blue-500 text-white px-3 py-1.5 rounded-lg text-sm flex items-center gap-1"><Icons.Scissors className="w-4 h-4"/> 裁切並辨識</button>
                                </div>
                            </div>
                            <div className="flex-1 relative flex items-center justify-center overflow-hidden touch-none select-none bg-black" onMouseMove={handleCropMove} onTouchMove={handleCropMove}>
                                {cropImageSrc && (
                                    <div className="relative inline-block">
                                        <img ref={imageRef} src={cropImageSrc} className="max-w-full max-h-[80vh] object-contain select-none pointer-events-auto" draggable={false} onMouseDown={handleCropStart} onTouchStart={handleCropStart} alt="Crop Target" />
                                        {cropSelection && cropSelection.w > 0 && (
                                            <div className="absolute border-2 border-blue-500 bg-blue-500/20 pointer-events-none dashed-border" style={{ left: cropSelection.x, top: cropSelection.y, width: cropSelection.w, height: cropSelection.h }}></div>
                                        )}
                                    </div>
                                )}
                            </div>
                            <div className="text-center text-slate-400 text-xs mt-2">拖曳選取範圍</div>
                        </div>
                    )}
                    
                    {/* Visual Mode (Fixed: Re-added) */}
                    {showVisualMode && (
                        <div className="fixed inset-0 z-[60] bg-black/90 flex flex-col p-4 crop-modal overflow-hidden">
                            <div className="flex justify-between items-center text-white mb-2 shrink-0">
                                <button onClick={() => setShowVisualMode(false)} className="text-slate-300 hover:text-white p-2"><Icons.X /></button>
                                <div className="flex gap-4 items-center">
                                    <button onClick={() => setVisualStyle(p => ({ ...p, color: p.color === 'white' ? 'black' : 'white' }))} className="p-2 bg-slate-700 rounded-full" title="切換文字顏色"><Icons.Palette /></button>
                                    <button onClick={handleSaveVisualImage} className="p-2 bg-blue-600 rounded-full" title="儲存圖片"><Icons.Download /></button>
                                </div>
                            </div>
                            <div ref={visualContainerRef} className="flex-1 relative flex items-center justify-center overflow-hidden bg-black select-none touch-none" onMouseMove={handleVisualMove} onTouchMove={handleVisualMove} onMouseUp={handleVisualEnd} onTouchend={handleVisualEnd}>
                                {displayImage && <img src={displayImage} className="max-w-full max-h-[85vh] object-contain pointer-events-none" alt="Visual Target" />}
                                {translatedText && (
                                    <div className="absolute p-4 rounded-xl cursor-move border-2 border-transparent hover:border-blue-400/50 transition-colors group flex flex-col justify-center visual-text-box" style={{ left: `${visualBox.x}%`, top: `${visualBox.y}%`, width: `${visualBox.w}px`, height: `${visualBox.h}px`, transform: 'translate(-50%, -50%)', backgroundColor: visualStyle.bg, color: visualStyle.color }} onMouseDown={handleVisualDragStart} onTouchStart={handleVisualDragStart}>
                                        <div className="overflow-y-auto w-full h-full text-center flex items-center justify-center hide-scrollbar" style={{ fontSize: `${visualFontSize}px`, lineHeight: 1.4 }}>{translatedText}</div>
                                        <div className="absolute bottom-1 right-1 p-2 cursor-se-resize opacity-0 group-hover:opacity-100 transition-opacity bg-blue-500 rounded-full w-6 h-6 flex items-center justify-center" onMouseDown={handleVisualResizeStart} onTouchStart={handleVisualResizeStart}><Icons.Scaling className="w-3 h-3 text-white" /></div>
                                    </div>
                                )}
                            </div>
                            <div className="text-center text-slate-400 text-xs mt-2">拖曳移動文字框 • 右下角調整大小</div>
                        </div>
                    )}

                    {showBigText && (
                        <div className="fixed inset-0 bg-white dark:bg-slate-900 z-[60] flex flex-col p-4 overflow-hidden">
                             <div className="flex justify-between items-center p-4 z-20 bg-white/80 dark:bg-slate-900/80 backdrop-blur-sm sticky top-0">
                                <div className="flex gap-4">
                                    <div className="hidden md:flex items-center gap-2 bg-slate-100 dark:bg-slate-800 rounded-lg p-1">
                                        <span className="text-xs text-slate-500 dark:text-slate-400 px-2">寬度</span>
                                        <input 
                                            type="range" min="400" max="1600" step="50" 
                                            value={fsWidth} 
                                            onChange={(e) => setFsWidth(parseInt(e.target.value))}
                                            className="w-24 h-1.5 bg-slate-200 dark:bg-slate-600 rounded-lg appearance-none cursor-pointer"
                                        />
                                    </div>
                                    <div className="flex items-center gap-2 bg-slate-100 dark:bg-slate-800 rounded-lg p-1">
                                        <span className="text-xs text-slate-500 dark:text-slate-400 px-2">字體</span>
                                        <input 
                                            type="range" min="8" max="48" step="1" 
                                            value={fsSize} 
                                            onChange={(e) => setFsSize(parseInt(e.target.value))}
                                            className="w-24 h-1.5 bg-slate-200 dark:bg-slate-600 rounded-lg appearance-none cursor-pointer"
                                        />
                                    </div>
                                </div>
                                <div className="flex gap-2">
                                    {bilingualMode && <button onClick={() => setBilingualMode(!bilingualMode)} className="p-2 bg-slate-100 dark:bg-slate-800 rounded-full" title="雙語切換"><Icons.Columns className="w-5 h-5 text-slate-600 dark:text-slate-300"/></button>}
                                    <button onClick={handleFullScreenDownload} className="p-2 bg-green-600 text-white rounded-full shadow-lg hover:bg-green-700" title="截圖"><Icons.Camera className="w-5 h-5"/></button>
                                    <button onClick={() => setShowBigText(false)} className="p-2 bg-slate-100 dark:bg-slate-800 rounded-full"><Icons.X className="w-8 h-8 text-slate-600 dark:text-slate-300"/></button>
                                </div>
                            </div>
                             <div ref={fsContentRef} className="flex-1 overflow-y-auto p-0 md:p-10 pb-24">
                                 {/* Fixed: Reduced padding on mobile (p-0) vs desktop (md:p-10) and ensured w-full for width expansion */}
                                 <div ref={fsInnerRef} className="w-full mx-auto min-h-full flex flex-col p-6 md:p-12 transition-all duration-300 bg-white dark:bg-slate-900 shadow-sm md:shadow-none" style={{ maxWidth: fsWidth + 'px' }}>
                                    {bilingualMode && sourceText ? (
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                                            <div className="prose prose-lg dark:prose-invert text-slate-500 dark:text-slate-400"><h3 className="text-sm font-bold uppercase tracking-wide mb-4 text-slate-400 dark:text-slate-500 border-b dark:border-slate-700 pb-2">原文</h3><p className="whitespace-pre-wrap text-base">{sourceText}</p></div>
                                            <div className="prose prose-xl dark:prose-invert text-slate-900 dark:text-slate-100"><h3 className="text-sm font-bold uppercase tracking-wide mb-4 text-indigo-500 border-b dark:border-slate-700 pb-2">譯文</h3>
                                                {currentTask === 'mindmap' ? (
                                                    <MermaidDiagram code={translatedText} darkMode={darkMode} />
                                                ) : isMarkdownMode ? (
                                                    <div className="leading-relaxed text-left" style={{ fontSize: `${fsSize}px` }} dangerouslySetInnerHTML={{ __html: marked.parse(translatedText || "尚無翻譯內容") }} />
                                                ) : (
                                                    <p className="leading-relaxed whitespace-pre-wrap font-['Zen_Maru_Gothic']" style={{ fontSize: `${fsSize}px` }}>{translatedText || "尚無翻譯內容"}</p>
                                                )}
                                            </div>
                                        </div>
                                    ) : (
                                        currentTask==='mindmap' ? <MermaidDiagram code={translatedText} darkMode={darkMode}/> : <div className="prose max-w-none dark:prose-invert dark:text-slate-200" style={{ fontSize: `${fsSize}px` }} dangerouslySetInnerHTML={{__html:marked.parse(translatedText)}}/>
                                    )}
                                 </div>
                             </div>
                             <div className="absolute bottom-0 left-0 right-0 p-2 bg-white/90 dark:bg-slate-900/90 border-t border-slate-200 dark:border-slate-800 grid grid-cols-5 gap-1 backdrop-blur-md z-30 safe-area-pb items-center justify-items-center">
                                 <button onClick={() => setBilingualMode(!bilingualMode)} className={`flex flex-col items-center justify-center p-2 rounded-lg ${bilingualMode ? 'text-blue-600 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/20' : 'text-slate-500 dark:text-slate-400'}`}>
                                     <Icons.Columns className="w-5 h-5"/>
                                     <span className="text-[10px] font-bold mt-1">雙語</span>
                                 </button>
                                 <button onClick={() => copy(translatedText)} className="flex flex-col items-center justify-center p-2 rounded-lg text-slate-500 dark:text-slate-400 active:bg-slate-100 dark:active:bg-slate-800">
                                     <Icons.Copy className="w-5 h-5"/>
                                     <span className="text-[10px] font-bold mt-1">複製</span>
                                 </button>
                                 <button onClick={handleDownload} className="flex flex-col items-center justify-center p-2 rounded-lg text-slate-500 dark:text-slate-400 active:bg-slate-100 dark:active:bg-slate-800">
                                     <Icons.FileDown className="w-5 h-5"/>
                                     <span className="text-[10px] font-bold mt-1">存文字</span>
                                 </button>
                                 <button onClick={handleFullScreenDownload} className="flex flex-col items-center justify-center p-2 rounded-lg text-slate-500 dark:text-slate-400 active:bg-slate-100 dark:active:bg-slate-800">
                                     <Icons.Camera className="w-5 h-5"/>
                                     <span className="text-[10px] font-bold mt-1">存圖片</span>
                                 </button>
                                 <button onClick={() => speak(translatedText, targetLang)} className="flex flex-col items-center justify-center p-2 rounded-lg text-slate-500 dark:text-slate-400 active:bg-slate-100 dark:active:bg-slate-800">
                                     <Icons.Volume2 className="w-5 h-5"/>
                                     <span className="text-[10px] font-bold mt-1">朗讀</span>
                                 </button>
                             </div>
                        </div>
                    )}

                    <div className="text-center text-xs text-slate-300 mt-8">Gemini AI Assistant • Pro Version</div>
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<App />);
    </script>
</body>
</html>
