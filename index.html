<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini ÁøªË≠Ø</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Zen Maru Gothic (ÂèØÊÑõÂúìÈ´î) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@500;700&display=swap" rel="stylesheet">
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <!-- Mammoth.js (Word) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>

    <!-- Tesseract.js (OCR) -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <style>
        body {
            font-family: 'Zen Maru Gothic', 'Microsoft JhengHei', system-ui, -apple-system, sans-serif;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior-y: none; 
            background-color: #fff5f7;
            background-image: radial-gradient(#ffcce0 15%, transparent 16%), radial-gradient(#ffcce0 15%, transparent 16%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }
        
        /* ÂèØÊÑõÊç≤Ëª∏ */
        textarea::-webkit-scrollbar { width: 8px; }
        textarea::-webkit-scrollbar-track { background: transparent; }
        textarea::-webkit-scrollbar-thumb { background-color: #ffb7c5; border-radius: 10px; border: 2px solid #fff; }
        
        /* Èö±ËóèÊç≤Ëª∏‰ΩÜÂèØÊç≤Âãï */
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-spin { animation: spin 2s linear infinite; }
        
        @keyframes bounce-slow {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        .animate-bounce-slow { animation: bounce-slow 2s infinite; }

        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .no-select { user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        
        /* Crop UI Styles */
        .crop-modal { touch-action: none; } 

        /* Âêâ‰ºäÂç°ÂìáÈ¢®Ê†ºÊåâÈàï (Bubble Button) */
        .btn-cute {
            transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0px 4px 0px 0px rgba(0,0,0,0.1);
            border-bottom-width: 4px;
            border-color: rgba(0,0,0,0.05);
        }
        .btn-cute:active:not(:disabled) {
            transform: translateY(4px);
            box-shadow: 0px 0px 0px 0px rgba(0,0,0,0.1);
            border-bottom-width: 0px;
            margin-top: 4px; /* Compensate for border removal */
        }
        .btn-cute:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Âç°ÁâáÊ®£Âºè */
        .card-cute {
            border: 3px solid #fff;
            box-shadow: 4px 4px 0px #ffdae6;
            border-radius: 24px;
        }
    </style>
</head>
<body class="text-slate-700 min-h-screen pb-10">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- Icons (Lucide) ---
        const Icon = ({ children, className = "w-6 h-6" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Icons = {
            Languages: () => <Icon><path d="m5 8 6 6"/><path d="m4 14 6-6 2-3"/><path d="M2 5h12"/><path d="M7 2h1"/><path d="m22 22-5-10-5 10"/><path d="M14 18h6"/></Icon>,
            FileText: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></Icon>,
            Type: () => <Icon><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></Icon>,
            UploadCloud: () => <Icon><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></Icon>,
            ArrowRightLeft: () => <Icon><path d="m16 3 4 4-4 4"/><path d="M20 7H4"/><path d="m8 21-4-4 4-4"/><path d="M4 17h16"/></Icon>,
            Copy: () => <Icon><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></Icon>,
            Check: () => <Icon className="w-5 h-5 text-green-500"><polyline points="20 6 9 17 4 12"/></Icon>,
            Volume2: () => <Icon><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></Icon>,
            X: () => <Icon><path d="M18 6 6 18"/><path d="m6 6 12 12"/></Icon>,
            RotateCw: () => <Icon className="w-5 h-5 animate-spin"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 12"/><path d="M21 3v9h-9"/></Icon>,
            Sparkles: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/></Icon>,
            AlertCircle: () => <Icon><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></Icon>,
            Mic: () => <Icon><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="22"/></Icon>,
            MicOff: () => <Icon><line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V5a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"/><line x1="12" y1="19" x2="12" y2="22"/></Icon>,
            FileType: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M9 13v-1h6v1"/><path d="M12 12v6"/><path d="M11 18h2"/></Icon>,
            Settings: () => <Icon><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Save: () => <Icon><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></Icon>,
            Server: () => <Icon><rect width="20" height="8" x="2" y="2" rx="2" ry="2"/><rect width="20" height="8" x="2" y="14" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></Icon>,
            Camera: () => <Icon><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></Icon>,
            Globe: () => <Icon><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></Icon>,
            Key: () => <Icon><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></Icon>,
            Magic: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H1"/><path d="M19 18v4"/><path d="M21 20h-4"/></Icon>,
            Edit3: () => <Icon><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></Icon>,
            List: () => <Icon><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></Icon>,
            Search: () => <Icon><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></Icon>,
            Eye: () => <Icon><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Clock: () => <Icon><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></Icon>,
            Trash: () => <Icon><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></Icon>,
            Zap: () => <Icon><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></Icon>,
            Scissors: () => <Icon><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></Icon>,
            MessageSquare: () => <Icon><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></Icon>,
            Maximize: () => <Icon><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></Icon>,
            CPU: () => <Icon><rect width="16" height="16" x="4" y="4" rx="2"/><rect width="6" height="6" x="9" y="9"/><path d="M9 1v3"/><path d="M15 1v3"/><path d="M9 20v3"/><path d="M15 20v3"/><path d="M20 9h3"/><path d="M20 14h3"/><path d="M1 9h3"/><path d="M1 14h3"/></Icon>,
            Crop: () => <Icon><path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"/><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"/></Icon>,
            Volume3: () => <Icon><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></Icon>
        };

        const DEFAULT_OLLAMA_URL = "http://localhost:11434/api/generate";
        const DEFAULT_OLLAMA_MODEL = "gemma:2b";

        const GEMINI_MODELS = [
            { id: 'gemini-2.5-flash-preview-09-2025', name: 'Flash 2.5 (È†êË¶Ω)', desc: 'È†êË®≠' },
            { id: 'gemini-1.5-flash-001', name: 'Flash 1.5 (Á©©ÂÆö)', desc: 'Âø´ÈÄü' },
            { id: 'gemini-1.5-pro-001', name: 'Pro 1.5 (ËÅ∞Êòé)', desc: 'È´òÂìÅË≥™' },
            { id: 'custom', name: 'Ëá™Ë®ÇÊ®°Âûã', desc: 'ÊâãÂãï' }
        ];

        const LANGUAGES = [
            { code: 'auto', name: 'Ëá™ÂãïËæ®Ë≠ò' },
            { code: 'zh-TW', name: 'ÁπÅÈ´î‰∏≠Êñá' },
            { code: 'en', name: 'English' },
            { code: 'ja', name: 'Êó•Êú¨Ë™û' },
            { code: 'ko', name: 'ÌïúÍµ≠Ïñ¥' },
            { code: 'es', name: 'Espa√±ol' },
            { code: 'fr', name: 'Fran√ßais' },
            { code: 'de', name: 'Deutsch' },
            { code: 'vi', name: 'Ti·∫øng Vi·ªát' },
            { code: 'th', name: '‡πÑ‡∏ó‡∏¢' },
        ];

        const TONES = [
            { id: 'standard', name: 'Ê®ôÊ∫ñ', icon: '‚ú®' },
            { id: 'formal', name: 'Á¶ÆË≤å', icon: 'üëî' },
            { id: 'casual', name: 'ËºïÈ¨Ü', icon: 'üòé' },
            { id: 'academic', name: 'Â∞àÊ•≠', icon: 'üéì' },
            { id: 'creative', name: 'ÂÑ™Áæé', icon: 'üé®' },
        ];

        const fetchWithRetry = async (url, options, retries = 3, delay = 1000) => {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({}));
                    const errorMessage = errorBody.error?.message || `HTTP error! status: ${response.status}`;
                    if (response.status >= 400 && response.status < 500) {
                        throw new Error(`Ë´ãÊ±ÇÂ§±Êïó (${response.status}): ${errorMessage} - Ë´ãÊ™¢Êü•Ê®°ÂûãÊàñ Key`); 
                    }
                    throw new Error(errorMessage);
                }
                return await response.json();
            } catch (error) {
                if (retries > 0 && !error.message.includes("400") && !error.message.includes("404")) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithRetry(url, options, retries - 1, delay * 2);
                } else {
                    throw error;
                }
            }
        };

        const compressImage = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;
                        const MAX_WIDTH = 1500; 
                        const MAX_HEIGHT = 1500;
                        if (width > height) {
                            if (width > MAX_WIDTH) {
                                height *= MAX_WIDTH / width;
                                width = MAX_WIDTH;
                            }
                        } else {
                            if (height > MAX_HEIGHT) {
                                width *= MAX_HEIGHT / height;
                                height = MAX_HEIGHT;
                            }
                        }
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        const base64Data = canvas.toDataURL('image/jpeg', 0.8);
                        resolve(base64Data.split(',')[1]);
                    };
                    img.onerror = (err) => reject(err);
                };
                reader.onerror = (err) => reject(err);
            });
        };

        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = error => reject(error);
            });
        };

        function App() {
            const [mode, setMode] = useState('text'); 
            const [sourceText, setSourceText] = useState('');
            const [translatedText, setTranslatedText] = useState('');
            const [sourceLang, setSourceLang] = useState('auto');
            const [targetLang, setTargetLang] = useState('zh-TW');
            const [selectedTone, setSelectedTone] = useState('standard');
            const [isLoading, setIsLoading] = useState(false);
            const [loadingStatus, setLoadingStatus] = useState('');
            const [errorMsg, setErrorMsg] = useState('');
            const [fileName, setFileName] = useState(null);
            const [isDragOver, setIsDragOver] = useState(false);
            const [showSettings, setShowSettings] = useState(false);
            const [showHistory, setShowHistory] = useState(false);
            const [showBigText, setShowBigText] = useState(false);
            const [isRealTime, setIsRealTime] = useState(false);
            
            // Voice Settings
            const [voiceRate, setVoiceRate] = useState(1);
            const [voicePitch, setVoicePitch] = useState(1);
            const [availableVoices, setAvailableVoices] = useState([]);
            const [selectedVoiceURI, setSelectedVoiceURI] = useState('');
            
            // Crop State
            const [showCropModal, setShowCropModal] = useState(false);
            const [cropImageSrc, setCropImageSrc] = useState(null);
            const [cropSelection, setCropSelection] = useState(null); 
            const [isCropping, setIsCropping] = useState(false);
            
            const dragStartRef = useRef(null);
            const isDraggingRef = useRef(false);
            const imageRef = useRef(null);
            const cropContainerRef = useRef(null);

            const [apiProvider, setApiProvider] = useState('gemini'); 
            const [geminiKey, setGeminiKey] = useState(localStorage.getItem('gemini_api_key') || '');
            const [geminiModel, setGeminiModel] = useState(localStorage.getItem('gemini_model') || 'gemini-2.5-flash-preview-09-2025');
            const [ollamaUrl, setOllamaUrl] = useState(DEFAULT_OLLAMA_URL);
            const [ollamaModel, setOllamaModel] = useState(DEFAULT_OLLAMA_MODEL);
            const [isListening, setIsListening] = useState(false);
            const [copiedSource, setCopiedSource] = useState(false);
            const [copiedTarget, setCopiedTarget] = useState(false);
            const [history, setHistory] = useState(JSON.parse(localStorage.getItem('translate_history') || '[]'));

            const recognitionRef = useRef(null);
            const fileInputRef = useRef(null);
            const cameraInputRef = useRef(null);
            const requestCounter = useRef(0);
            
            useEffect(() => { localStorage.setItem('gemini_api_key', geminiKey); }, [geminiKey]);
            useEffect(() => { localStorage.setItem('gemini_model', geminiModel); }, [geminiModel]);
            useEffect(() => { localStorage.setItem('translate_history', JSON.stringify(history)); }, [history]);
            
            useEffect(() => {
                const loadVoices = () => {
                    const voices = window.speechSynthesis.getVoices();
                    setAvailableVoices(voices);
                };
                loadVoices();
                window.speechSynthesis.onvoiceschanged = loadVoices;
            }, []);

            useEffect(() => {
                if (mode !== 'text' && mode !== 'file') return;
                const handlePaste = (e) => {
                    const items = e.clipboardData?.items;
                    if (!items) return;
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].type.indexOf('image') !== -1) {
                            e.preventDefault();
                            const file = items[i].getAsFile();
                            processFile(file);
                            break;
                        }
                    }
                };
                window.addEventListener('paste', handlePaste);
                return () => window.removeEventListener('paste', handlePaste);
            }, [apiProvider, geminiKey, sourceLang, mode]); 

            useEffect(() => {
                if (!isRealTime || !sourceText.trim() || mode !== 'text') return;
                const timer = setTimeout(() => { if (sourceText.length > 1) callAI('translate'); }, 1200);
                return () => clearTimeout(timer);
            }, [sourceText, isRealTime, sourceLang, targetLang, apiProvider, selectedTone, mode]);

            const addToHistory = (src, res, sLang, tLang) => {
                if (!src || !res) return;
                const newItem = { id: Date.now(), src, res, sLang, tLang, timestamp: new Date().toLocaleString() };
                setHistory(prev => [newItem, ...prev].slice(0, 50));
            };

            const clearHistory = () => { if(confirm("Á¢∫ÂÆöË¶ÅÂà™Èô§ÂóéÔºü")) setHistory([]); };

            const handleScreenCapture = async () => {
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "never" }, audio: false });
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    await video.play();
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);
                    stream.getTracks().forEach(track => track.stop());
                    canvas.toBlob(blob => {
                        const file = new File([blob], "screenshot.png", { type: 'image/png' });
                        processFile(file);
                    });
                } catch (e) { 
                    console.log("Screen capture cancelled", e); 
                    alert("Êà™ÂúñÂ§±ÊïóÔºåË´ãÊ™¢Êü•Ê¨äÈôê„ÄÇ");
                }
            };

            const getClientCoordinates = (e) => {
                const imgRect = imageRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                let x = clientX - imgRect.left;
                let y = clientY - imgRect.top;
                x = Math.max(0, Math.min(x, imgRect.width));
                y = Math.max(0, Math.min(y, imgRect.height));
                return { x, y };
            };

            const handleCropStart = (e) => {
                if(e.type === 'mousedown') e.preventDefault(); 
                if(!cropImageSrc) return;
                const coords = getClientCoordinates(e);
                dragStartRef.current = coords;
                isDraggingRef.current = true;
                setCropSelection({ x: coords.x, y: coords.y, w: 0, h: 0 });
            };

            const handleCropMove = (e) => {
                if (e.cancelable && e.type.startsWith('touch')) e.preventDefault();
                if (!isDraggingRef.current || !dragStartRef.current) return;
                const coords = getClientCoordinates(e);
                const start = dragStartRef.current;
                const currentX = coords.x;
                const currentY = coords.y;
                const x = Math.min(start.x, currentX);
                const y = Math.min(start.y, currentY);
                const w = Math.abs(currentX - start.x);
                const h = Math.abs(currentY - start.y);
                setCropSelection({ x, y, w, h });
            };

            const handleCropEnd = () => {
                isDraggingRef.current = false;
                dragStartRef.current = null;
            };

            const handleCropConfirm = async () => {
                // ÂæÆË∑ùÈÅ∏ÂèñËß£Èéñ: ÁßªÈô§ÊúÄÂ∞èÂ∞∫ÂØ∏ÈôêÂà∂
                if (!cropSelection) {
                    alert("Ë´ãÂÖàÂú®ÂúñÁâá‰∏äÊªëÂãïÊâãÊåáÈÅ∏ÂèñÁØÑÂúç");
                    return;
                }
                const img = imageRef.current;
                const canvas = document.createElement('canvas');
                const scaleX = img.naturalWidth / img.clientWidth;
                const scaleY = img.naturalHeight / img.clientHeight;
                canvas.width = Math.max(1, cropSelection.w * scaleX);
                canvas.height = Math.max(1, cropSelection.h * scaleY);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, cropSelection.x * scaleX, cropSelection.y * scaleY, cropSelection.w * scaleX, cropSelection.h * scaleY, 0, 0, canvas.width, canvas.height);
                canvas.toBlob(blob => {
                    const file = new File([blob], "cropped_selection.jpg", { type: 'image/jpeg' });
                    setShowCropModal(false);
                    setMode('text');
                    runOCR(file);
                }, 'image/jpeg', 0.9);
            };

            const handleFullImageConfirm = async () => {
                const res = await fetch(cropImageSrc);
                const blob = await res.blob();
                const file = new File([blob], "full_image.jpg", { type: 'image/jpeg' });
                setShowCropModal(false);
                setMode('text');
                runOCR(file);
            };

            const runOCR = async (file) => {
                setErrorMsg('');
                setSourceText('');
                setIsLoading(true);
                setLoadingStatus('Ê≠£Âú®ËÆÄÂèñÂúñÁâá...');
                try {
                    let text = "";
                    if (apiProvider === 'gemini') text = await performGeminiOCR(file);
                    else text = await performLegacyOCR(file);
                    
                    if (!text || !text.trim()) throw new Error("ÁÑ°Ê≥ïËæ®Ë≠òÂúñÁâá‰∏≠ÁöÑÊñáÂ≠ó");
                    setSourceText(text);
                    callAI('translate', text); 
                } catch (err) {
                    console.error(err);
                    setErrorMsg(err.message || "ËÆÄÂèñÂ§±Êïó");
                    setIsLoading(false);
                }
            };

            const performGeminiOCR = async (file) => {
                const trimmedKey = geminiKey.trim();
                if (!trimmedKey) {
                    setShowSettings(true);
                    throw new Error("Ë´ãËº∏ÂÖ• Gemini API Key");
                }
                setLoadingStatus('AI Ê≠£Âú®Â£ìÁ∏Æ‰∏¶ËÆÄÂèñÂúñÁâá...');
                const base64Image = await compressImage(file);
                const mimeType = 'image/jpeg';
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${trimmedKey}`;
                const payload = {
                    contents: [{
                        parts: [
                            { text: "Please convert the text in this image to plain text. Output ONLY the text found in the image." },
                            { inline_data: { mime_type: mimeType, data: base64Image } }
                        ]
                    }]
                };
                const data = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error("AI ÁÑ°Ê≥ïËæ®Ë≠òÂúñÁâá‰∏≠ÁöÑÊñáÂ≠ó");
                return text.trim();
            };

            const performLegacyOCR = async (file) => {
                if (!window.Tesseract) throw new Error("OCR ÂÖÉ‰ª∂ËºâÂÖ•‰∏≠...");
                let tessLang = 'eng'; 
                if (sourceLang === 'auto') tessLang = 'chi_tra+eng'; 
                else if (sourceLang.includes('zh')) tessLang = 'chi_tra+eng';
                else if (sourceLang.includes('ja')) tessLang = 'jpn+eng';
                else if (sourceLang.includes('ko')) tessLang = 'kor+eng';
                setLoadingStatus(`‰∏ãËºâËæ®Ë≠òÊ®°Âûã‰∏≠...`);
                const { data: { text } } = await Tesseract.recognize(file, tessLang, {
                    logger: m => { if (m.status === 'recognizing text') setLoadingStatus(`Ëæ®Ë≠òÊñáÂ≠ó‰∏≠... ${Math.round(m.progress * 100)}%`); }
                });
                return text;
            };

            const processFile = async (file) => {
                if (!file) return;
                setFileName(file.name || "File");
                const lowerName = file.name ? file.name.toLowerCase() : 'image.jpg';
                const fileType = file.type || '';

                if (fileType.startsWith('image/') || lowerName.match(/\.(jpg|jpeg|png|bmp|webp)$/)) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setCropImageSrc(e.target.result);
                        setCropSelection(null);
                        setShowCropModal(true);
                    };
                    reader.readAsDataURL(file);
                    return;
                }

                setMode('text');
                setSourceText('');
                setIsLoading(true);
                setLoadingStatus('Ê≠£Âú®ËôïÁêÜÊñá‰ª∂...');

                try {
                    let text = "";
                    if (lowerName.endsWith('.pdf')) {
                        if (!window.pdfjsLib) throw new Error("PDF ÂÖÉ‰ª∂ËºâÂÖ•‰∏≠...");
                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        const maxPages = Math.min(pdf.numPages, 30);
                        for (let i = 1; i <= maxPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            text += textContent.items.map(item => item.str).join(' ') + '\n\n';
                        }
                    } else if (lowerName.endsWith('.docx')) {
                        if (!window.mammoth) throw new Error("Word ÂÖÉ‰ª∂ËºâÂÖ•‰∏≠...");
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await window.mammoth.extractRawText({ arrayBuffer });
                        text = result.value;
                    } else {
                        text = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = e => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(file);
                        });
                    }
                    
                    if (!text || !text.trim()) throw new Error("ÁÑ°Ê≥ïËÆÄÂèñÊñáÂ≠ó");
                    setSourceText(text);
                    callAI('translate', text); 
                } catch (err) {
                    console.error(err);
                    setErrorMsg(err.message || "ËÆÄÂèñÂ§±Êïó");
                    setIsLoading(false);
                } 
            };

            const handleFileChange = (e) => processFile(e.target.files[0]);
            
            const toggleListening = () => {
                if (isListening) { recognitionRef.current?.stop(); setIsListening(false); return; }
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) { setErrorMsg("ÁÄèË¶ΩÂô®‰∏çÊîØÊè¥Ë™ûÈü≥Ëº∏ÂÖ•"); return; }
                const recognition = new SpeechRecognition();
                if (sourceLang !== 'auto') recognition.lang = sourceLang;
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.onstart = () => { setIsListening(true); setErrorMsg(''); };
                recognition.onend = () => setIsListening(false);
                recognition.onresult = (event) => {
                    let final = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) final += event.results[i][0].transcript;
                    }
                    if (final) setSourceText(prev => prev + (prev ? ' ' : '') + final);
                };
                recognitionRef.current = recognition;
                recognition.start();
            };

            const performTranslation = async (text, sLangCode, tLangCode) => {
                const sName = LANGUAGES.find(l => l.code === sLangCode)?.name || sLangCode;
                const tName = LANGUAGES.find(l => l.code === tLangCode)?.name || tLangCode;
                let systemInstruction = `Translate the following text from ${sName} to ${tName}. Output ONLY the translated text.`;
                
                if (apiProvider === 'gemini') {
                    const trimmedKey = geminiKey.trim();
                    if (!trimmedKey) throw new Error("Key missing");
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${trimmedKey}`;
                    const payload = { contents: [{ parts: [{ text: text }] }], systemInstruction: { parts: [{ text: systemInstruction }] } };
                    const data = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
                } else if (apiProvider === 'mymemory') {
                    const pair = `${sLangCode}|${tLangCode}`;
                    const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${pair}`;
                    const res = await fetch(url);
                    const data = await res.json();
                    return data.responseData.translatedText;
                } else { return `[${tName}] ${text}`; }
            };

            const callAI = async (promptType, textOverride = null) => {
                const textToUse = textOverride !== null ? textOverride : sourceText;
                if (!textToUse.trim()) return;
                if (apiProvider === 'mymemory' && promptType !== 'translate') { setErrorMsg("MyMemory ÂÉÖÊîØÊè¥Âü∫Á§éÁøªË≠Ø"); return; }

                const currentRequestId = ++requestCounter.current;
                setIsLoading(true);
                setErrorMsg('');
                if (!isRealTime && textOverride === null) setTranslatedText(''); 

                const tName = LANGUAGES.find(l => l.code === targetLang)?.name || targetLang;
                const sName = sourceLang === 'auto' ? 'Auto Detect' : LANGUAGES.find(l => l.code === sourceLang)?.name;
                const toneInfo = TONES.find(t => t.id === selectedTone)?.name || 'Standard';

                let systemInstruction = "";
                if (promptType === 'translate') systemInstruction = `Translate input to ${tName}. Source: ${sName}. Tone: ${toneInfo}. Rules: Output ONLY translated text.`;
                else if (promptType === 'polish') systemInstruction = `Rewrite text into ${tName} to be professional/fluent. Tone: ${toneInfo}. Output ONLY rewritten text.`;
                else if (promptType === 'summarize') systemInstruction = `Summarize text into ${tName}. Use bullet points. Concise.`;
                else if (promptType === 'grammar') systemInstruction = `Analyze text. 1. ID Source Lang. 2. Grammar errors. 3. Key vocab. 4. Corrected version. Output in ${tName}.`;

                if(!textOverride) setLoadingStatus("AI ÊÄùËÄÉ‰∏≠ (ÔΩ•œâÔΩ•)b...");

                try {
                    let resultText = "";
                    if (apiProvider === 'gemini') {
                        const trimmedKey = geminiKey.trim();
                        if (!trimmedKey) { setShowSettings(true); throw new Error("Ë´ãËº∏ÂÖ• Key"); }
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${trimmedKey}`;
                        const payload = { contents: [{ parts: [{ text: textToUse }] }], systemInstruction: { parts: [{ text: systemInstruction }] } };
                        const data = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        resultText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
                    } else if (apiProvider === 'mymemory' && promptType === 'translate') {
                        resultText = await performTranslation(textToUse, sourceLang === 'auto' ? 'Autodetect' : sourceLang, targetLang);
                    } else {
                        resultText = "Ê≠§Ê®°Âºè‰∏çÊîØÊè¥";
                    }

                    if (currentRequestId === requestCounter.current) {
                        setTranslatedText(resultText);
                        if (resultText && !resultText.startsWith("Error") && !resultText.startsWith("Ê≠§Ê®°Âºè")) {
                            addToHistory(textToUse, resultText, sourceLang, targetLang);
                        }
                    }
                } catch (error) { if (currentRequestId === requestCounter.current) setErrorMsg(error.message); } 
                finally { if (currentRequestId === requestCounter.current) { setIsLoading(false); setLoadingStatus(''); } }
            };

            const copy = (t, isS) => { if(!t)return; navigator.clipboard.writeText(t); if(isS){setCopiedSource(true);setTimeout(()=>setCopiedSource(false),2000)}else{setCopiedTarget(true);setTimeout(()=>setCopiedTarget(false),2000)} };
            const speak = (t, l) => { 
                if(!t)return; 
                window.speechSynthesis.cancel(); 
                const u = new SpeechSynthesisUtterance(t); 
                u.lang = l; 
                u.rate = voiceRate;
                u.pitch = voicePitch;
                if (selectedVoiceURI) {
                    u.voice = availableVoices.find(v => v.voiceURI === selectedVoiceURI);
                }
                window.speechSynthesis.speak(u); 
            };
            const clearAll = () => { setSourceText(''); setTranslatedText(''); setFileName(null); setErrorMsg(''); if(fileInputRef.current) fileInputRef.current.value = ''; };

            return (
                <div className="pb-12">
                    {/* Crop Modal */}
                    {showCropModal && (
                        <div className="fixed inset-0 bg-black/90 z-[70] flex flex-col animate-in fade-in duration-200 crop-modal"
                             onMouseMove={handleCropMove}
                             onTouchMove={handleCropMove}
                             onMouseUp={handleCropEnd}
                             onTouchEnd={handleCropEnd}
                        >
                            <div className="flex justify-between items-center p-4 bg-[#ffdbed] text-[#d45d79] z-10 border-b-4 border-[#fff]">
                                <h3 className="font-bold text-lg flex items-center gap-2">‚úÇÔ∏è Ë£ÅÂàáÈÅ∏ÂèñÂçÄÂüü</h3>
                                <button onClick={() => { setShowCropModal(false); setCropImageSrc(null); }} className="p-2 bg-white rounded-full shadow-sm active:scale-95 transition-transform"><Icons.X className="w-6 h-6"/></button>
                            </div>
                            <div className="flex-1 relative flex items-center justify-center overflow-hidden bg-[#fff0f5]">
                                <div className="relative shadow-2xl rounded-lg overflow-hidden border-4 border-white">
                                    <img 
                                        ref={imageRef} 
                                        src={cropImageSrc} 
                                        className="max-w-full max-h-[80vh] object-contain no-select block" 
                                        draggable="false"
                                        alt="Crop Preview"
                                        onMouseDown={handleCropStart}
                                        onTouchStart={handleCropStart}
                                    />
                                    {cropSelection && (
                                        <div 
                                            className="absolute border-4 border-[#ffb7c5] bg-[#ffb7c5]/20 pointer-events-none shadow-[0_0_0_9999px_rgba(255,255,255,0.7)] rounded-lg"
                                            style={{
                                                left: cropSelection.x,
                                                top: cropSelection.y,
                                                width: cropSelection.w,
                                                height: cropSelection.h
                                            }}
                                        />
                                    )}
                                </div>
                            </div>
                            <div className="p-4 bg-white border-t-4 border-[#ffdae6] grid grid-cols-2 gap-4 z-10">
                                <button onClick={handleFullImageConfirm} className="btn-cute bg-[#e0f7fa] text-[#0277bd] py-3.5 rounded-2xl font-bold text-sm flex items-center justify-center gap-2">
                                    <Icons.FileText className="w-5 h-5"/> ÁøªË≠ØÊï¥Âºµ
                                </button>
                                <button onClick={handleCropConfirm} className={`btn-cute py-3.5 rounded-2xl font-bold text-sm flex items-center justify-center gap-2 ${!cropSelection ? 'bg-gray-100 text-gray-400' : 'bg-[#ffdbed] text-[#d45d79]'}`}>
                                    <Icons.Crop className="w-5 h-5"/> ÁøªË≠ØÈÅ∏Âèñ
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Full Screen Text Modal */}
                    {showBigText && (
                        <div className="fixed inset-0 bg-[#fff0f5] z-[60] flex flex-col animate-in fade-in duration-200">
                            <div className="flex justify-end p-4">
                                <button onClick={() => setShowBigText(false)} className="p-3 bg-white border-2 border-[#ffb7c5] rounded-full text-[#d45d79] shadow-lg active:scale-90 transition-transform"><Icons.X className="w-8 h-8"/></button>
                            </div>
                            <div className="flex-1 flex items-center justify-center p-8 overflow-y-auto">
                                <p className="text-4xl md:text-6xl font-bold text-slate-700 leading-tight text-center whitespace-pre-wrap font-[Zen_Maru_Gothic]">
                                    {translatedText || "Â∞öÁÑ°ÁøªË≠ØÂÖßÂÆπ"}
                                </p>
                            </div>
                            <div className="p-8 flex justify-center gap-4">
                                <button onClick={() => speak(translatedText, targetLang)} className="p-6 bg-[#ffdbed] border-4 border-white rounded-full text-[#d45d79] shadow-[4px_4px_0px_#ffb7c5] active:translate-y-1 active:shadow-none transition-all"><Icons.Volume2 className="w-10 h-10"/></button>
                            </div>
                        </div>
                    )}

                    {/* History Modal */}
                    {showHistory && (
                        <div className="fixed inset-0 bg-black/30 backdrop-blur-sm z-50 flex justify-end" onClick={() => setShowHistory(false)}>
                            <div className="bg-[#fff0f5] w-full max-w-md h-full shadow-2xl flex flex-col border-l-4 border-[#ffdae6]" onClick={e => e.stopPropagation()}>
                                <div className="px-6 py-5 border-b-2 border-[#ffdae6] flex justify-between items-center bg-white">
                                    <h3 className="font-bold text-slate-700 flex items-center gap-2 text-lg"><Icons.Clock /> Ê≠∑Âè≤Á¥ÄÈåÑ</h3>
                                    <button onClick={clearHistory} className="text-red-400 hover:text-red-600 bg-red-50 p-2 rounded-xl"><Icons.Trash /></button>
                                </div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-3">
                                    {history.map(item => (
                                        <div key={item.id} className="bg-white p-4 rounded-2xl border-2 border-[#ffdae6] shadow-sm active:scale-95 transition-transform cursor-pointer" onClick={() => { setSourceText(item.src); setTranslatedText(item.res); setShowHistory(false); }}>
                                            <div className="flex justify-between text-xs text-slate-400 mb-2 font-bold">
                                                <span>{item.timestamp}</span>
                                                <span className="bg-[#e0f7fa] text-[#0277bd] px-2 py-0.5 rounded-full">{item.sLang} ‚Üí {item.tLang}</span>
                                            </div>
                                            <div className="font-bold mb-1 line-clamp-2 text-slate-700">{item.src}</div>
                                            <div className="text-[#d45d79] line-clamp-2">{item.res}</div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* Settings Modal */}
                    {showSettings && (
                        <div className="fixed inset-0 bg-black/30 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                            <div className="bg-[#fff0f5] rounded-3xl w-full max-w-md p-6 space-y-5 max-h-[90vh] overflow-y-auto border-4 border-white shadow-[8px_8px_0px_#ffdae6]">
                                <div className="flex justify-between items-center border-b-2 border-[#ffdae6] pb-3">
                                    <h3 className="font-bold text-xl flex items-center gap-2 text-slate-700"><Icons.Settings /> Ë®≠ÂÆö</h3>
                                    <button onClick={() => setShowSettings(false)} className="bg-white p-2 rounded-full text-slate-400"><Icons.X/></button>
                                </div>
                                
                                {/* Voice Settings */}
                                <div className="space-y-3 bg-white p-4 rounded-2xl border-2 border-[#ffdae6]">
                                    <h4 className="text-sm font-bold text-slate-600 flex items-center gap-2"><Icons.Volume3 className="w-4 h-4"/> Ë™ûÈü≥Ë®≠ÂÆö</h4>
                                    <select value={selectedVoiceURI} onChange={(e) => setSelectedVoiceURI(e.target.value)} className="w-full p-2 border-2 border-slate-100 rounded-xl text-sm bg-[#f9fafb] outline-none focus:border-[#ffb7c5]">
                                        <option value="">È†êË®≠Ë™ûÈü≥</option>
                                        {availableVoices.map(v => <option key={v.voiceURI} value={v.voiceURI}>{v.name} ({v.lang})</option>)}
                                    </select>
                                    <div className="grid grid-cols-2 gap-4">
                                        <div><label className="text-xs text-slate-500 block mb-1">Ë™ûÈÄü: {voiceRate}x</label><input type="range" min="0.5" max="2" step="0.1" value={voiceRate} onChange={(e) => setVoiceRate(parseFloat(e.target.value))} className="w-full accent-[#ffb7c5]"/></div>
                                        <div><label className="text-xs text-slate-500 block mb-1">Èü≥Ë™ø: {voicePitch}</label><input type="range" min="0.5" max="2" step="0.1" value={voicePitch} onChange={(e) => setVoicePitch(parseFloat(e.target.value))} className="w-full accent-[#ffb7c5]"/></div>
                                    </div>
                                </div>

                                <div className="space-y-2">
                                    <label className="text-sm font-bold text-slate-600 ml-1">ÁøªË≠ØÂºïÊìé</label>
                                    <div className="grid grid-cols-3 gap-2">
                                        <button onClick={() => setApiProvider('gemini')} className={`p-2 border-2 rounded-xl text-sm font-bold transition-all ${apiProvider==='gemini'?'bg-[#ffdbed] border-[#ffb7c5] text-[#d45d79]':'bg-white border-slate-100 text-slate-400'}`}>Gemini</button>
                                        <button onClick={() => setApiProvider('mymemory')} className={`p-2 border-2 rounded-xl text-sm font-bold transition-all ${apiProvider==='mymemory'?'bg-[#e0f7fa] border-[#81d4fa] text-[#0277bd]':'bg-white border-slate-100 text-slate-400'}`}>ÂÖçË≤ªAPI</button>
                                        <button onClick={() => setApiProvider('ollama')} className={`p-2 border-2 rounded-xl text-sm font-bold transition-all ${apiProvider==='ollama'?'bg-[#fff9c4] border-[#fff176] text-[#fbc02d]':'bg-white border-slate-100 text-slate-400'}`}>Êú¨Âú∞</button>
                                    </div>
                                </div>
                                
                                {apiProvider === 'gemini' && (
                                    <div className="space-y-3 animate-in fade-in bg-white p-4 rounded-2xl border-2 border-[#ffdae6]">
                                        <div>
                                            <label className="text-xs font-bold text-[#d45d79] flex items-center gap-1 mb-1"><Icons.Key className="w-3 h-3"/> API Key</label>
                                            <input type="password" value={geminiKey} onChange={e=>setGeminiKey(e.target.value)} className="w-full p-3 border-2 border-slate-100 rounded-xl font-mono text-sm outline-none focus:border-[#ffb7c5]" placeholder="Ë≤º‰∏ä Key" />
                                            <a href="https://aistudio.google.com/app/apikey" target="_blank" className="text-[10px] text-slate-400 mt-1 block underline hover:text-[#d45d79] text-right">üëâ ÂèñÂæóÂÖçË≤ª Key</a>
                                        </div>
                                        <div>
                                            <label className="text-xs font-bold text-slate-500 flex items-center gap-1 mb-1"><Icons.CPU className="w-3 h-3"/> Ê®°Âûã (Model)</label>
                                            <select value={GEMINI_MODELS.some(m => m.id === geminiModel) ? geminiModel : 'custom'} onChange={(e) => { if (e.target.value === 'custom') setGeminiModel(''); else setGeminiModel(e.target.value); }} className="w-full p-2 border-2 border-slate-100 rounded-xl text-sm bg-[#f9fafb] outline-none focus:border-[#ffb7c5]">
                                                {GEMINI_MODELS.map(m => <option key={m.id} value={m.id}>{m.name}</option>)}
                                            </select>
                                            {(GEMINI_MODELS.every(m => m.id !== geminiModel) || geminiModel === '') && <input type="text" value={geminiModel} onChange={(e) => setGeminiModel(e.target.value)} placeholder="Ëº∏ÂÖ•Ê®°Âûã ID" className="mt-2 w-full p-2 border-2 border-slate-100 rounded-xl text-sm font-mono bg-[#f9fafb]" />}
                                        </div>
                                    </div>
                                )}
                                <button onClick={() => setShowSettings(false)} className="w-full bg-[#d45d79] text-white py-3 rounded-2xl font-bold shadow-lg active:scale-95 transition-transform">OK! (ÂÑ≤Â≠ò)</button>
                            </div>
                        </div>
                    )}

                    {/* Header */}
                    <header className="bg-white/80 backdrop-blur-md shadow-[0_2px_10px_rgba(255,183,197,0.2)] sticky top-0 z-20 h-16 flex items-center justify-between px-4">
                        <div className="flex items-center gap-2 text-[#d45d79]">
                            <div className="bg-[#ffdbed] text-[#d45d79] p-2 rounded-xl shadow-sm"><Icons.Languages className="w-6 h-6" /></div>
                            <h1 className="font-bold text-lg tracking-tight">Âêâ‰ºäÁøªË≠Ø <span className="text-xs font-normal text-slate-400">x Gemini</span></h1>
                        </div>
                        <div className="flex items-center gap-2">
                            <button onClick={() => setShowHistory(true)} className="p-2 rounded-full text-slate-400 hover:bg-[#fff0f5] hover:text-[#d45d79] transition-colors"><Icons.Clock className="w-6 h-6" /></button>
                            <button onClick={() => setShowSettings(true)} className={`p-2 rounded-full transition-colors ${!geminiKey&&apiProvider==='gemini'?'text-red-400 animate-pulse bg-red-50':'text-slate-400 hover:bg-[#fff0f5] hover:text-[#d45d79]'}`}><Icons.Settings className="w-6 h-6" /></button>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto px-4 py-6 space-y-5">
                        {/* Mode Switcher */}
                        <div className="flex gap-2 bg-white p-2 rounded-3xl shadow-[4px_4px_0px_#ffdae6] border-2 border-white">
                            <button onClick={() => setMode('text')} className={`flex-1 py-2.5 rounded-2xl text-xs md:text-sm font-bold flex items-center justify-center gap-1 transition-all ${mode==='text'?'bg-[#ffdbed] text-[#d45d79] shadow-sm':'text-slate-400 hover:bg-slate-50'}`}><Icons.Type className="w-4 h-4"/>‰∏ÄËà¨</button>
                            <button onClick={() => setMode('file')} className={`flex-1 py-2.5 rounded-2xl text-xs md:text-sm font-bold flex items-center justify-center gap-1 transition-all ${mode==='file'?'bg-[#e0f7fa] text-[#0277bd] shadow-sm':'text-slate-400 hover:bg-slate-50'}`}><Icons.FileText className="w-4 h-4"/>Êñá‰ª∂/Áõ∏Ê©ü</button>
                        </div>

                        {/* Language Select */}
                        <div className="flex gap-2 items-center justify-center bg-white p-2 rounded-3xl shadow-[4px_4px_0px_#e0f2f1] border-2 border-white">
                            <select value={sourceLang} onChange={e=>setSourceLang(e.target.value)} className="bg-transparent w-full text-sm font-bold text-slate-600 text-center outline-none appearance-none py-2">{LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name.split(' ')[0]}</option>)}</select>
                            <div onClick={()=>{const t=targetLang;setTargetLang(sourceLang);setSourceLang(t)}} className="p-2 rounded-full bg-[#e0f7fa] text-[#0277bd] cursor-pointer active:rotate-180 transition-transform"><Icons.ArrowRightLeft className="w-4 h-4"/></div>
                            <select value={targetLang} onChange={e=>setTargetLang(e.target.value)} className="bg-transparent w-full text-sm font-bold text-slate-600 text-center outline-none appearance-none py-2">{LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name.split(' ')[0]}</option>)}</select>
                        </div>

                        {errorMsg && <div className="bg-red-50 text-red-500 p-4 rounded-2xl text-sm flex items-center gap-2 animate-bounce shadow-sm border border-red-100"><Icons.AlertCircle className="w-5 h-5"/>{errorMsg}</div>}

                        <div className="grid md:grid-cols-2 gap-5">
                            {/* Source Input */}
                            <div className={`card-cute bg-white flex flex-col h-[300px] md:h-[500px] overflow-hidden relative group transition-all ${isListening?'border-[#ff8a80] ring-4 ring-[#ffebee]':''}`}>
                                <div className="p-3 border-b-2 border-slate-50 flex justify-between items-center bg-[#fffbfc]">
                                    <div className="flex items-center gap-2">
                                        <button onClick={() => setIsRealTime(!isRealTime)} className={`p-1.5 rounded-xl transition-all ${isRealTime?'bg-[#fff9c4] text-[#fbc02d] shadow-sm':'text-slate-300 hover:bg-slate-50'}`} title="Âç≥ÊôÇÁøªË≠Ø"><Icons.Zap className="w-4 h-4"/></button>
                                        <span className="text-xs font-bold text-slate-400 tracking-wider">ÂéüÊñá {isListening&&<span className="text-[#ff8a80] animate-pulse">‚óè ËÅΩÂØ´‰∏≠</span>}</span>
                                    </div>
                                    <div className="flex gap-1">
                                        <input type="file" ref={cameraInputRef} className="hidden" accept="image/*" onChange={handleFileChange} />
                                        <button onClick={handleScreenCapture} className="p-2 rounded-xl hover:bg-[#e0f7fa] text-slate-400 hover:text-[#0277bd] hidden sm:block" title="Êà™Âúñ"><Icons.Scissors className="w-4 h-4"/></button>
                                        <button onClick={() => cameraInputRef.current?.click()} className={`p-2 rounded-xl transition-all ${apiProvider==='gemini'&&geminiKey?'text-[#0277bd] bg-[#e0f7fa] hover:bg-[#b3e5fc]':'text-slate-400 hover:text-[#0277bd] hover:bg-[#e0f7fa]'}`} title="Áõ∏Ê©ü"><Icons.Camera className="w-4 h-4"/></button>
                                        <button onClick={() => toggleListening()} className={`p-2 rounded-xl transition-all ${isListening?'bg-[#ff8a80] text-white animate-pulse':'text-slate-400 hover:text-[#d45d79] hover:bg-[#ffdbed]'}`}><Icons.Mic className="w-4 h-4"/></button>
                                        {sourceText && <button onClick={clearAll} className="p-2 rounded-xl hover:bg-red-50 text-slate-300 hover:text-red-400"><Icons.X className="w-4 h-4"/></button>}
                                    </div>
                                </div>
                                <div className="flex-1 relative">
                                    {mode === 'file' && !sourceText ? (
                                        <div onClick={()=>fileInputRef.current?.click()} className={`absolute inset-4 border-4 border-dashed border-[#b3e5fc] rounded-3xl flex flex-col items-center justify-center cursor-pointer text-[#81d4fa] hover:bg-[#e0f7fa] transition-colors ${isDragOver?'bg-[#e0f7fa] border-[#0277bd]':''}`} onDragOver={e=>{e.preventDefault();setIsDragOver(true)}} onDragLeave={e=>{e.preventDefault();setIsDragOver(false)}} onDrop={e=>{e.preventDefault();setIsDragOver(false);processFile(e.dataTransfer.files[0])}}>
                                            <input type="file" ref={fileInputRef} className="hidden" accept=".pdf,.docx,.txt,image/*" onChange={handleFileChange} />
                                            <Icons.UploadCloud className="w-10 h-10 mb-2 animate-bounce-slow" />
                                            <p className="text-sm font-bold">ÈªûÊìäÊàñÊãñÊõ≥Ê™îÊ°à/ÂúñÁâá</p>
                                            <p className="text-[10px] mt-1 opacity-60">PDF / Word / Êà™Âúñ</p>
                                        </div>
                                    ) : (
                                        <textarea value={sourceText} onChange={e=>setSourceText(e.target.value)} className="w-full h-full p-5 resize-none outline-none bg-transparent text-lg text-slate-700 leading-relaxed" placeholder="Ëº∏ÂÖ•ÊñáÂ≠ó..." spellCheck="false" />
                                    )}
                                    {fileName && <div className="absolute bottom-3 left-3 px-3 py-1 bg-[#e0f7fa] text-[#0277bd] text-xs rounded-full font-bold flex items-center gap-1 shadow-sm"><Icons.FileType className="w-3 h-3"/>{fileName}</div>}
                                </div>
                            </div>

                            {/* Target Output */}
                            <div className="card-cute bg-[#fdfdfe] flex flex-col h-[300px] md:h-[500px] overflow-hidden relative border-3 border-white shadow-[4px_4px_0px_#fff9c4]">
                                <div className="p-3 border-b-2 border-slate-50 flex justify-between items-center bg-[#fffdf0]">
                                    <span className="text-xs font-bold text-slate-400 uppercase">Ë≠ØÊñá (AI)</span>
                                    <div className="flex gap-1">
                                        {translatedText && <button onClick={() => setShowBigText(true)} className="p-2 text-slate-400 hover:text-[#fbc02d] hover:bg-[#fff9c4] rounded-xl" title="ÂÖ®Ëû¢Âπï"><Icons.Maximize className="w-4 h-4"/></button>}
                                        <button onClick={()=>copy(translatedText,false)} className="p-2 text-slate-400 hover:text-[#fbc02d] hover:bg-[#fff9c4] rounded-xl"><Icons.Copy className="w-4 h-4"/></button>
                                        <button onClick={()=>speak(translatedText,targetLang)} className="p-2 text-slate-400 hover:text-[#fbc02d] hover:bg-[#fff9c4] rounded-xl"><Icons.Volume2 className="w-4 h-4"/></button>
                                    </div>
                                </div>
                                <div className="flex-1 relative">
                                    {isLoading && <div className="absolute inset-0 bg-white/90 backdrop-blur-[1px] flex flex-col items-center justify-center z-10"><div className="text-4xl mb-2 animate-bounce">ü§î</div><span className="text-xs font-bold text-[#d45d79] animate-pulse">{loadingStatus}</span></div>}
                                    <textarea readOnly value={translatedText} className="w-full h-full p-5 resize-none outline-none bg-transparent text-lg text-slate-800 leading-relaxed" placeholder="Á≠âÂæÖÁøªË≠Ø..." />
                                </div>
                            </div>
                        </div>

                        {/* Bottom Actions */}
                        <div className="bg-white p-3 rounded-3xl shadow-[4px_4px_0px_#f0f0f0] border-2 border-white">
                            <div className="flex items-center justify-between mb-3 px-1">
                                <span className="text-xs font-bold text-slate-400">Ë™ûÊ∞£È¢®Ê†º</span>
                                <div className="flex gap-2 overflow-x-auto hide-scrollbar">
                                    {TONES.map(t => (
                                        <button key={t.id} onClick={()=>setSelectedTone(t.id)} className={`px-3 py-1.5 rounded-xl text-xs font-bold whitespace-nowrap transition-all ${selectedTone===t.id?'bg-[#ffdbed] text-[#d45d79] shadow-sm':'text-slate-400 hover:bg-slate-50'}`}>{t.icon} {t.name.split(' ')[0]}</button>
                                    ))}
                                </div>
                            </div>

                            <div className="grid grid-cols-4 gap-3">
                                <button onClick={() => callAI('translate')} disabled={isLoading || !sourceText} className="col-span-4 md:col-span-1 btn-cute bg-[#d45d79] hover:bg-[#c2405e] text-white py-3.5 rounded-2xl font-bold flex items-center justify-center gap-2 text-sm">
                                    {isLoading ? <Icons.RotateCw className="w-5 h-5 animate-spin"/> : <Icons.Sparkles className="w-5 h-5 text-[#fff9c4]"/>} ÁøªË≠Ø
                                </button>
                                <button onClick={() => callAI('polish')} disabled={isLoading || !sourceText} className="btn-cute bg-[#e0f7fa] hover:bg-[#b3e5fc] text-[#0277bd] py-3 rounded-2xl font-bold flex flex-col items-center justify-center gap-1 text-xs"><Icons.Edit3 className="w-4 h-4"/>ÊΩ§È£æ</button>
                                <button onClick={() => callAI('summarize')} disabled={isLoading || !sourceText} className="btn-cute bg-[#fff9c4] hover:bg-[#fff59d] text-[#f57f17] py-3 rounded-2xl font-bold flex flex-col items-center justify-center gap-1 text-xs"><Icons.List className="w-4 h-4"/>ÊëòË¶Å</button>
                                <button onClick={() => callAI('grammar')} disabled={isLoading || !sourceText} className="btn-cute bg-[#f3e5f5] hover:bg-[#e1bee7] text-[#8e24aa] py-3 rounded-2xl font-bold flex flex-col items-center justify-center gap-1 text-xs"><Icons.Search className="w-4 h-4"/>ÂàÜÊûê</button>
                            </div>
                        </div>
                        
                        <div className="text-center text-[10px] text-[#ffb7c5] font-bold">¬© 2023 Gemini Chiikawa Translate</div>
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
