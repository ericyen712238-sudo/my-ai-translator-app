<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini AI ÂÖ®ËÉΩÊñá‰ª∂Âä©Êâã</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <!-- Mammoth.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>

    <!-- Tesseract.js -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <!-- Marked.js -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body {
            font-family: 'Zen Maru Gothic', 'Microsoft JhengHei', system-ui, -apple-system, sans-serif;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior-y: none; 
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background-color: #94a3b8; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-spin { animation: spin 1s linear infinite; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .no-select { user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        
        /* UI Styles */
        .crop-modal { touch-action: none; } 
        .visual-text-box { touch-action: none; backdrop-filter: blur(4px); text-shadow: 0 1px 2px rgba(0,0,0,0.3); }

        /* Markdown */
        .prose { font-size: 1.05rem; line-height: 1.7; color: #334155; max-width: none; }
        .prose h1 { font-size: 1.4em; font-weight: 700; margin: 0.8em 0 0.4em; color: #0f172a; }
        .prose h2 { font-size: 1.2em; font-weight: 600; margin: 0.8em 0 0.4em; color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 0.2em; }
        .prose ul { list-style-type: disc; padding-left: 1.2em; margin-bottom: 0.8em; }
        .prose ol { list-style-type: decimal; padding-left: 1.2em; margin-bottom: 0.8em; }
        .prose li { margin-bottom: 0.2em; }
        .prose strong { font-weight: 700; color: #0f172a; background-color: #f1f5f9; padding: 0 2px; rounded: 2px; }
        .prose blockquote { border-left: 4px solid #6366f1; padding-left: 1em; font-style: italic; color: #475569; background-color: #f8fafc; padding: 0.5em 1em; border-radius: 0 0.5em 0.5em 0; }
    </style>
</head>
<body class="bg-gradient-to-br from-sky-50 via-white to-indigo-50 text-slate-800 min-h-screen">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- Icons ---
        const Icon = ({ children, className = "w-6 h-6" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Icons = {
            Languages: () => <Icon><path d="m5 8 6 6"/><path d="m4 14 6-6 2-3"/><path d="M2 5h12"/><path d="M7 2h1"/><path d="m22 22-5-10-5 10"/><path d="M14 18h6"/></Icon>,
            FileText: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></Icon>,
            Type: () => <Icon><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></Icon>,
            UploadCloud: () => <Icon><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></Icon>,
            ArrowRightLeft: () => <Icon><path d="m16 3 4 4-4 4"/><path d="M20 7H4"/><path d="m8 21-4-4 4-4"/><path d="M4 17h16"/></Icon>,
            Copy: () => <Icon><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></Icon>,
            Check: () => <Icon className="w-4 h-4 text-green-500"><polyline points="20 6 9 17 4 12"/></Icon>,
            Volume2: () => <Icon><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></Icon>,
            X: () => <Icon><path d="M18 6 6 18"/><path d="m6 6 12 12"/></Icon>,
            RotateCw: () => <Icon className="w-5 h-5 animate-spin"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 12"/><path d="M21 3v9h-9"/></Icon>,
            Sparkles: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/></Icon>,
            AlertCircle: () => <Icon><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></Icon>,
            Mic: () => <Icon><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="22"/></Icon>,
            MicOff: () => <Icon><line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V5a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"/><line x1="12" y1="19" x2="12" y2="22"/></Icon>,
            FileType: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M9 13v-1h6v1"/><path d="M12 12v6"/><path d="M11 18h2"/></Icon>,
            Settings: () => <Icon><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Save: () => <Icon><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></Icon>,
            Server: () => <Icon><rect width="20" height="8" x="2" y="2" rx="2" ry="2"/><rect width="20" height="8" x="2" y="14" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></Icon>,
            Camera: () => <Icon><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></Icon>,
            Globe: () => <Icon><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></Icon>,
            Key: () => <Icon><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></Icon>,
            Magic: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H1"/><path d="M19 18v4"/><path d="M21 20h-4"/></Icon>,
            Edit3: () => <Icon><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></Icon>,
            List: () => <Icon><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></Icon>,
            Search: () => <Icon><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></Icon>,
            Eye: () => <Icon><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Clock: () => <Icon><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></Icon>,
            Trash: () => <Icon><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></Icon>,
            Zap: () => <Icon><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></Icon>,
            Scissors: () => <Icon><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></Icon>,
            MessageSquare: () => <Icon><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></Icon>,
            Maximize: () => <Icon><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></Icon>,
            CPU: () => <Icon><rect width="16" height="16" x="4" y="4" rx="2"/><rect width="6" height="6" x="9" y="9"/><path d="M9 1v3"/><path d="M15 1v3"/><path d="M9 20v3"/><path d="M15 20v3"/><path d="M20 9h3"/><path d="M20 14h3"/><path d="M1 9h3"/><path d="M1 14h3"/></Icon>,
            Crop: () => <Icon><path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"/><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"/></Icon>,
            Volume3: () => <Icon><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></Icon>,
            Image: () => <Icon><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></Icon>,
            Code: () => <Icon><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></Icon>
        };

        const DEFAULT_OLLAMA_URL = "http://localhost:11434/api/generate";
        const DEFAULT_OLLAMA_MODEL = "gemma:2b";

        const GEMINI_MODELS = [
            { id: 'gemini-2.5-flash-preview-09-2025', name: 'Flash 2.5 (ÊúÄÊñ∞)', desc: 'È†êË®≠' },
            { id: 'gemini-1.5-flash-001', name: 'Flash 1.5 (Á©©ÂÆö)', desc: 'Âø´ÈÄü' },
            { id: 'gemini-1.5-pro-001', name: 'Pro 1.5 (Â∞àÊ•≠)', desc: 'È´òÂìÅË≥™' },
            { id: 'custom', name: 'Ëá™Ë®ÇÊ®°Âûã', desc: 'ÊâãÂãï' }
        ];

        const LANGUAGES = [
            { code: 'auto', name: 'Ëá™ÂãïËæ®Ë≠ò (Auto)' },
            { code: 'zh-TW', name: 'ÁπÅÈ´î‰∏≠Êñá (Chinese)' },
            { code: 'en', name: 'English' },
            { code: 'ja', name: 'Êó•Êú¨Ë™û (Japanese)' },
            { code: 'ko', name: 'ÌïúÍµ≠Ïñ¥ (Korean)' },
            { code: 'es', name: 'Espa√±ol (Spanish)' },
            { code: 'fr', name: 'Fran√ßais (French)' },
            { code: 'de', name: 'Deutsch (German)' },
            { code: 'vi', name: 'Ti·∫øng Vi·ªát (Vietnamese)' },
            { code: 'th', name: '‡πÑ‡∏ó‡∏¢ (Thai)' },
        ];

        // Define Task Modes
        const TASKS = [
            { id: 'translate', name: '‰∏ÄËà¨ÁøªË≠Ø', icon: <Icons.Languages className="w-4 h-4"/>, btnColor: 'bg-blue-600 hover:bg-blue-700', prompt: 'Translate' },
            { id: 'summarize', name: 'ÊëòË¶ÅÊï¥ÁêÜ', icon: <Icons.List className="w-4 h-4"/>, btnColor: 'bg-orange-500 hover:bg-orange-600', prompt: 'Summarize' },
            { id: 'polish', name: 'ÊΩ§È£æÂÑ™Âåñ', icon: <Icons.Magic className="w-4 h-4"/>, btnColor: 'bg-purple-600 hover:bg-purple-700', prompt: 'Polish' },
            { id: 'grammar', name: 'ÊñáÊ≥ïÂàÜÊûê', icon: <Icons.Search className="w-4 h-4"/>, btnColor: 'bg-emerald-600 hover:bg-emerald-700', prompt: 'Analyze' }
        ];

        const TONES = [
            { id: 'standard', name: 'Ê®ôÊ∫ñ', icon: '‚ú®' },
            { id: 'formal', name: 'Á¶ÆË≤å', icon: 'üëî' },
            { id: 'casual', name: 'ËºïÈ¨Ü', icon: 'üòé' },
            { id: 'academic', name: 'Â∞àÊ•≠', icon: 'üéì' },
            { id: 'creative', name: 'ÂÑ™Áæé', icon: 'üé®' },
        ];

        const fetchWithRetry = async (url, options, retries = 3, delay = 1000) => {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({}));
                    const errorMessage = errorBody.error?.message || `HTTP error! status: ${response.status}`;
                    if (response.status >= 400 && response.status < 500) {
                        throw new Error(`Ë´ãÊ±ÇÂ§±Êïó (${response.status}): ${errorMessage} - Ë´ãÊ™¢Êü•Ê®°ÂûãÂêçÁ®±Êàñ API Key`); 
                    }
                    throw new Error(errorMessage);
                }
                return await response.json();
            } catch (error) {
                if (retries > 0 && !error.message.includes("400") && !error.message.includes("404")) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithRetry(url, options, retries - 1, delay * 2);
                } else {
                    throw error;
                }
            }
        };

        const compressImage = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;
                        const MAX_WIDTH = 1500; 
                        const MAX_HEIGHT = 1500;
                        if (width > height) {
                            if (width > MAX_WIDTH) {
                                height *= MAX_WIDTH / width;
                                width = MAX_WIDTH;
                            }
                        } else {
                            if (height > MAX_HEIGHT) {
                                width *= MAX_HEIGHT / height;
                                height = MAX_HEIGHT;
                            }
                        }
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        const base64Data = canvas.toDataURL('image/jpeg', 0.8);
                        resolve(base64Data.split(',')[1]);
                    };
                    img.onerror = (err) => reject(err);
                };
                reader.onerror = (err) => reject(err);
            });
        };

        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = error => reject(error);
            });
        };

        const renderPdfFirstPage = async (arrayBuffer) => {
            const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: 2.0 });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            await page.render({ canvasContext: context, viewport: viewport }).promise;
            return new Promise(resolve => {
                canvas.toBlob(resolve, 'image/jpeg', 0.8);
            });
        };

        function App() {
            const [mode, setMode] = useState('text'); 
            const [currentTask, setCurrentTask] = useState('translate'); // New State for Task
            
            const [sourceText, setSourceText] = useState('');
            const [translatedText, setTranslatedText] = useState('');
            const [sourceLang, setSourceLang] = useState('auto');
            const [targetLang, setTargetLang] = useState('zh-TW');
            const [selectedTone, setSelectedTone] = useState('standard');
            const [isLoading, setIsLoading] = useState(false);
            const [loadingStatus, setLoadingStatus] = useState('');
            const [errorMsg, setErrorMsg] = useState('');
            const [fileName, setFileName] = useState(null);
            const [isDragOver, setIsDragOver] = useState(false);
            const [showSettings, setShowSettings] = useState(false);
            const [showHistory, setShowHistory] = useState(false);
            const [showBigText, setShowBigText] = useState(false);
            const [isRealTime, setIsRealTime] = useState(false);
            const [isMarkdownMode, setIsMarkdownMode] = useState(true); 
            
            const [voiceRate, setVoiceRate] = useState(1);
            const [voicePitch, setVoicePitch] = useState(1);
            const [availableVoices, setAvailableVoices] = useState([]);
            const [selectedVoiceURI, setSelectedVoiceURI] = useState('');
            
            const [showCropModal, setShowCropModal] = useState(false);
            const [cropImageSrc, setCropImageSrc] = useState(null);
            const [cropSelection, setCropSelection] = useState(null); 
            const [isCropping, setIsCropping] = useState(false);
            
            const [showVisualMode, setShowVisualMode] = useState(false);
            const [displayImage, setDisplayImage] = useState(null);
            const [visualTextPos, setVisualTextPos] = useState({ x: 50, y: 50 });
            const [visualFontSize, setVisualFontSize] = useState(18);
            const [visualDragging, setVisualDragging] = useState(false);
            
            const dragStartRef = useRef(null);
            const isDraggingRef = useRef(false);
            const visualDragStartRef = useRef(null);
            
            const imageRef = useRef(null);
            const cropContainerRef = useRef(null);
            const visualContainerRef = useRef(null);

            const [conversationChat, setConversationChat] = useState([]);
            const [activeSpeaker, setActiveSpeaker] = useState(null);

            const [apiProvider, setApiProvider] = useState('gemini'); 
            const [geminiKey, setGeminiKey] = useState(localStorage.getItem('gemini_api_key') || '');
            const [geminiModel, setGeminiModel] = useState(localStorage.getItem('gemini_model') || 'gemini-2.5-flash-preview-09-2025');
            const [ollamaUrl, setOllamaUrl] = useState(DEFAULT_OLLAMA_URL);
            const [ollamaModel, setOllamaModel] = useState(DEFAULT_OLLAMA_MODEL);
            const [isListening, setIsListening] = useState(false);
            const [copiedSource, setCopiedSource] = useState(false);
            const [copiedTarget, setCopiedTarget] = useState(false);
            const [history, setHistory] = useState(JSON.parse(localStorage.getItem('translate_history') || '[]'));

            const recognitionRef = useRef(null);
            const fileInputRef = useRef(null);
            const cameraInputRef = useRef(null);
            const requestCounter = useRef(0);
            const chatEndRef = useRef(null);

            useEffect(() => { localStorage.setItem('gemini_api_key', geminiKey); }, [geminiKey]);
            useEffect(() => { localStorage.setItem('gemini_model', geminiModel); }, [geminiModel]);
            useEffect(() => { localStorage.setItem('translate_history', JSON.stringify(history)); }, [history]);
            
            useEffect(() => {
                if (mode === 'conversation') {
                    chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
                }
            }, [conversationChat, mode]);

            useEffect(() => {
                const loadVoices = () => {
                    const voices = window.speechSynthesis.getVoices();
                    setAvailableVoices(voices);
                };
                loadVoices();
                window.speechSynthesis.onvoiceschanged = loadVoices;
            }, []);

            useEffect(() => {
                if (mode !== 'text' && mode !== 'file') return;
                const handlePaste = (e) => {
                    const items = e.clipboardData?.items;
                    if (!items) return;
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].type.indexOf('image') !== -1) {
                            e.preventDefault();
                            const file = items[i].getAsFile();
                            processFile(file);
                            break;
                        }
                    }
                };
                window.addEventListener('paste', handlePaste);
                return () => window.removeEventListener('paste', handlePaste);
            }, [apiProvider, geminiKey, sourceLang, mode]); 

            useEffect(() => {
                if (!isRealTime || !sourceText.trim() || mode !== 'text') return;
                const timer = setTimeout(() => { if (sourceText.length > 1) callAI(currentTask); }, 1200); // Use currentTask
                return () => clearTimeout(timer);
            }, [sourceText, isRealTime, sourceLang, targetLang, apiProvider, selectedTone, mode, currentTask]); // Add currentTask dependency

            const addToHistory = (src, res, sLang, tLang) => {
                if (!src || !res) return;
                const newItem = { id: Date.now(), src, res, sLang, tLang, timestamp: new Date().toLocaleString() };
                setHistory(prev => [newItem, ...prev].slice(0, 50));
            };

            const clearHistory = () => { if(confirm("Á¢∫ÂÆöË¶ÅÊ∏ÖÈô§ÊâÄÊúâÊ≠∑Âè≤Á¥ÄÈåÑÂóéÔºü")) setHistory([]); };

            const handleScreenCapture = async () => {
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "never" }, audio: false });
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    await video.play();
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);
                    stream.getTracks().forEach(track => track.stop());
                    canvas.toBlob(blob => {
                        const file = new File([blob], "screenshot.png", { type: 'image/png' });
                        processFile(file);
                    });
                } catch (e) { 
                    console.log("Screen capture cancelled", e); 
                    alert("Êà™ÂúñÂ§±ÊïóÔºåË´ãÊ™¢Êü•Ê¨äÈôê„ÄÇ");
                }
            };

            // --- Visual Mode Handlers ---
            const handleVisualDragStart = (e) => {
                e.preventDefault(); 
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                visualDragStartRef.current = { x: clientX, y: clientY };
                setVisualDragging(true);
            };

            const handleVisualDragMove = (e) => {
                if (!visualDragging || !visualDragStartRef.current || !visualContainerRef.current) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const containerRect = visualContainerRef.current.getBoundingClientRect();
                const deltaX = ((clientX - visualDragStartRef.current.x) / containerRect.width) * 100;
                const deltaY = ((clientY - visualDragStartRef.current.y) / containerRect.height) * 100;
                setVisualTextPos(prev => ({
                    x: Math.max(0, Math.min(100, prev.x + deltaX)),
                    y: Math.max(0, Math.min(100, prev.y + deltaY))
                }));
                visualDragStartRef.current = { x: clientX, y: clientY };
            };

            const handleVisualDragEnd = () => {
                setVisualDragging(false);
                visualDragStartRef.current = null;
            };

            // --- Crop Handlers (Optimized) ---
            const getClientCoordinates = (e) => {
                const imgRect = imageRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                let x = clientX - imgRect.left;
                let y = clientY - imgRect.top;
                x = Math.max(0, Math.min(x, imgRect.width));
                y = Math.max(0, Math.min(y, imgRect.height));
                return { x, y };
            };

            const handleCropStart = (e) => {
                if(e.type === 'mousedown') e.preventDefault(); 
                if(!cropImageSrc) return;
                const coords = getClientCoordinates(e);
                dragStartRef.current = coords;
                isDraggingRef.current = true;
                setCropSelection({ x: coords.x, y: coords.y, w: 0, h: 0 });
            };

            const handleCropMove = (e) => {
                if (e.cancelable && e.type.startsWith('touch')) e.preventDefault();
                if (!isDraggingRef.current || !dragStartRef.current) return;
                const coords = getClientCoordinates(e);
                const start = dragStartRef.current;
                const currentX = coords.x;
                const currentY = coords.y;
                const x = Math.min(start.x, currentX);
                const y = Math.min(start.y, currentY);
                const w = Math.abs(currentX - start.x);
                const h = Math.abs(currentY - start.y);
                setCropSelection({ x, y, w, h });
            };

            const handleCropEnd = () => {
                isDraggingRef.current = false;
                dragStartRef.current = null;
            };

            const handleCropConfirm = async () => {
                if (!cropSelection) {
                    alert("Ë´ãÂÖàÂú®ÂúñÁâá‰∏äÊªëÂãïÊâãÊåáÈÅ∏ÂèñÁØÑÂúç");
                    return;
                }
                const img = imageRef.current;
                const canvas = document.createElement('canvas');
                const scaleX = img.naturalWidth / img.clientWidth;
                const scaleY = img.naturalHeight / img.clientHeight;
                canvas.width = Math.max(1, cropSelection.w * scaleX);
                canvas.height = Math.max(1, cropSelection.h * scaleY);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, cropSelection.x * scaleX, cropSelection.y * scaleY, cropSelection.w * scaleX, cropSelection.h * scaleY, 0, 0, canvas.width, canvas.height);
                canvas.toBlob(blob => {
                    const file = new File([blob], "cropped_selection.jpg", { type: 'image/jpeg' });
                    setShowCropModal(false);
                    setMode('text');
                    runOCR(file);
                }, 'image/jpeg', 0.9);
            };

            const handleFullImageConfirm = async () => {
                const res = await fetch(cropImageSrc);
                const blob = await res.blob();
                const file = new File([blob], "full_image.jpg", { type: 'image/jpeg' });
                setShowCropModal(false);
                setMode('text');
                runOCR(file);
            };

            const runOCR = async (file) => {
                setErrorMsg('');
                setSourceText('');
                setIsLoading(true);
                setLoadingStatus('Ê≠£Âú®ËÆÄÂèñÂúñÁâá...');
                const reader = new FileReader();
                reader.onload = (e) => setDisplayImage(e.target.result);
                reader.readAsDataURL(file);
                try {
                    let text = "";
                    if (apiProvider === 'gemini') text = await performGeminiOCR(file);
                    else text = await performLegacyOCR(file);
                    
                    if (!text || !text.trim()) throw new Error("ÁÑ°Ê≥ïËæ®Ë≠òÂúñÁâá‰∏≠ÁöÑÊñáÂ≠ó");
                    setSourceText(text);
                    callAI(currentTask, text); // Auto run current task after OCR
                } catch (err) {
                    console.error(err);
                    setErrorMsg(err.message || "ËÆÄÂèñÂ§±Êïó");
                    setIsLoading(false);
                }
            };

            const performGeminiOCR = async (file) => {
                const trimmedKey = geminiKey.trim();
                if (!trimmedKey) {
                    setShowSettings(true);
                    throw new Error("Ë´ãËº∏ÂÖ• Gemini API Key");
                }
                setLoadingStatus('AI Ê≠£Âú®Â£ìÁ∏Æ‰∏¶ËÆÄÂèñÂúñÁâá...');
                const base64Image = await compressImage(file);
                const mimeType = 'image/jpeg';
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${trimmedKey}`;
                const payload = {
                    contents: [{
                        parts: [
                            { text: "Please convert the text in this image to plain text. Output ONLY the text found in the image." },
                            { inline_data: { mime_type: mimeType, data: base64Image } }
                        ]
                    }]
                };
                const data = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error("AI ÁÑ°Ê≥ïËæ®Ë≠òÂúñÁâá‰∏≠ÁöÑÊñáÂ≠ó");
                return text.trim();
            };

            const performLegacyOCR = async (file) => {
                if (!window.Tesseract) throw new Error("OCR ÂÖÉ‰ª∂ËºâÂÖ•‰∏≠...");
                let tessLang = 'eng'; 
                if (sourceLang === 'auto') tessLang = 'chi_tra+eng'; 
                else if (sourceLang.includes('zh')) tessLang = 'chi_tra+eng';
                else if (sourceLang.includes('ja')) tessLang = 'jpn+eng';
                else if (sourceLang.includes('ko')) tessLang = 'kor+eng';
                setLoadingStatus(`‰∏ãËºâËæ®Ë≠òÊ®°Âûã‰∏≠...`);
                const { data: { text } } = await Tesseract.recognize(file, tessLang, {
                    logger: m => { if (m.status === 'recognizing text') setLoadingStatus(`Ëæ®Ë≠òÊñáÂ≠ó‰∏≠... ${Math.round(m.progress * 100)}%`); }
                });
                return text;
            };

            const processFile = async (file) => {
                if (!file) return;
                setFileName(file.name || "File");
                const lowerName = file.name ? file.name.toLowerCase() : 'image.jpg';
                const fileType = file.type || '';

                if (fileType.startsWith('image/') || lowerName.match(/\.(jpg|jpeg|png|bmp|webp)$/)) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setCropImageSrc(e.target.result);
                        setDisplayImage(e.target.result);
                        setCropSelection(null);
                        setShowCropModal(true);
                    };
                    reader.readAsDataURL(file);
                    return;
                }

                setMode('text');
                setSourceText('');
                setIsLoading(true);
                setLoadingStatus('Ê≠£Âú®ËôïÁêÜÊñá‰ª∂...');
                setDisplayImage(null);

                try {
                    let text = "";
                    if (lowerName.endsWith('.pdf')) {
                        if (!window.pdfjsLib) throw new Error("PDF ÂÖÉ‰ª∂ËºâÂÖ•‰∏≠...");
                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        const maxPages = Math.min(pdf.numPages, 30);
                        for (let i = 1; i <= maxPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            text += textContent.items.map(item => item.str).join(' ') + '\n\n';
                        }
                        // Fallback for scanned PDF
                         if ((!text || text.trim().length < 50) && geminiKey) {
                            setLoadingStatus('PDF ÁÑ°ÊñáÂ≠óÂ±§ÔºåÂòóË©¶ OCR Ëæ®Ë≠òÁ¨¨‰∏ÄÈ†Å...');
                            const imageBlob = await renderPdfFirstPage(arrayBuffer);
                            const imageFile = new File([imageBlob], "pdf_page_1.jpg", { type: "image/jpeg" });
                            await runOCR(imageFile);
                            return; 
                        }
                    } else if (lowerName.endsWith('.docx')) {
                        if (!window.mammoth) throw new Error("Word ÂÖÉ‰ª∂ËºâÂÖ•‰∏≠...");
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await window.mammoth.extractRawText({ arrayBuffer });
                        text = result.value;
                    } else {
                        text = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = e => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(file);
                        });
                    }
                    
                    if (!text || !text.trim()) throw new Error("ÁÑ°Ê≥ïËÆÄÂèñÊñáÂ≠ó");
                    setSourceText(text);
                    callAI(currentTask, text); // Auto run current task
                } catch (err) {
                    console.error(err);
                    setErrorMsg(err.message || "ËÆÄÂèñÂ§±Êïó");
                    setIsLoading(false);
                } 
            };

            const handleFileChange = (e) => processFile(e.target.files[0]);
            
            const toggleListening = () => {
                if (isListening) { recognitionRef.current?.stop(); setIsListening(false); return; }
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) { setErrorMsg("ÁÄèË¶ΩÂô®‰∏çÊîØÊè¥Ë™ûÈü≥Ëº∏ÂÖ•"); return; }
                const recognition = new SpeechRecognition();
                if (sourceLang !== 'auto') recognition.lang = sourceLang;
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.onstart = () => { setIsListening(true); setErrorMsg(''); };
                recognition.onend = () => setIsListening(false);
                recognition.onresult = (event) => {
                    let final = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) final += event.results[i][0].transcript;
                    }
                    if (final) setSourceText(prev => prev + (prev ? ' ' : '') + final);
                };
                recognitionRef.current = recognition;
                recognition.start();
            };

            const startConversationVoice = (lang, speaker) => {
                if (isListening) return;
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) { setErrorMsg("Ê≠§ÁÄèË¶ΩÂô®‰∏çÊîØÊè¥Ë™ûÈü≥Ëº∏ÂÖ•"); return; }

                const recognition = new SpeechRecognition();
                let useLang = lang;
                if (lang === 'auto') useLang = 'en-US';
                
                recognition.lang = useLang;
                recognition.continuous = false;
                recognition.interimResults = true;
                recognition.onstart = () => { setIsListening(true); setActiveSpeaker(speaker); setErrorMsg(''); };
                recognition.onend = () => { setIsListening(false); setActiveSpeaker(null); };
                recognition.onresult = (event) => {
                    let final = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) final += event.results[i][0].transcript;
                    }
                    if (final) handleConversationTranslate(final, speaker);
                };
                recognitionRef.current = recognition;
                try { recognition.start(); } catch(e) { console.error(e); setIsListening(false); }
            };

            const stopConversationVoice = () => { if (recognitionRef.current) recognitionRef.current.stop(); };

            const handleConversationTranslate = async (text, speaker) => {
                if (!text.trim()) return;
                const sLang = sourceLang === 'auto' ? 'en' : sourceLang;
                const tLang = targetLang;
                const fromLang = speaker === 'user' ? tLang : sLang;
                const toLang = speaker === 'user' ? sLang : tLang;
                const newMessage = { id: Date.now(), speaker: speaker, text: text, translation: '...', isPending: true };
                setConversationChat(prev => [...prev, newMessage]);

                try {
                    const translation = await performTranslation(text, fromLang, toLang);
                    setConversationChat(prev => prev.map(msg => msg.id === newMessage.id ? { ...msg, translation: translation, isPending: false } : msg));
                    speak(translation, toLang);
                } catch (e) {
                    setConversationChat(prev => prev.map(msg => msg.id === newMessage.id ? { ...msg, translation: "Error", isPending: false } : msg));
                }
            };

            const performTranslation = async (text, sLangCode, tLangCode) => {
                const sName = LANGUAGES.find(l => l.code === sLangCode)?.name || sLangCode;
                const tName = LANGUAGES.find(l => l.code === tLangCode)?.name || tLangCode;
                let systemInstruction = `Translate the following text from ${sName} to ${tName}. Output ONLY the translated text.`;
                
                if (apiProvider === 'gemini') {
                    const trimmedKey = geminiKey.trim();
                    if (!trimmedKey) throw new Error("Key missing");
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${trimmedKey}`;
                    const payload = { contents: [{ parts: [{ text: text }] }], systemInstruction: { parts: [{ text: systemInstruction }] } };
                    const data = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
                } else if (apiProvider === 'mymemory') {
                    const pair = `${sLangCode}|${tLangCode}`;
                    const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${pair}`;
                    const res = await fetch(url);
                    const data = await res.json();
                    return data.responseData.translatedText;
                } else { return `[${tName}] ${text}`; }
            };

            const callAI = async (promptType, textOverride = null) => {
                const textToUse = textOverride !== null ? textOverride : sourceText;
                if (!textToUse.trim()) return;
                if (apiProvider === 'mymemory' && promptType !== 'translate') { setErrorMsg("MyMemory ÂÉÖÊîØÊè¥Âü∫Á§éÁøªË≠Ø"); return; }

                const currentRequestId = ++requestCounter.current;
                setIsLoading(true);
                setErrorMsg('');
                if (!isRealTime && textOverride === null) setTranslatedText(''); 

                const tName = LANGUAGES.find(l => l.code === targetLang)?.name || targetLang;
                const sName = sourceLang === 'auto' ? 'Auto Detect' : LANGUAGES.find(l => l.code === sourceLang)?.name;
                const toneInfo = TONES.find(t => t.id === selectedTone)?.name || 'Standard';

                let systemInstruction = "";
                // Prompts based on Task Type
                if (promptType === 'translate') {
                     systemInstruction = `Translate input to ${tName}. Source: ${sName}. Tone: ${toneInfo}. Rules: Output ONLY translated text. Use Markdown for formatting (paragraphs, lists, bolding).`;
                } else if (promptType === 'polish') {
                     systemInstruction = `Rewrite text into ${tName} to be professional/fluent. Tone: ${toneInfo}. Output ONLY rewritten text in Markdown.`;
                } else if (promptType === 'summarize') {
                     systemInstruction = `Summarize the following text into ${tName}. Format: Markdown with Title, Bullet Points, and Conclusion. Keep it concise and structured.`;
                } else if (promptType === 'grammar') {
                     systemInstruction = `Analyze text. 1. ID Source Lang. 2. Grammar errors. 3. Key vocab. 4. Corrected version. Output in ${tName} using Markdown.`;
                }

                if(!textOverride) setLoadingStatus("AI ËôïÁêÜ‰∏≠...");

                try {
                    let resultText = "";
                    if (apiProvider === 'gemini') {
                        const trimmedKey = geminiKey.trim();
                        if (!trimmedKey) { setShowSettings(true); throw new Error("Ë´ãËº∏ÂÖ• Key"); }
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${trimmedKey}`;
                        const payload = { contents: [{ parts: [{ text: textToUse }] }], systemInstruction: { parts: [{ text: systemInstruction }] } };
                        const data = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        resultText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
                    } else if (apiProvider === 'mymemory' && promptType === 'translate') {
                        resultText = await performTranslation(textToUse, sourceLang === 'auto' ? 'Autodetect' : sourceLang, targetLang);
                    } else {
                        resultText = "Ê≠§Ê®°Âºè‰∏çÊîØÊè¥ÈÄ≤ÈöéÂäüËÉΩ";
                    }

                    if (currentRequestId === requestCounter.current) {
                        setTranslatedText(resultText);
                        if (resultText && !resultText.startsWith("Error") && !resultText.startsWith("Ê≠§Ê®°Âºè")) {
                            addToHistory(textToUse, resultText, sourceLang, targetLang);
                        }
                    }
                } catch (error) { if (currentRequestId === requestCounter.current) setErrorMsg(error.message); } 
                finally { if (currentRequestId === requestCounter.current) { setIsLoading(false); setLoadingStatus(''); } }
            };

            const copy = (t, isS) => { if(!t)return; navigator.clipboard.writeText(t); if(isS){setCopiedSource(true);setTimeout(()=>setCopiedSource(false),2000)}else{setCopiedTarget(true);setTimeout(()=>setCopiedTarget(false),2000)} };
            const speak = (t, l) => { 
                if(!t)return; 
                window.speechSynthesis.cancel(); 
                const u = new SpeechSynthesisUtterance(t); 
                u.lang = l; 
                u.rate = voiceRate;
                u.pitch = voicePitch;
                if (selectedVoiceURI) {
                    u.voice = availableVoices.find(v => v.voiceURI === selectedVoiceURI);
                }
                window.speechSynthesis.speak(u); 
            };
            const clearAll = () => { setSourceText(''); setTranslatedText(''); setFileName(null); setErrorMsg(''); if(fileInputRef.current) fileInputRef.current.value = ''; };

            // Render Translated Text (Markdown or Plain)
            const renderResult = () => {
                if (isMarkdownMode) {
                    return <div className="prose prose-sm max-w-none text-slate-800 leading-relaxed overflow-y-auto h-full p-4" dangerouslySetInnerHTML={{ __html: marked.parse(translatedText || '') }} />;
                } else {
                    return <textarea readOnly value={translatedText} className="w-full h-full p-4 resize-none outline-none bg-transparent text-lg" placeholder="ÁµêÊûú..." />;
                }
            };

            return (
                <div className="pb-12">
                    {/* Visual Mode Modal */}
                    {showVisualMode && displayImage && (
                        <div className="fixed inset-0 bg-black z-[80] flex flex-col animate-in fade-in duration-200"
                             onMouseMove={handleVisualDragMove}
                             onTouchMove={handleVisualDragMove}
                             onMouseUp={handleVisualDragEnd}
                             onTouchEnd={handleVisualDragEnd}
                        >
                            <div className="flex justify-between items-center p-4 bg-black/50 text-white z-20 absolute top-0 left-0 right-0">
                                <div className="flex gap-2">
                                    <button onClick={() => setVisualFontSize(s => Math.max(12, s - 2))} className="p-2 bg-white/20 rounded">A-</button>
                                    <button onClick={() => setVisualFontSize(s => Math.min(48, s + 2))} className="p-2 bg-white/20 rounded">A+</button>
                                </div>
                                <button onClick={() => setShowVisualMode(false)} className="p-2 bg-white/20 rounded-full"><Icons.X className="w-6 h-6"/></button>
                            </div>
                            
                            <div className="flex-1 relative overflow-hidden flex items-center justify-center bg-gray-900" ref={visualContainerRef}>
                                <img src={displayImage} className="max-w-full max-h-full object-contain pointer-events-none select-none" alt="Original" />
                                
                                {translatedText && (
                                    <div 
                                        className="absolute visual-text-box bg-black/60 text-white p-4 rounded-lg cursor-move border border-white/30"
                                        style={{
                                            left: `${visualTextPos.x}%`,
                                            top: `${visualTextPos.y}%`,
                                            transform: 'translate(-50%, -50%)',
                                            fontSize: `${visualFontSize}px`,
                                            maxWidth: '80vw',
                                            minWidth: '100px'
                                        }}
                                        onMouseDown={handleVisualDragStart}
                                        onTouchStart={handleVisualDragStart}
                                    >
                                        {translatedText}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Crop Modal */}
                    {showCropModal && (
                        <div className="fixed inset-0 bg-black/90 z-[70] flex flex-col animate-in fade-in duration-200 crop-modal"
                             onMouseMove={handleCropMove}
                             onTouchMove={handleCropMove}
                             onMouseUp={handleCropEnd}
                             onTouchEnd={handleCropEnd}
                        >
                            <div className="flex justify-between items-center p-4 bg-black/50 text-white z-10">
                                <h3 className="font-bold">Ë£ÅÂàáÈÅ∏ÂèñÂçÄÂüü</h3>
                                <button onClick={() => { setShowCropModal(false); setCropImageSrc(null); }} className="p-2"><Icons.X className="w-6 h-6"/></button>
                            </div>
                            <div className="flex-1 relative flex items-center justify-center overflow-hidden">
                                <div className="relative">
                                    <img 
                                        ref={imageRef} 
                                        src={cropImageSrc} 
                                        className="max-w-full max-h-[80vh] object-contain no-select block" 
                                        draggable="false"
                                        alt="Crop Preview"
                                        onMouseDown={handleCropStart}
                                        onTouchStart={handleCropStart}
                                    />
                                    {cropSelection && (
                                        <div 
                                            className="absolute border-2 border-yellow-400 bg-yellow-400/30 pointer-events-none shadow-[0_0_0_9999px_rgba(0,0,0,0.5)]"
                                            style={{
                                                left: cropSelection.x,
                                                top: cropSelection.y,
                                                width: cropSelection.w,
                                                height: cropSelection.h
                                            }}
                                        />
                                    )}
                                </div>
                            </div>
                            <div className="p-4 bg-black/80 grid grid-cols-2 gap-4 z-10">
                                <button onClick={handleFullImageConfirm} className="bg-slate-700 hover:bg-slate-600 text-white py-3.5 rounded-xl font-bold text-sm">
                                    ÁøªË≠ØÊï¥Âºµ
                                </button>
                                <button onClick={handleCropConfirm} className={`py-3.5 rounded-xl font-bold text-sm ${!cropSelection ? 'bg-indigo-900 text-indigo-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-500 text-white'}`} disabled={!cropSelection}>
                                    ÁøªË≠ØÈÅ∏ÂèñÂçÄÂüü
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Full Screen Text Modal */}
                    {showBigText && (
                        <div className="fixed inset-0 bg-white z-[60] flex flex-col animate-in fade-in duration-200">
                            <div className="flex justify-end p-4">
                                <button onClick={() => setShowBigText(false)} className="p-2 bg-slate-100 rounded-full"><Icons.X className="w-8 h-8 text-slate-600"/></button>
                            </div>
                            <div className="flex-1 flex items-center justify-center p-8 overflow-y-auto">
                                {isMarkdownMode ? (
                                    <div className="prose prose-xl max-w-3xl text-slate-900 leading-relaxed text-center" dangerouslySetInnerHTML={{ __html: marked.parse(translatedText || "Â∞öÁÑ°ÁøªË≠ØÂÖßÂÆπ") }} />
                                ) : (
                                    <p className="text-4xl md:text-6xl font-bold text-slate-900 leading-tight text-center whitespace-pre-wrap font-['Zen_Maru_Gothic']">
                                        {translatedText || "Â∞öÁÑ°ÁøªË≠ØÂÖßÂÆπ"}
                                    </p>
                                )}
                            </div>
                            <div className="p-8 flex justify-center gap-4">
                                <button onClick={() => speak(translatedText, targetLang)} className="p-4 bg-indigo-600 rounded-full text-white shadow-lg"><Icons.Volume2 className="w-8 h-8"/></button>
                            </div>
                        </div>
                    )}

                    {/* History Modal */}
                    {showHistory && (
                        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex justify-end" onClick={() => setShowHistory(false)}>
                            <div className="bg-white w-full max-w-md h-full shadow-2xl flex flex-col p-4" onClick={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4 border-b pb-2">
                                    <h3 className="font-bold flex gap-2"><Icons.Clock /> Ê≠∑Âè≤</h3>
                                    <button onClick={clearHistory}><Icons.Trash /></button>
                                </div>
                                <div className="flex-1 overflow-y-auto space-y-3">
                                    {history.map(item => (
                                        <div key={item.id} className="bg-slate-50 p-3 rounded-lg text-sm cursor-pointer" onClick={() => { setSourceText(item.src); setTranslatedText(item.res); setShowHistory(false); }}>
                                            <div className="text-slate-500 text-xs mb-1">{item.sLang} ‚Üí {item.tLang}</div>
                                            <div className="font-bold mb-1 line-clamp-2">{item.src}</div>
                                            <div className="text-indigo-600 line-clamp-2">{item.res}</div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* Settings Modal */}
                    {showSettings && (
                        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                            <div className="bg-white rounded-2xl w-full max-w-md p-6 space-y-4 max-h-[90vh] overflow-y-auto">
                                <h3 className="font-bold text-lg flex items-center gap-2"><Icons.Settings /> Ë®≠ÂÆö</h3>
                                
                                {/* Voice Settings Section */}
                                <div className="space-y-3 border-b pb-4">
                                    <h4 className="text-sm font-bold text-slate-600 flex items-center gap-2"><Icons.Volume3 className="w-4 h-4"/> Ë™ûÈü≥Ë®≠ÂÆö</h4>
                                    
                                    <div>
                                        <label className="text-xs text-slate-500 mb-1 block">ÊúóËÆÄË™ûÈü≥ (Voice)</label>
                                        <select 
                                            value={selectedVoiceURI} 
                                            onChange={(e) => setSelectedVoiceURI(e.target.value)}
                                            className="w-full p-2 border rounded-lg text-sm bg-white"
                                        >
                                            <option value="">È†êË®≠ (Default)</option>
                                            {availableVoices.map(v => (
                                                <option key={v.voiceURI} value={v.voiceURI}>{v.name} ({v.lang})</option>
                                            ))}
                                        </select>
                                    </div>

                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="text-xs text-slate-500 mb-1 block">Ë™ûÈÄü (Rate): {voiceRate}x</label>
                                            <input 
                                                type="range" min="0.5" max="2" step="0.1" 
                                                value={voiceRate} 
                                                onChange={(e) => setVoiceRate(parseFloat(e.target.value))}
                                                className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer"
                                            />
                                        </div>
                                        <div>
                                            <label className="text-xs text-slate-500 mb-1 block">Èü≥Ë™ø (Pitch): {voicePitch}</label>
                                            <input 
                                                type="range" min="0.5" max="2" step="0.1" 
                                                value={voicePitch} 
                                                onChange={(e) => setVoicePitch(parseFloat(e.target.value))}
                                                className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer"
                                            />
                                        </div>
                                    </div>
                                </div>

                                <div className="space-y-2">
                                    <label className="text-sm font-bold">ÁøªË≠ØÂºïÊìé</label>
                                    <div className="grid grid-cols-3 gap-2">
                                        <button onClick={() => setApiProvider('gemini')} className={`p-2 border rounded text-sm ${apiProvider==='gemini'?'bg-indigo-50 border-indigo-500 text-indigo-700':''}`}>Gemini</button>
                                        <button onClick={() => setApiProvider('mymemory')} className={`p-2 border rounded text-sm ${apiProvider==='mymemory'?'bg-blue-50 border-blue-500 text-blue-700':''}`}>MyMemory</button>
                                        <button onClick={() => setApiProvider('ollama')} className={`p-2 border rounded text-sm ${apiProvider==='ollama'?'bg-emerald-50 border-emerald-500 text-emerald-700':''}`}>Ollama</button>
                                    </div>
                                </div>
                                
                                {apiProvider === 'gemini' && (
                                    <div className="space-y-3 animate-in fade-in">
                                        <div className="bg-indigo-50 p-4 rounded-xl space-y-2">
                                            <label className="text-xs font-bold text-indigo-600 flex items-center gap-1"><Icons.Key className="w-3 h-3"/> Gemini API Key</label>
                                            <input type="password" value={geminiKey} onChange={e=>setGeminiKey(e.target.value)} className="w-full p-2 border border-indigo-200 rounded-lg font-mono text-sm focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="Ë≤º‰∏äÊÇ®ÁöÑ Key" />
                                            <div className="text-xs text-indigo-600 font-medium flex items-center gap-1 mt-1">
                                                <a href="https://aistudio.google.com/app/apikey" target="_blank" className="underline flex items-center gap-1 hover:text-indigo-800">
                                                    üëâ ÈªûÊ≠§ÂâçÂæÄ Google AI Studio ÂèñÂæóÂÖçË≤ª Key <Icons.Copy className="w-3 h-3 inline"/>
                                                </a>
                                            </div>
                                        </div>
                                        <div className="space-y-1">
                                            <label className="text-xs font-bold text-slate-500 flex items-center gap-1"><Icons.CPU className="w-3 h-3"/> ÈÅ∏ÊìáÊ®°Âûã (Model)</label>
                                            <select 
                                                value={GEMINI_MODELS.some(m => m.id === geminiModel) ? geminiModel : 'custom'} 
                                                onChange={(e) => {
                                                    if (e.target.value === 'custom') setGeminiModel('');
                                                    else setGeminiModel(e.target.value);
                                                }} 
                                                className="w-full p-2 border rounded-lg text-sm bg-white"
                                            >
                                                {GEMINI_MODELS.map(m => <option key={m.id} value={m.id}>{m.name} - {m.desc}</option>)}
                                            </select>
                                            
                                            {(GEMINI_MODELS.every(m => m.id !== geminiModel) || geminiModel === '') && (
                                                <input 
                                                    type="text" 
                                                    value={geminiModel}
                                                    onChange={(e) => setGeminiModel(e.target.value)}
                                                    placeholder="Ëº∏ÂÖ•Ê®°Âûã ID (‰æãÂ¶Ç gemini-3.0-pro)"
                                                    className="mt-2 w-full p-2 border rounded-lg text-sm font-mono bg-slate-50"
                                                />
                                            )}
                                            
                                            <p className="text-xs text-slate-400 mt-1">Ëã•ÈÅáÂà∞ 404 ÈåØË™§ÔºåË´ãÂòóË©¶ÂàáÊèõ‰∏çÂêåÊ®°Âûã„ÄÇ</p>
                                        </div>
                                    </div>
                                )}

                                {apiProvider === 'ollama' && (
                                    <div className="bg-emerald-50 p-4 rounded-xl space-y-2 animate-in fade-in">
                                        <label className="text-xs font-bold text-emerald-600">API URL</label>
                                        <input type="text" value={ollamaUrl} onChange={e=>setOllamaUrl(e.target.value)} className="w-full p-2 border border-emerald-200 rounded-lg font-mono text-sm" />
                                    </div>
                                )}

                                <button onClick={() => setShowSettings(false)} className="w-full bg-slate-900 text-white py-2 rounded-lg shadow-lg hover:bg-slate-800">ÈóúÈñâË®≠ÂÆö</button>
                            </div>
                        </div>
                    )}

                    {/* Header */}
                    <header className="bg-white/90 backdrop-blur-md shadow-sm sticky top-0 z-20 h-16 flex items-center justify-between px-4">
                        <div className="flex items-center gap-2 text-blue-700">
                            <div className="bg-blue-600 text-white p-1.5 rounded-lg"><Icons.Languages className="w-5 h-5" /></div>
                            <h1 className="font-bold text-slate-900">Gemini Âä©Êâã</h1>
                        </div>
                        <div className="flex items-center gap-3">
                            <button onClick={() => setShowHistory(true)} className="p-2 rounded-full text-slate-400 hover:bg-slate-100"><Icons.Clock className="w-6 h-6" /></button>
                            <button onClick={() => setShowSettings(true)} className={`p-2 rounded-full ${!geminiKey&&apiProvider==='gemini'?'text-red-500 animate-pulse':'text-slate-400'}`}><Icons.Settings className="w-6 h-6" /></button>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto px-4 py-6 space-y-4">
                        {/* Mode Switcher */}
                        <div className="grid grid-cols-2 gap-2 bg-white p-1.5 rounded-xl shadow-sm border border-slate-200">
                            <button onClick={() => setMode('text')} className={`py-2 rounded-lg text-xs md:text-sm font-bold flex items-center justify-center gap-1 ${mode==='text'?'bg-blue-50 text-blue-600':'text-slate-500'}`}><Icons.Type className="w-4 h-4"/>‰∏ÄËà¨</button>
                            <button onClick={() => setMode('file')} className={`py-2 rounded-lg text-xs md:text-sm font-bold flex items-center justify-center gap-1 ${mode==='file'?'bg-blue-50 text-blue-600':'text-slate-500'}`}><Icons.FileText className="w-4 h-4"/>Êñá‰ª∂/Áõ∏Ê©ü</button>
                        </div>

                        {/* Task Switcher (New Feature) */}
                        <div className="flex items-center gap-2 overflow-x-auto hide-scrollbar py-1">
                            {TASKS.map(task => (
                                <button 
                                    key={task.id} 
                                    onClick={() => setCurrentTask(task.id)}
                                    className={`flex items-center gap-1 px-4 py-2 rounded-full text-sm font-bold whitespace-nowrap transition-all ${currentTask === task.id ? 'bg-slate-800 text-white shadow-md' : 'bg-white text-slate-500 border border-slate-200 hover:bg-slate-50'}`}
                                >
                                    {task.icon} {task.name}
                                </button>
                            ))}
                        </div>

                        {/* Language Select (Global) */}
                        <div className="flex gap-2 items-center justify-center bg-white p-2 rounded-xl shadow-sm border border-slate-200">
                            <select value={sourceLang} onChange={e=>setSourceLang(e.target.value)} className="bg-transparent w-full text-sm font-bold text-slate-700 text-center outline-none">{LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name.split(' ')[0]}</option>)}</select>
                            <div onClick={()=>{const t=targetLang;setTargetLang(sourceLang);setSourceLang(t)}} className="p-2 rounded-full bg-slate-50 text-slate-400"><Icons.ArrowRightLeft className="w-4 h-4"/></div>
                            <select value={targetLang} onChange={e=>setTargetLang(e.target.value)} className="bg-transparent w-full text-sm font-bold text-slate-700 text-center outline-none">{LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name.split(' ')[0]}</option>)}</select>
                        </div>

                        {errorMsg && <div className="bg-red-50 text-red-600 p-3 rounded-xl text-sm flex items-center gap-2 animate-bounce"><Icons.AlertCircle className="w-4 h-4"/>{errorMsg}</div>}

                        {/* Main Input Area */}
                        <div className="grid md:grid-cols-2 gap-4">
                            {/* Source */}
                            <div className={`bg-white rounded-2xl shadow-sm border flex flex-col h-[300px] md:h-[500px] overflow-hidden relative group ${isListening?'ring-2 ring-red-100 border-red-400':''}`}>
                                <div className="p-3 border-b bg-slate-50/50 flex justify-between items-center">
                                    <div className="flex items-center gap-2">
                                        <button onClick={() => setIsRealTime(!isRealTime)} className={`p-1 rounded ${isRealTime?'bg-yellow-100 text-yellow-600':'text-slate-400'}`} title="Âç≥ÊôÇÁøªË≠Ø"><Icons.Zap className="w-4 h-4"/></button>
                                        <span className="text-xs font-bold text-slate-400 uppercase">ÂéüÊñá {isListening&&<span className="text-red-500 animate-pulse">‚óè</span>}</span>
                                    </div>
                                    <div className="flex gap-1">
                                        <input type="file" ref={cameraInputRef} className="hidden" accept="image/*" onChange={handleFileChange} />
                                        <button onClick={handleScreenCapture} className="p-1.5 rounded hover:bg-slate-100 hidden sm:block" title="Êà™Âúñ"><Icons.Scissors className="w-5 h-5 text-slate-500"/></button>
                                        <button onClick={() => cameraInputRef.current?.click()} className={`p-1.5 rounded-lg ${apiProvider==='gemini'&&geminiKey?'text-blue-600 bg-blue-50 hover:bg-blue-100':'text-slate-500 hover:text-blue-600 hover:bg-blue-50'}`} title={apiProvider==='gemini'?'AI Ë¶ñË¶∫Ëæ®Ë≠ò (Gemini Vision)':'Áõ∏Ê©ü (Tesseract OCR)'}>
                                            {apiProvider==='gemini'&&geminiKey ? <Icons.Eye className="w-5 h-5"/> : <Icons.Camera className="w-5 h-5" />}
                                        </button>
                                        <button onClick={() => toggleListening()} className={`p-1.5 rounded ${isListening?'bg-red-100 text-red-600':'text-slate-500 hover:bg-slate-100'}`}><Icons.Mic className="w-5 h-5"/></button>
                                        {sourceText && <button onClick={clearAll} className="p-1.5 rounded hover:bg-red-50 text-slate-400 hover:text-red-500"><Icons.X className="w-5 h-5"/></button>}
                                    </div>
                                </div>
                                <div className="flex-1 relative">
                                    {mode === 'file' && !sourceText ? (
                                        <div onClick={()=>fileInputRef.current?.click()} className={`absolute inset-3 border-2 border-dashed rounded-xl flex flex-col items-center justify-center cursor-pointer text-slate-400 hover:bg-slate-50 ${isDragOver?'border-blue-500 bg-blue-50':''}`} onDragOver={e=>{e.preventDefault();setIsDragOver(true)}} onDragLeave={e=>{e.preventDefault();setIsDragOver(false)}} onDrop={e=>{e.preventDefault();setIsDragOver(false);processFile(e.dataTransfer.files[0])}}>
                                            <input type="file" ref={fileInputRef} className="hidden" accept=".pdf,.docx,.txt,image/*" onChange={handleFileChange} />
                                            <Icons.UploadCloud className="w-8 h-8 text-blue-300 mb-2" />
                                            <p className="text-sm font-bold">ÊãñÊõ≥Ê™îÊ°àÊàñÂúñÁâá</p>
                                            <p className="text-xs mt-1 opacity-70">
                                                {apiProvider === 'gemini' && geminiKey ? '‚ú® ÊîØÊè¥ Gemini AI Ë¶ñË¶∫Ëæ®Ë≠ò' : 'ÊîØÊè¥ÂúñÁâá OCR, PDF, Word'}
                                            </p>
                                        </div>
                                    ) : (
                                        <textarea value={sourceText} onChange={e=>setSourceText(e.target.value)} className="w-full h-full p-4 resize-none outline-none bg-transparent text-lg" placeholder="Ëº∏ÂÖ•ÊñáÂ≠ó..." />
                                    )}
                                    {fileName && <div className="absolute bottom-2 left-2 px-2 py-1 bg-blue-100 text-blue-700 text-xs rounded flex items-center gap-1"><Icons.FileType className="w-3 h-3"/>{fileName}</div>}
                                </div>
                            </div>

                            {/* Target */}
                            <div className="bg-slate-50 rounded-2xl border border-slate-200 flex flex-col h-[300px] md:h-[500px] overflow-hidden relative">
                                <div className="p-3 border-b bg-slate-100/50 flex justify-between items-center">
                                    <span className="text-xs font-bold text-slate-400 uppercase">ÁµêÊûú ({TASKS.find(t=>t.id===currentTask)?.name})</span>
                                    <div className="flex gap-1">
                                        <button onClick={() => setIsMarkdownMode(!isMarkdownMode)} className={`p-1.5 rounded ${isMarkdownMode?'text-blue-600 bg-blue-50':'text-slate-400'}`} title="Markdown/Á¥îÊñáÂ≠ó ÂàáÊèõ"><Icons.Code className="w-5 h-5"/></button>
                                        {translatedText && <button onClick={() => setShowBigText(true)} className="p-1.5 text-slate-500 hover:text-blue-600 hover:bg-blue-100 rounded" title="ÂÖ®Ëû¢ÂπïÂ±ïÁ§∫"><Icons.Maximize className="w-5 h-5"/></button>}
                                        {displayImage && <button onClick={() => setShowVisualMode(true)} className="p-1.5 text-slate-500 hover:text-blue-600 hover:bg-blue-100 rounded" title="ÂúñÁâáÊ®°Âºè"><Icons.Image className="w-5 h-5"/></button>}
                                        <button onClick={()=>copy(translatedText,false)} className="p-1.5 text-slate-500 hover:text-blue-600 hover:bg-blue-100 rounded"><Icons.Copy className="w-5 h-5"/></button>
                                        <button onClick={()=>speak(translatedText,targetLang)} className="p-1.5 text-slate-500 hover:text-blue-600 hover:bg-blue-100 rounded"><Icons.Volume2 className="w-5 h-5"/></button>
                                    </div>
                                </div>
                                <div className="flex-1 relative">
                                    {isLoading && <div className="absolute inset-0 bg-white/80 backdrop-blur-sm flex flex-col items-center justify-center z-10"><div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-2"></div><span className="text-xs font-bold text-blue-600">{loadingStatus}</span></div>}
                                    {renderResult()}
                                </div>
                            </div>
                        </div>

                        {/* Main Action Button */}
                        <button 
                            onClick={() => callAI(currentTask)} 
                            disabled={isLoading || !sourceText} 
                            className={`w-full py-4 rounded-xl font-bold text-lg shadow-xl active:scale-[0.98] disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 text-white transition-colors ${TASKS.find(t=>t.id===currentTask)?.btnColor}`}
                        >
                            {isLoading ? <Icons.RotateCw className="w-6 h-6 animate-spin"/> : <Icons.Sparkles className="w-6 h-6 text-yellow-300"/>} 
                            {TASKS.find(t=>t.id===currentTask)?.name}
                        </button>
                        
                        <div className="text-center text-xs text-slate-400 opacity-60">¬© 2023 Gemini AI Assistant</div>
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
