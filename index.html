<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini AI 文件助手 (Pro v4.5 Voice)</title>
    
    <!-- Favicon (Logo) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22%232563eb%22 stroke-width=%222%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22><path d=%22m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z%22/></svg>">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    animation: { 
                        'slide-up': 'slideUp 0.3s ease-out forwards', 
                        'fade-out': 'fadeOut 0.3s ease-in forwards',
                        'pop-in': 'popIn 0.2s ease-out forwards',
                        'slide-in-bottom': 'slideInBottom 0.3s ease-out forwards',
                        'wave': 'wave 1.5s infinite'
                    },
                    keyframes: {
                        slideUp: { '0%': { transform: 'translate(-50%, 100%)', opacity: '0' }, '100%': { transform: 'translate(-50%, -1rem)', opacity: '1' } },
                        fadeOut: { '0%': { opacity: '1' }, '100%': { opacity: '0' } },
                        popIn: { '0%': { opacity: '0', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' } },
                        slideInBottom: { '0%': { transform: 'translateY(100%)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } },
                        wave: { '0%, 100%': { transform: 'scaleY(1)' }, '50%': { transform: 'scaleY(0.5)' } }
                    }
                }
            }
        }
    </script>
    
    <!-- KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Fonts & Libs -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- File Processing Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

    <!-- Firebase SDKs (Compat version for easier HTML usage) -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <style>
        body { font-family: 'Zen Maru Gothic', sans-serif; -webkit-tap-highlight-color: transparent; overscroll-behavior-y: none; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 3px; }
        .dark ::-webkit-scrollbar-thumb { background-color: #475569; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .visual-text-box { touch-action: none; backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center; overflow: hidden; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .mermaid { display: flex; justify-content: center; padding: 20px; background: white; border-radius: 10px; overflow-x: auto; }
        .dark .mermaid { background: #1e293b; }
        .prose { max-width: none; }
        .crop-modal { touch-action: none; }
        input[type=range] { accent-color: #2563eb; }

        /* Force dark mode overrides */
        .dark .prose { color: #e2e8f0 !important; }
        .dark .prose h1, .dark .prose h2, .dark .prose h3, .dark .prose h4, .dark .prose h5, .dark .prose h6 { color: #f1f5f9 !important; }
        .dark .prose strong { color: #fcd34d !important; background-color: rgba(255,255,255,0.1); padding: 0 4px; border-radius: 4px; }
        .dark .prose li { color: #e2e8f0 !important; }
        .dark .prose ul > li::marker { color: #94a3b8 !important; }
        .dark .prose ol > li::marker { color: #94a3b8 !important; }
        .dark .prose code { color: #fca5a5 !important; background-color: #1e293b !important; border: 1px solid #334155; }
        .dark .prose a { color: #60a5fa !important; }
        .dark .prose blockquote { color: #cbd5e1 !important; border-left-color: #60a5fa !important; background-color: #1e293b !important; }
        
        /* Chat Input Styling */
        .chat-input { min-height: 40px; max-height: 120px; line-height: 1.5; }
        
        /* Dashed Border Animation */
        .dashed-border {
            background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='8' ry='8' stroke='%23333' stroke-width='2' stroke-dasharray='10%2c 10' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
        }
        
        /* Safe Area for Mobile */
        .safe-area-pb { padding-bottom: env(safe-area-inset-bottom); }

        /* Voice Wave Animation (New) */
        .wave-bar { width: 4px; background: #fff; border-radius: 2px; animation: wave 1s ease-in-out infinite; }
        .wave-bar:nth-child(2) { animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { animation-delay: 0.3s; }
        .wave-bar:nth-child(5) { animation-delay: 0.4s; }
    </style>
</head>
<body class="bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-100 min-h-screen transition-colors duration-300">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        if (typeof mermaid !== 'undefined') mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose', fontFamily: 'Zen Maru Gothic' });

        // --- NEW: Audio Helpers (PCM to WAV) ---
        const pcmToWav = (pcmData, sampleRate = 24000) => {
            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.byteLength, 1);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, 1);
            view.setUint16(20, 1, 1);
            view.setUint16(22, 1, 1);
            view.setUint32(24, sampleRate, 1);
            view.setUint32(28, sampleRate * 2, 1);
            view.setUint16(32, 2, 1);
            view.setUint16(34, 16, 1);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.byteLength, 1);
            new Uint8Array(buffer).set(new Uint8Array(pcmData), 44);
            return buffer;
        };
        const base64ToArrayBuffer = (base64) => {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
            return bytes.buffer;
        };

        // --- User's Pre-configured Firebase Settings (Locked) ---
        const DEFAULT_FIREBASE_CONFIG = {
          "apiKey": "AIzaSyAwbquRwB2p_2zXXHYo_Vzk_EDPYyOSeKY",
          "authDomain": "aitools-40017.firebaseapp.com",
          "databaseURL": "https://aitools-40017-default-rtdb.firebaseio.com",
          "projectId": "aitools-40017",
          "storageBucket": "aitools-40017.appspot.com",
          "messagingSenderId": "aitools712238",
          "appId": "aitools712238"
        };

        // --- Global Helper Functions ---
        const loadPdfWithPassword = (data) => {
            const loadingTask = window.pdfjsLib.getDocument({ data });
            loadingTask.onPassword = (updatePassword, reason) => {
                let msg = '此 PDF 受密碼保護，請輸入密碼：';
                if (reason === window.pdfjsLib.PasswordResponses.INCORRECT_PASSWORD) msg = '密碼錯誤，請重新輸入：';
                const password = prompt(msg);
                if (password) updatePassword(password); else loadingTask.destroy();
            };
            return loadingTask.promise;
        };

        const compressImage = (file) => new Promise((resolve, reject) => {
            const r = new FileReader(); r.readAsDataURL(file);
            r.onload = e => {
                const img = new Image(); img.src = e.target.result;
                img.onload = () => {
                    const c = document.createElement('canvas');
                    let w=img.width, h=img.height, m=1500;
                    if(w>h && w>m){h*=m/w;w=m;} else if(h>m){w*=m/h;h=m;}
                    c.width=w; c.height=h; c.getContext('2d').drawImage(img,0,0,w,h);
                    resolve(c.toDataURL('image/jpeg',0.8).split(',')[1]);
                };
                img.onerror = reject;
            };
            r.onerror = reject;
        });

        const renderPdfToImages = async (ab) => {
            const pdf = await loadPdfWithPassword(ab);
            const imgs = [];
            const count = Math.min(pdf.numPages, 5); 
            for(let i=1;i<=count;i++){
                const p = await pdf.getPage(i);
                const v = p.getViewport({scale:1.5});
                const c = document.createElement('canvas'); c.width=v.width; c.height=v.height;
                await p.render({canvasContext:c.getContext('2d'),viewport:v}).promise;
                imgs.push(c.toDataURL('image/jpeg',0.8).split(',')[1]);
            }
            return imgs;
        };

        // Optimized fetchWithRetry handling cancellations and abort signals
        const fetchWithRetry = async (url, options, retries = 3, delay = 1000, onRetry) => {
            try {
                if (options.signal && options.signal.aborted) throw new Error("Request cancelled");
                
                const res = await fetch(url, options);
                
                if (res.status === 429) {
                    if (retries > 0) {
                        if(onRetry) onRetry(delay / 1000);
                        // Wait with abort check
                        await new Promise((resolve, reject) => {
                            const timer = setTimeout(resolve, delay);
                            if (options.signal) {
                                options.signal.addEventListener('abort', () => {
                                    clearTimeout(timer);
                                    reject(new Error("Request cancelled"));
                                });
                            }
                        });
                        // Exponential backoff capped at 8s
                        return fetchWithRetry(url, options, retries - 1, Math.min(delay * 2, 8000), onRetry);
                    }
                    throw new Error("429_TOO_MANY_REQUESTS");
                }
                
                return await res.json().then(data => ({ status: res.status, ok: res.ok, data }));
            } catch (e) {
                if (e.message === "Request cancelled") throw e;
                if (retries > 0) {
                    if(onRetry) onRetry(delay / 1000);
                    await new Promise((resolve, reject) => {
                        const timer = setTimeout(resolve, delay);
                        if (options.signal) {
                            options.signal.addEventListener('abort', () => {
                                clearTimeout(timer);
                                reject(new Error("Request cancelled"));
                            });
                        }
                    });
                    return fetchWithRetry(url, options, retries - 1, delay * 1.5, onRetry);
                }
                throw e;
            }
        };

        // --- Components ---
        const SafeMarkdown = ({ content, fontSize, isUser }) => {
            const [html, setHtml] = useState('');
            const containerRef = useRef(null);
            useEffect(() => {
                try {
                    if (typeof marked === 'function') setHtml(marked(content));
                    else if (typeof marked !== 'undefined' && typeof marked.parse === 'function') setHtml(marked.parse(content));
                    else setHtml(content);
                } catch (e) { setHtml(content); }
            }, [content]);
            useEffect(() => {
                if(containerRef.current && typeof renderMathInElement === 'function') {
                    try { renderMathInElement(containerRef.current, { delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}, {left: "\\(", right: "\\)", display: false}, {left: "\\[", right: "\\]", display: true}], throwOnError: false }); } catch(e) { console.error("KaTeX render error", e); }
                }
            }, [html]);
            const userClasses = "text-white [&_*]:text-white";
            const aiClasses = "prose prose-sm dark:prose-invert max-w-none leading-relaxed [&_img]:max-h-[500px] [&_img]:rounded-lg [&_img]:shadow-lg";
            return <div ref={containerRef} className={isUser ? userClasses : aiClasses} style={{ fontSize: `${fontSize}px` }} dangerouslySetInnerHTML={{__html: html}} />;
        };

        const MermaidDiagram = ({code, darkMode}) => {
            const [svg, setSvg] = useState('');
            const [err, setErr] = useState(null);
            useEffect(() => {
                setSvg(''); setErr(null);
                if(code && typeof mermaid !== 'undefined') {
                    const id = `mermaid-${Date.now()}`;
                    const run = async () => {
                        try {
                            mermaid.initialize({startOnLoad:true, theme:darkMode?'dark':'default', securityLevel:'loose', fontFamily:'Zen Maru Gothic', darkMode});
                            const {svg} = await mermaid.render(id, code);
                            setSvg(svg);
                        } catch(e) { console.error(e); setErr('無法繪製圖表'); const el=document.getElementById(id); if(el)el.remove(); }
                    };
                    setTimeout(run, 100);
                }
            }, [code, darkMode]);
            if(err) return <div className="text-red-500 text-sm p-4 bg-red-50 rounded">{err}<br/><span className="text-xs text-gray-500">Code: {code.substring(0,50)}...</span></div>;
            return <div className="w-full overflow-x-auto flex justify-center bg-white dark:bg-slate-800 p-4 rounded-lg" dangerouslySetInnerHTML={{__html:svg}}/>;
        };

        const Icon = ({ children, className = "w-6 h-6" }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>;
        const Icons = {
            Languages: () => <Icon><path d="m5 8 6 6"/><path d="m4 14 6-6 2-3"/><path d="M2 5h12"/><path d="M7 2h1"/><path d="m22 22-5-10-5 10"/><path d="M14 18h6"/></Icon>,
            FileText: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></Icon>,
            Type: () => <Icon><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></Icon>,
            UploadCloud: () => <Icon><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></Icon>,
            ArrowRightLeft: () => <Icon><path d="m16 3 4 4-4 4"/><path d="M20 7H4"/><path d="m8 21-4-4 4-4"/><path d="M4 17h16"/></Icon>,
            ArrowLeft: () => <Icon><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></Icon>,
            Copy: () => <Icon><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></Icon>,
            Paste: () => <Icon><rect width="8" height="4" x="8" y="2" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/></Icon>,
            Check: () => <Icon className="w-4 h-4 text-green-500"><polyline points="20 6 9 17 4 12"/></Icon>,
            Volume2: () => <Icon><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></Icon>,
            X: () => <Icon><path d="M18 6 6 18"/><path d="m6 6 12 12"/></Icon>,
            RotateCw: () => <Icon className="w-5 h-5 animate-spin"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 12"/><path d="M21 3v9h-9"/></Icon>,
            Sparkles: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/></Icon>,
            AlertCircle: () => <Icon><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></Icon>,
            Mic: () => <Icon><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="22"/></Icon>,
            Settings: () => <Icon><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Save: () => <Icon><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></Icon>,
            Camera: () => <Icon><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></Icon>,
            Magic: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H1"/><path d="M19 18v4"/><path d="M21 20h-4"/></Icon>,
            List: () => <Icon><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></Icon>,
            Search: () => <Icon><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></Icon>,
            Eye: () => <Icon><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Clock: () => <Icon><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></Icon>,
            Trash: () => <Icon><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></Icon>,
            Zap: () => <Icon><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></Icon>,
            Scissors: () => <Icon><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></Icon>,
            MessageSquare: () => <Icon><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><line x1="9" y1="10" x2="15" y2="10"/><line x1="12" y1="7" x2="12" y2="13"/></Icon>,
            Maximize: () => <Icon><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></Icon>,
            CPU: () => <Icon><rect width="16" height="16" x="4" y="4" rx="2"/><rect width="6" height="6" x="9" y="9"/><path d="M9 1v3"/><path d="M15 1v3"/><path d="M9 20v3"/><path d="M15 20v3"/><path d="M20 9h3"/><path d="M20 14h3"/><path d="M1 9h3"/><path d="M1 14h3"/></Icon>,
            Image: () => <Icon><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></Icon>,
            Code: () => <Icon><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></Icon>,
            Download: () => <Icon><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></Icon>,
            MessageSquarePlus: () => <Icon><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><line x1="9" y1="10" x2="15" y2="10"/><line x1="12" y1="7" x2="12" y2="13"/></Icon>,
            Book: () => <Icon><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></Icon>,
            Columns: () => <Icon><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="12" y1="3" x2="12" y2="21"/></Icon>,
            Monitor: () => <Icon><rect width="20" height="14" x="2" y="3" rx="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></Icon>,
            FileDown: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m9 15 3 3 3-3"/></Icon>,
            FileUp: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 12v6"/><path d="m9 15 3-3 3 3"/></Icon>,
            Palette: () => <Icon><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></Icon>,
            Scaling: () => <Icon><path d="M16 16l5 5"/><path d="M15 21h6v-6"/><path d="M21 9v-6h-6"/><path d="M21 3l-5 5"/><path d="M3 9v-6h6"/><path d="M3 3l5 5"/><path d="M9 21h-6v-6"/><path d="M3 21l5-5"/></Icon>,
            Moon: () => <Icon><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></Icon>,
            Sun: () => <Icon><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></Icon>,
            Brain: () => <Icon><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"/></Icon>,
            ExternalLink: () => <Icon><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></Icon>,
            Notebook: () => <Icon><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></Icon>,
            Send: () => <Icon><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></Icon>,
            Cloud: () => <Icon><path d="M17.5 19c0-3.037-2.463-5.5-5.5-5.5S6.5 15.963 6.5 19"/><path d="M19 19h.5c1.933 0 3.5-1.567 3.5-3.5S21.433 12 19.5 12c-.22 0-.435.02-.646.06A5.505 5.505 0 0 0 12 7a5.505 5.505 0 0 0-6.854 5.06c-.211-.04-.426-.06-.646-.06C2.567 12 1 13.567 1 15.5S2.567 19 4.5 19h.5"/></Icon>,
            Wifi: () => <Icon><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></Icon>
        };

      
const GEMINI_MODELS = [
    // --- 下一代模型 (Experimental) ---
    // 注意：Gemini 3.0 目前可能僅限部分帳號使用，若失敗請改用 2.5
    {id:'gemini-3-pro-preview', name:'Gemini 3.0 Pro (Exp)'},
    {id:'gemini-3-flash-preview', name:'Gemini 3.0 Flash (Exp)'},
    
    // --- 最新預覽版 (推薦備援) ---
    {id:'gemini-2.5-flash-preview-09-2025', name:'Gemini 2.5 Flash (Preview)'},
    {id:'gemini-2.5-pro', name:'Gemini 2.5 Pro'},
    {id:'gemini-2.0-flash', name:'Gemini 2.0 Flash'},
];

        
        const LANGUAGES = [
            {code:'auto',name:'自動'},
            {code:'zh-TW',name:'繁中'},
            {code:'en',name:'English'},
            {code:'ja',name:'日本語'},
            {code:'ko',name:'韓語'},
            {code:'vi',name:'越南'},
            {code:'th',name:'泰文'},
            {code:'nan',name:'台語'},
            {code:'yue',name:'粵語'},
            {code:'fr',name:'法文'},
            {code:'de',name:'德文'},
            {code:'nl',name:'荷蘭文'}
        ];
        const TASKS = [
            {id:'notes',name:'筆記',icon:<Icons.Notebook/>,btnColor:'bg-teal-600'},
            {id:'translate',name:'翻譯',icon:<Icons.Languages/>,btnColor:'bg-blue-600'},
            {id:'summarize',name:'摘要',icon:<Icons.List/>,btnColor:'bg-orange-500'},
            {id:'polish',name:'潤飾',icon:<Icons.Magic/>,btnColor:'bg-purple-600'},
            {id:'grammar',name:'文法',icon:<Icons.Search/>,btnColor:'bg-emerald-600'},
            {id:'analyze',name:'分析',icon:<Icons.Brain/>,btnColor:'bg-pink-600'},
            {id:'mindmap',name:'心智圖',icon:<Icons.Brain/>,btnColor:'bg-indigo-600'},
            {id:'vision',name:'識圖',icon:<Icons.Eye/>,btnColor:'bg-violet-600'}
        ];
        const TONES = [{id:'standard',name:'標準'},{id:'formal',name:'禮貌'},{id:'casual',name:'輕鬆'},{id:'academic',name:'專業'},{id:'creative',name:'優美'}];
        
        // 更穩定的備援模型
        const FALLBACK_MODEL = 'gemini-1.5-flash';

        const Toast = ({ message, type, onClose }) => {
            useEffect(() => { const timer = setTimeout(onClose, 3000); return () => clearTimeout(timer); }, [onClose]);
           return <div className={`fixed bottom-4 left-1/2 -translate-x-1/2 px-4 py-2 rounded-full shadow-lg text-white text-sm font-bold flex items-center gap-2 z-[9999] animate-slide-up ${type==='success'?'bg-slate-800/90':'bg-red-500/90'}`}>{type==='success'?<Icons.Check className="w-4 h-4 text-green-400"/>:<Icons.AlertCircle className="w-4 h-4 text-white"/>}{message}</div>;

        };

        function App() {
            const [mode, setMode] = useState('text');
            const [currentTask, setCurrentTask] = useState('notes');
            const [sourceText, setSourceText] = useState('');
            const [translatedText, setTranslatedText] = useState('');
            const [sourceLang, setSourceLang] = useState('auto');
            const [targetLang, setTargetLang] = useState('zh-TW');
            const [selectedTone, setSelectedTone] = useState('standard');
            const [isLoading, setIsLoading] = useState(false);
            const [loadingStatus, setLoadingStatus] = useState('');
            const [errorMsg, setErrorMsg] = useState('');
            const [fileName, setFileName] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [showHistory, setShowHistory] = useState(false);
            const [showBigText, setShowBigText] = useState(false);
            const [isRealTime, setIsRealTime] = useState(false);
            const [isMarkdownMode, setIsMarkdownMode] = useState(true);
            const [usePdfVision, setUsePdfVision] = useState(false);
            const [fsSize, setFsSize] = useState(24);
            const [globalFontSize, setGlobalFontSize] = useState(16);
            const [fsWidth, setFsWidth] = useState(1000); 
            const [aiTemperature, setAiTemperature] = useState(0.7);
            const [bilingualMode, setBilingualMode] = useState(false);
            const [darkMode, setDarkMode] = useState(()=>localStorage.getItem('gemini_dark_mode')==='true');
            const [geminiKey, setGeminiKey] = useState(localStorage.getItem('gemini_api_key')||'');
            const [geminiModel, setGeminiModel] = useState(localStorage.getItem('gemini_model')||'gemini-2.5-flash-preview-09-2025');
            const [history, setHistory] = useState(() => { try { return JSON.parse(localStorage.getItem('translate_history') || '[]'); } catch(e) { return []; } });
            const [chatMessages, setChatMessages] = useState([]);
            const [chatInput, setChatInput] = useState('');
            const [showCropModal, setShowCropModal] = useState(false);
            const [cropImageSrc, setCropImageSrc] = useState(null);
            const [cropSelection, setCropSelection] = useState(null);
            const [showVisualMode, setShowVisualMode] = useState(false);
            const [displayImage, setDisplayImage] = useState(null);
            const [visualBox, setVisualBox] = useState({ x: 50, y: 50, w: 300, h: 'auto' });
            const [visualFontSize, setVisualFontSize] = useState(18);
            const [visualDragging, setVisualDragging] = useState(false);
            const [visualResizing, setVisualResizing] = useState(false);
            const [visualStyle, setVisualStyle] = useState({ color: 'white', bg: 'rgba(0,0,0,0.6)' });
            const dragStartRef = useRef(null);
            const isDraggingRef = useRef(false);
            const imageRef = useRef(null);
            const visualContainerRef = useRef(null);
            const visualDragStartRef = useRef(null);
            const visualResizeStartRef = useRef(null);
            const fileInputRef = useRef(null);
            const cameraInputRef = useRef(null);
            const chatFileInputRef = useRef(null); // New ref for chat image upload
            const requestCounter = useRef(0);
            const chatEndRef = useRef(null);
            const [isListening, setIsListening] = useState(false);
            const [selectionMenu, setSelectionMenu] = useState({ visible: false, x: 0, y: 0, text: '' });
            const [activeTab, setActiveTab] = useState('general');
            const [toast, setToast] = useState(null);
            const [availableVoices, setAvailableVoices] = useState([]);
            const [selectedVoiceURI, setSelectedVoiceURI] = useState('');
            const [voiceRate, setVoiceRate] = useState(1);
            const [voicePitch, setVoicePitch] = useState(1);
            const [glossary, setGlossary] = useState(() => { try { return JSON.parse(localStorage.getItem('gemini_glossary') || '[]'); } catch(e) { return []; } });
            const [newGlossaryTerm, setNewGlossaryTerm] = useState('');
            const [newGlossaryTrans, setNewGlossaryTrans] = useState('');
            const [customInstruction, setCustomInstruction] = useState(localStorage.getItem('gemini_custom_instruction') || '');
            const [isDragOver, setIsDragOver] = useState(false);
            const fsContentRef = useRef(null);
            const fsInnerRef = useRef(null);
            const recognitionRef = useRef(null);
            const abortControllerRef = useRef(null);
            
            // --- NEW: IMAGE GEN STATE ---
            const [imageGenState, setImageGenState] = useState({ show: false, prompt: '' });
            
            // --- FIREBASE SYNC STATES ---
            const [firebaseConfigStr, setFirebaseConfigStr] = useState(localStorage.getItem('firebase_config_str') || JSON.stringify(DEFAULT_FIREBASE_CONFIG, null, 2));
            const [syncId, setSyncId] = useState(localStorage.getItem('sync_id') || '');
            const [isSyncing, setIsSyncing] = useState(false);
            const [syncStatusMsg, setSyncStatusMsg] = useState('');
            const [isCloudInitialized, setIsCloudInitialized] = useState(false); // SAFETY LOCK
            const dbRef = useRef(null);
            const isRemoteUpdate = useRef(false);

            // --- V5.0 新增: 錄音狀態 ---
            const [isRecording, setIsRecording] = useState(false);
            const [voiceTargetLang, setVoiceTargetLang] = useState('en');
            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);
            const audioContextRef = useRef(null);

            // --- FIREBASE LOGIC ---
            useEffect(() => {
                if (firebaseConfigStr && syncId && typeof firebase !== 'undefined') {
                    try {
                        const config = JSON.parse(firebaseConfigStr);
                        if (!firebase.apps.length) {
                            firebase.initializeApp(config);
                        }
                        const db = firebase.firestore();
                        dbRef.current = db;
                        
                        // Initial Fetch to prevent overwriting cloud data with empty local state
                        db.collection('gemini_sync_data').doc(syncId).get().then((doc) => {
                            if (doc.exists) {
                                const data = doc.data();
                                isRemoteUpdate.current = true;
                                if (data.history) setHistory(data.history);
                                if (data.glossary) setGlossary(data.glossary);
                                if (data.customInstruction) setCustomInstruction(data.customInstruction);
                                showToast("資料已從雲端載入 (初始化)", "success");
                                setTimeout(() => { isRemoteUpdate.current = false; setIsCloudInitialized(true); }, 500); // UNLOCK
                            } else {
                                setIsCloudInitialized(true); // New ID, safe to write
                            }
                        }).catch(e => {
                            console.error("Init fetch failed", e);
                            setIsCloudInitialized(true); // Fallback to allow local usage
                        });

                        // Real-time listener
                        const unsubscribe = db.collection('gemini_sync_data').doc(syncId).onSnapshot((doc) => {
                            setIsSyncing(true);
                            setSyncStatusMsg('已連線');
                            if (doc.exists && isCloudInitialized) { // Only process updates if initialized
                                const data = doc.data();
                                isRemoteUpdate.current = true;
                                if (data.history) setHistory(data.history);
                                if (data.glossary) setGlossary(data.glossary);
                                if (data.customInstruction) setCustomInstruction(data.customInstruction);
                                setTimeout(() => { isRemoteUpdate.current = false; }, 1000);
                            }
                        }, (error) => {
                            console.error("Sync Error:", error);
                            setIsSyncing(false);
                            if (error.code === 'permission-denied') {
                                setSyncStatusMsg('權限不足：請檢查 Firebase Rules');
                            } else if (error.code === 'unavailable') {
                                setSyncStatusMsg('無法連線：請檢查網路或 Firestore 狀態');
                            } else {
                                setSyncStatusMsg('連線失敗：請檢查 Config 或 ID');
                            }
                        });

                        return () => unsubscribe();
                    } catch (e) {
                        console.error("Firebase Init Error", e);
                        setIsSyncing(false);
                        setSyncStatusMsg('設定錯誤：JSON 格式不正確');
                    }
                }
            }, [firebaseConfigStr, syncId]);

            const pushToCloud = useCallback((type, data) => {
                if (dbRef.current && syncId && !isRemoteUpdate.current && isCloudInitialized) {
                    dbRef.current.collection('gemini_sync_data').doc(syncId).set({
                        [type]: data,
                        lastUpdated: new Date().toISOString()
                    }, { merge: true }).catch(err => {
                        console.error("Upload failed", err);
                        if (err.code === 'permission-denied') {
                            showToast("同步失敗：資料庫權限不足", "error");
                        }
                    });
                }
            }, [syncId, isCloudInitialized]);
            
            const testConnection = async () => {
                if (!dbRef.current || !syncId) {
                    showToast("請先輸入完整的 Firebase Config 和 Sync ID", "error");
                    return;
                }
                setIsLoading(true);
                try {
                    await dbRef.current.collection('gemini_sync_data').doc(syncId).set({
                        lastTest: new Date().toISOString()
                    }, { merge: true });
                    showToast("測試成功！寫入權限正常", "success");
                    setSyncStatusMsg("連線正常，可同步");
                } catch (error) {
                    console.error("Test Connection Failed:", error);
                    let msg = "測試失敗";
                    if (error.code === 'permission-denied') msg = "權限不足 (Permission Denied) - 請檢查 Firestore Rules";
                    else if (error.code === 'unavailable') msg = "服務無法使用 - 請確認是否已建立 Firestore 資料庫";
                    else if (error.code === 'invalid-argument') msg = "參數錯誤 - 請檢查 Config 格式";
                    else msg = `連線錯誤: ${error.message}`;
                    
                    showToast(msg, "error");
                    setSyncStatusMsg(msg);
                } finally {
                    setIsLoading(false);
                }
            };

// --- 修改區塊開始：testApiKey ---
const testApiKey = async () => {
    // 解析所有 Keys
    const allKeys = geminiKey.split(/[\n,]+/).map(k => k.trim()).filter(k => k);

    if (allKeys.length === 0) {
        showToast("請先輸入 API Key", "error");
        return;
    }

    const originalStatus = loadingStatus;
    setIsLoading(true);
    setLoadingStatus(`正在驗證 ${allKeys.length} 組 API Key...`);

    try {
        const modelToTest = geminiModel || 'gemini-1.5-flash';
        
        // 只測試第一組，或者你可以寫迴圈測試全部
        // 這裡示範測試第一組即可，因為 runGeminiRequest 會自動輪詢
        const keyToTest = allKeys[0]; 

        const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelToTest}:generateContent?key=${keyToTest}`;
        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: [{ parts: [{ text: "Hello" }] }] })
        });

        const data = await res.json();

        if (!res.ok) {
            let errorMsg = data.error?.message || `HTTP Error: ${res.status}`;
            if (res.status === 400) errorMsg = "無效的 Key";
            else if (res.status === 429) errorMsg = "第一組 Key 額度已滿 (但系統會嘗試其他組)";
            throw new Error(errorMsg);
        }

        showToast(`✅ 驗證成功！已載入 ${allKeys.length} 組 Key`, "success");

    } catch (e) {
        showToast("❌ 驗證失敗: " + e.message, "error");
    } finally {
        setIsLoading(false);
        setLoadingStatus(originalStatus);
    }
};
// --- 修改區塊結束 ---

            // Auto-sync triggers
            useEffect(() => { localStorage.setItem('translate_history', JSON.stringify(history)); pushToCloud('history', history); }, [history, pushToCloud]);
            useEffect(() => { localStorage.setItem('gemini_glossary', JSON.stringify(glossary)); pushToCloud('glossary', glossary); }, [glossary, pushToCloud]);
            useEffect(() => { localStorage.setItem('gemini_custom_instruction', customInstruction); pushToCloud('customInstruction', customInstruction); }, [customInstruction, pushToCloud]);

            // Normal LocalStorage effects
            useEffect(() => { if(darkMode){document.documentElement.classList.add('dark');localStorage.setItem('gemini_dark_mode','true');}else{document.documentElement.classList.remove('dark');localStorage.setItem('gemini_dark_mode','false');} }, [darkMode]);
            useEffect(() => { localStorage.setItem('gemini_api_key', geminiKey); }, [geminiKey]);
            useEffect(() => { localStorage.setItem('gemini_model', geminiModel); }, [geminiModel]);
            useEffect(() => { localStorage.setItem('firebase_config_str', firebaseConfigStr); }, [firebaseConfigStr]);
            useEffect(() => { localStorage.setItem('sync_id', syncId); }, [syncId]);
            useEffect(() => { 
                const getVoices = () => { const v = window.speechSynthesis.getVoices(); setAvailableVoices(v); }; 
                getVoices(); window.speechSynthesis.onvoiceschanged = getVoices; 
            }, []);
            useEffect(() => { chatEndRef.current?.scrollIntoView({behavior:'smooth'}); }, [chatMessages, imageGenState.show]);

            // --- Helper Functions ---
            const addToHistory = (src, res, s, t) => setHistory(prev => [{ id: Date.now(), src, res, s, t, timestamp: new Date().toLocaleString() }, ...prev].slice(0, 50));
            const clearHistory = () => { if(confirm("確定要清除所有歷史紀錄嗎？")) { setHistory([]); } };
            const addGlossaryTerm = () => { if(newGlossaryTerm && newGlossaryTrans) { setGlossary([...glossary, { term: newGlossaryTerm, trans: newGlossaryTrans }]); setNewGlossaryTerm(''); setNewGlossaryTrans(''); } };
            const removeGlossaryTerm = (index) => { const newG = [...glossary]; newG.splice(index, 1); setGlossary(newG); };
            
            const showToast = (msg, type = 'success') => { setToast({ message: msg, type }); };

            const resetApp = () => {
                setSourceText('');
                setTranslatedText('');
                setErrorMsg('');
                setCropImageSrc(null);
                setDisplayImage(null);
                setCropSelection(null);
                setShowCropModal(false);
                setShowVisualMode(false);
                setChatMessages([]);
                setLoadingStatus('');
                setImageGenState({ show: false, prompt: '' });
                if (fileInputRef.current) fileInputRef.current.value = '';
                if (cameraInputRef.current) cameraInputRef.current.value = '';
                if (chatFileInputRef.current) chatFileInputRef.current.value = '';
            };

            const handleClearAll = () => {
                if(confirm("確定要清除所有內容（原文、結果、對話）嗎？")) {
                    resetApp();
                    setFileName(null);
                    showToast("已清除所有內容", "success");
                }
            };
            
            const handleCancelRequest = () => {
                if (abortControllerRef.current) {
                    abortControllerRef.current.abort();
                    abortControllerRef.current = null;
                }
                setIsLoading(false);
                setLoadingStatus('');
                showToast("已取消請求", "success");
            };

          // --- 修改區塊開始：runGeminiRequest ---
const runGeminiRequest = async (payload, preferredModel) => {
    if (abortControllerRef.current) abortControllerRef.current.abort();
    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    // 1. 解析所有 Keys (支援換行或逗號分隔)
    const allKeys = geminiKey.split(/[\n,]+/).map(k => k.trim()).filter(k => k);

    if (allKeys.length === 0) throw new Error("請先輸入 API Key");

    // 內部請求函式 (單次嘗試)
    const executeFetch = async (modelId, key) => {
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${key}`;
        const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            signal
        };
        const res = await fetch(url, options);
        // 如果是 429 (額度滿)，拋出特定錯誤以便外層捕捉換 Key
        if (res.status === 429) throw new Error("429_QUOTA");
        return await res.json().then(data => ({ status: res.status, ok: res.ok, data }));
    };

    // 嘗試所有 Keys 的迴圈邏輯
    const attemptWithKeyRotation = async (modelId) => {
        let lastError = null;

        for (let i = 0; i < allKeys.length; i++) {
            const currentKey = allKeys[i];
            try {
                // 如果不是第一組 Key，顯示切換狀態
                if (i > 0) setLoadingStatus(`Key #${i} 額度已滿，切換至 Key #${i + 1}...`);
                
                return await executeFetch(modelId, currentKey);
            } catch (e) {
                if (e.message === "Request cancelled") throw e;
                if (e.message === "429_QUOTA") {
                    console.warn(`Key ending in ...${currentKey.slice(-4)} exhausted.`);
                    lastError = e;
                    continue; // 嘗試下一組 Key
                }
                throw e; // 其他錯誤 (如 400, 500) 直接拋出
            }
        }
        // 如果所有 Keys 都跑完還是 429
        throw new Error("429_TOO_MANY_REQUESTS"); 
    };

    try {
        // 優先嘗試選定的模型
        let resultWrapper = await attemptWithKeyRotation(preferredModel);
        let resData = resultWrapper.data;

        // 檢查是否有 API 錯誤
        if (resData.error) throw new Error(resData.error.message || "API Error");

        // 如果成功且有內容
        if (resData && resData.candidates && resData.candidates.length > 0) {
            return resData;
        }

        // 如果是 PromptFeedback 被擋
        if (resData.promptFeedback) console.warn("Safety Filter triggered:", resData.promptFeedback);

        // 如果主要模型失敗且不是 Flash 1.5，嘗試備援模型 (Fallback)
        if (preferredModel !== FALLBACK_MODEL) {
            console.log("Primary model empty/failed, trying fallback...");
            setLoadingStatus(`切換至穩定模型 (${FALLBACK_MODEL})...`);
            resultWrapper = await attemptWithKeyRotation(FALLBACK_MODEL);
            if (resultWrapper.data.error) throw new Error(resultWrapper.data.error.message);
            return resultWrapper.data;
        }

        return resData;

    } catch (e) {
        if (e.message === 'Request cancelled') throw new Error("Request cancelled");

        console.error("Gemini Request Failed:", e);

        // 如果所有 Key 都滿了，或是其他錯誤，且還沒試過備援模型
        if (preferredModel !== FALLBACK_MODEL) {
            const errorType = e.message.includes("404") ? "模型不存在" : "連線異常或額度全滿";
            showToast(`${errorType}，嘗試備援模型`, "error");
            setLoadingStatus("啟動備援模型...");
            try {
                const fbWrapper = await attemptWithKeyRotation(FALLBACK_MODEL);
                return fbWrapper.data;
            } catch (fbError) {
                throw fbError; // 備援也失敗，徹底失敗
            }
        }
        throw e;
    }
};
// --- 修改區塊結束 ---

            // --- V5.0 新增: 語音錄製邏輯 ---
            const startRecording = async () => {
                if(!geminiKey) { setShowSettings(true); return; }
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const mediaRecorder = new MediaRecorder(stream);
                    mediaRecorderRef.current = mediaRecorder;
                    audioChunksRef.current = [];
                    mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) audioChunksRef.current.push(e.data); };
                    mediaRecorder.start();
                    setIsRecording(true);
                } catch (err) { showToast("無法存取麥克風: " + err.message, "error"); }
            };

const stopRecordingAndProcess = () => {
                if (!mediaRecorderRef.current) return;
                setIsRecording(false);
                setLoadingStatus('⚡ 極速翻譯中...'); // 更新提示文字
                setIsLoading(true);

                mediaRecorderRef.current.onstop = async () => {
                    const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.readAsDataURL(audioBlob);
                    reader.onloadend = async () => {
                        const base64Audio = reader.result.split(',')[1];
                        try {
                            // 1. 發送請求
                            const asrRes = await runGeminiRequest({
                                contents: [{
                                    parts: [
                                        { text: `Listen to this audio. Translate it naturally to ${voiceTargetLang === 'en' ? 'English' : voiceTargetLang === 'ja' ? 'Japanese' : 'Traditional Chinese'}. Output ONLY the translated text. Do not add explanations.` },
                                        { inline_data: { mime_type: 'audio/webm', data: base64Audio } }
                                    ]
                                }]
                            }, 'gemini-2.5-flash-preview-09-2025'); // <--- 這裡修正了引號

                            const translatedText = asrRes.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

                            if (!translatedText) throw new Error("無法辨識或翻譯");

                            // 2. 顯示結果
                            setChatMessages(prev => [...prev, { role: 'model', text: `🗣️ ${translatedText}` }]);
                            
                            // 3. 直接使用瀏覽器內建朗讀 (零延遲)
                            speak(translatedText, voiceTargetLang);

                        } catch (e) {
                            showToast("處理失敗: " + e.message, "error");
                        } finally {
                            setIsLoading(false);
                        }
                    };
                };
                mediaRecorderRef.current.stop();
                mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());
            };
            
            const handleSmartAction = async (actionType) => {
                if(chatMessages.length === 0 && actionType !== 'image_prompt') {
                    showToast("請先進行對話再使用此功能", "error");
                    return;
                }
                
                setIsLoading(true);
                const currentRequestId = ++requestCounter.current;
                
                let historyStr = '';
                chatMessages.forEach(m => {
                    historyStr += `${m.role === 'user' ? 'User' : 'Model'}: ${m.text}\n`;
                });

                if (actionType === 'summary') {
                    setLoadingStatus('正在整理對話重點...');
                    const prompt = `Based on the following conversation history, please provide a concise summary in Traditional Chinese bullet points. Highlight key takeaways and action items if any.\n\nConversation:\n${historyStr}`;
                    
                    try {
                         const payload = { contents:[{parts:[{text:prompt}]}] };
                         const res = await runGeminiRequest(payload, geminiModel);
                         const summary = res.candidates?.[0]?.content?.parts?.[0]?.text;
                         
                         if(summary) {
                             setChatMessages(prev => [...prev, {role:'model', text: `### 📝 對話重點整理\n\n${summary}`}]);
                         }
                    } catch(e) {
                        if (e.message !== "Request cancelled") showToast("整理失敗: " + e.message, "error");
                    }
                } 
                else if (actionType === 'image_prompt') {
                    setLoadingStatus('正在構思繪圖指令...');
                    let context = historyStr;
                    if (!context && sourceText) context = `Source Text: ${sourceText}`;
                    if (!context) context = "A creative and artistic scene.";

                    const prompt = `Based on the visual concepts discussed in this conversation (or the source text provided), create a detailed image generation prompt (in English, as it works best for image models). The prompt should be descriptive, artistic, and suitable for a high-quality image generator. Output ONLY the prompt text, no intro/outro.\n\nContext:\n${context}`;
                    
                    try {
                         const payload = { contents:[{parts:[{text:prompt}]}] };
                         const res = await runGeminiRequest(payload, geminiModel);
                         const promptText = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                         
                         if(promptText) {
                             setImageGenState({ show: true, prompt: promptText });
                         }
                    } catch(e) {
                        if (e.message !== "Request cancelled") showToast("產生指令失敗: " + e.message, "error");
                    }
                }
                
                setIsLoading(false);
            };
            
            // --- NEW: Handle Image Upload in Chat for Style Analysis ---
            const handleChatImageUpload = async (e) => {
                const file = e.target.files[0];
                if(!file) return;
                
                if(!geminiKey) {
                    showToast("請先在設定中輸入 API Key 才能使用圖片分析功能", "error");
                    return;
                }

                setIsLoading(true);
                setLoadingStatus("正在分析圖片風格...");
                
                try {
                    const b64 = await compressImage(file);
                    
                    let prompt = "";
                    let successTitle = "";
                    
                    // Check if there is text in the input box to combine
                    if (chatInput.trim()) {
                        prompt = `Analyze the artistic style of the provided image. Then, create a detailed image generation prompt in English that depicts the following subject: "${chatInput}". The image must be generated strictly in the analyzed style (colors, brushstrokes, lighting, mood) of the provided image. Output ONLY the prompt text.`;
                        successTitle = "🎨 風格+內容整合完成";
                    } else {
                        // Original Style Analysis
                        prompt = `Analyze the artistic style, color palette, lighting, and composition of this image. Create a detailed image generation prompt in English that would allow an AI to generate a NEW image with this exact same style and aesthetic. Output ONLY the prompt text.`;
                        successTitle = "🎨 風格分析完成";
                    }
                    
                    const payload = {contents:[{parts:[{text: prompt},{inline_data:{mime_type:'image/jpeg',data:b64}}]}]};
                    const res = await runGeminiRequest(payload, geminiModel);
                    const newPrompt = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    
                    const successBody = chatInput.trim() 
                        ? `已將您的描述「${chatInput}」與圖片風格結合。`
                        : `已根據您上傳的圖片提取風格提示詞。`;

                    setChatMessages(prev => [...prev, {
                        role: 'model', 
                        text: `### ${successTitle}\n\n${successBody} 您可以在下方「繪圖工坊」查看或修改，並生成新圖片。`
                    }]);

                    if (newPrompt) {
                        setImageGenState({ show: true, prompt: newPrompt });
                    }
                } catch(e) {
                    if (e.message !== "Request cancelled") showToast("分析圖片失敗: " + e.message, "error");
                } finally {
                    setIsLoading(false);
                    setLoadingStatus('');
                    if(chatFileInputRef.current) chatFileInputRef.current.value = '';
                }
            };

            const handleResultToImageGen = async () => {
                if (!translatedText) {
                    showToast("沒有內容可供繪圖", "error");
                    return;
                }
                setIsLoading(true);
                setLoadingStatus("正在將內容轉換為繪圖提示詞...");
                try {
                    const prompt = `Based on the following text, create a detailed, artistic image generation prompt in English. Output ONLY the prompt text.\n\nText:\n${translatedText.substring(0, 2000)}`;
                    const payload = { contents:[{parts:[{text:prompt}]}] };
                    const res = await runGeminiRequest(payload, geminiModel);
                    const newPrompt = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    
                    setMode('conversation');
                    // Add a context message to chat
                    setChatMessages(prev => [...prev, {role:'model', text: `### 🎨 聯想繪圖模式\n\n已根據您的內容產生初步提示詞，請在下方「繪圖工坊」面板進行確認或修改。`}]);
                    
                    if (newPrompt) {
                        setImageGenState({ show: true, prompt: newPrompt });
                    } else {
                        setImageGenState({ show: true, prompt: translatedText }); 
                    }
                } catch(e) {
                    if (e.message !== "Request cancelled") showToast("轉換失敗: " + e.message, "error");
                    setMode('conversation');
                    setImageGenState({ show: true, prompt: translatedText });
                } finally {
                    setIsLoading(false);
                }
            };

            const callAI = async (promptType, textOverride = null) => {
                const textToUse = textOverride !== null ? textOverride : sourceText;
                if (!textToUse.trim()) return;
                
                const currentRequestId = ++requestCounter.current;
                setIsLoading(true);
                setErrorMsg('');
                if (!isRealTime && textOverride === null) setTranslatedText('');

                // Image Generation Branch - NOW REDIRECTS TO CHAT PANEL
                if (promptType === 'image-gen') {
                    setIsLoading(false);
                    // Switch to chat mode
                    setMode('conversation');
                    // If there is source text, use it as initial prompt
                    if (textToUse) {
                        setImageGenState({ show: true, prompt: textToUse });
                    } else {
                        // Just open empty panel
                        setImageGenState({ show: true, prompt: '' });
                    }
                    return;
                }
                
                // Text Generation Branch
                const tName = LANGUAGES.find(l=>l.code===targetLang)?.name || targetLang;
                const toneInfo = TONES.find(t => t.id === selectedTone)?.name || 'Standard';
                
                const now = new Date().toLocaleString('zh-TW', { timeZone: 'Asia/Taipei' });
                let sys = `Current DateTime: ${now}. Task: ${promptType}. Target: ${tName}. Tone: ${toneInfo}. Input: ${textToUse}.`;
                
                if(promptType==='translate') {
                    if (targetLang === 'nan') {
                        sys = `Current DateTime: ${now}. Translate the following text to Taiwanese Hokkien (台語). You may use Traditional Chinese characters (漢字) or Pe̍h-ōe-jī (POJ) mixed as appropriate for natural Taiwanese reading. Source: Auto. Tone: ${toneInfo}. Output ONLY the translated result in Markdown. Text:\n${textToUse}`;
                    } else if (targetLang === 'yue') {
                        sys = `Current DateTime: ${now}. Translate the following text to Cantonese (粵語). Use Traditional Chinese characters. Source: Auto. Tone: ${toneInfo}. Output ONLY the translated result in Markdown. Text:\n${textToUse}`;
                    } else {
                        sys = `Current DateTime: ${now}. Translate the following text to ${tName}. Source language: Auto. Tone: ${toneInfo}. Output ONLY the translated result in Markdown format. Text to translate:\n${textToUse}`;
                    }
                } else if(promptType==='mindmap') {
                    sys = `Current DateTime: ${now}. Generate a Mind Map for the following text using Mermaid JS syntax (mindmap). Output ONLY the code block starting with \`\`\`mermaid. Do NOT include intro/outro. Use ${tName} for node labels. Text to analyze:\n${textToUse}`;
                } else if (promptType === 'vision') {
                    sys = `Current DateTime: ${now}. The user has provided a description of an image. Please organize this description into a clear, readable Markdown format. Input:\n${textToUse}`;
                }
                
                if(glossary.length>0) sys += `\nGlossary:${JSON.stringify(glossary)}`;
                if(customInstruction) sys += `\nSystem Instruction:${customInstruction}`;

                try {
                    let out = "";
                    if(!geminiKey) { setShowSettings(true); throw new Error("請輸入 API Key"); }
                    
                    const safetySettings = [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                    ];

                    const payload = {
                        contents:[{parts:[{text:sys}]}], 
                        generationConfig:{temperature:aiTemperature},
                        safetySettings: safetySettings
                    };

                    const res = await runGeminiRequest(payload, geminiModel);
                    
                    // Safety check
                    if (res.promptFeedback && res.promptFeedback.blockReason) {
                         throw new Error(`⚠️ 內容被安全系統阻擋 (${res.promptFeedback.blockReason})`);
                    }

                    const candidate = res.candidates?.[0];
                    if (!candidate) {
                        console.error("AI Response Error:", res);
                        throw new Error("No response candidates from AI. (可能原因: 模型負載過高或內容被過濾)");
                    }
                    if (candidate.finishReason !== "STOP" && !candidate.content) {
                        throw new Error(`AI response blocked. Reason: ${candidate.finishReason}`);
                    }
                    
                    out = candidate.content?.parts?.[0]?.text || "Error: Empty content";
                    
                    if(currentRequestId === requestCounter.current) {
                        if(promptType==='mindmap') {
                            let cleaned = out;
                            if(cleaned.includes('```mermaid')) {
                                cleaned = cleaned.split('```mermaid')[1];
                            } else if(cleaned.includes('```')) {
                                cleaned = cleaned.split('```')[1]; 
                            }
                            if(cleaned.includes('```')) {
                                cleaned = cleaned.split('```')[0];
                            }
                            cleaned = cleaned.trim();
                            if (!cleaned.startsWith('mindmap')) {
                                cleaned = 'mindmap\n' + cleaned;
                            } else {
                                const firstLineEnd = cleaned.indexOf('\n');
                                if (firstLineEnd === -1) {
                                    cleaned = cleaned.replace('mindmap', 'mindmap\n');
                                } else {
                                    const firstLine = cleaned.substring(0, firstLineEnd).trim();
                                    if (firstLine !== 'mindmap') {
                                     cleaned = cleaned.replace('mindmap', 'mindmap\n');
                                    }
                                }
                            }
                            setTranslatedText(cleaned);
                        } else {
                            setTranslatedText(out);
                        }
                        if(!out.startsWith('Error') && !out.startsWith('此模式')) addToHistory(textToUse, out, sourceLang, targetLang);
                    }
                } catch(e) { 
                    if(currentRequestId === requestCounter.current) {
                        if (e.message !== "Request cancelled") {
                            setErrorMsg(e.message); 
                            setTranslatedText(`錯誤: ${e.message}\n\n1. 請檢查 API Key 是否正確\n2. 嘗試更換其他模型 (Flash/Pro)\n3. 內容可能涉及敏感話題`);
                        }
                    }
                }
                if(currentRequestId === requestCounter.current) setIsLoading(false);
            };

            const processFile = async (f) => {
                if(!f) return;
                resetApp(); // HARD RESET ON NEW FILE
                
                if (currentTask === 'vision' && !f.type.startsWith('image/')) {
                    showToast("識圖模式僅限上傳圖片", "error");
                    return;
                }

                setFileName(f.name); 
                if(f.type.startsWith('image/')) {
                      const r = new FileReader(); 
                      r.onload = e => { 
                          setTimeout(() => {
                              setCropImageSrc(e.target.result); 
                              setDisplayImage(e.target.result); 
                              setShowCropModal(true); 
                          }, 50);
                      }; 
                      r.readAsDataURL(f);
                      return;
                }
                setMode('text'); setIsLoading(true); setLoadingStatus('讀取中...'); setErrorMsg('');
                try {
                    let text = "";
                    if(f.name.endsWith('.pdf')) {
                        const ab = await f.arrayBuffer();
                        if(usePdfVision && geminiKey) {
                            setLoadingStatus('AI 視覺讀取 PDF...');
                            const imgs = await renderPdfToImages(ab.slice(0));
                            text = await performGeminiOCR_Multi(imgs.images || imgs); 
                        } else {
                            const pdf = await loadPdfWithPassword(ab.slice(0));
                            for(let i=1;i<=pdf.numPages;i++) text += (await (await pdf.getPage(i)).getTextContent()).items.map(s=>s.str).join(' ')+'\n';
                            if((!text || text.length<50) && geminiKey) {
                                setLoadingStatus('文字過少，切換至 AI 視覺讀取...');
                                const imgs = await renderPdfToImages(ab.slice(0));
                                text = await performGeminiOCR_Multi(imgs.images || imgs);
                            }
                        }
                    } else if(f.name.endsWith('.docx')) {
                        text = (await window.mammoth.extractRawText({arrayBuffer:await f.arrayBuffer()})).value;
                    } else {
                        text = await new Promise(r=>{const rd=new FileReader(); rd.onload=e=>r(e.target.result); rd.readAsText(f);});
                    }
                    if(!text.trim()) throw new Error("無法讀取文字");
                    setSourceText(text);
                    callAI(currentTask, text);
                } catch(e) { console.error(e); setErrorMsg(e.message||"讀取失敗"); setIsLoading(false); }
            };
            
            const handleFileChange = (e) => { 
                const f = e.target.files[0]; 
                if(f) processFile(f); 
                e.target.value = ''; 
            };

            const performGeminiOCR = async (file, task) => {
                const b64 = await compressImage(file);
                let promptText = "OCR this image. Output text only.";
                if (task === 'vision') promptText = "請用繁體中文詳細描述這張圖片的內容。如果有文字，請也一併列出。 (Describe this image in detail in Traditional Chinese)";
                
                const payload = {contents:[{parts:[{text: promptText},{inline_data:{mime_type:'image/jpeg',data:b64}}]}]};
                const res = await runGeminiRequest(payload, geminiModel);
                return res.candidates?.[0]?.content?.parts?.[0]?.text || "";
            };

            const performGeminiOCR_Multi = async (imgs) => {
                const parts = [{text:"OCR these pages sequentially. Output text only."}];
                imgs.forEach(b64 => parts.push({inline_data:{mime_type:'image/jpeg',data:b64}}));
                const payload = {contents:[{parts}]};
                const res = await runGeminiRequest(payload, geminiModel);
                return res.candidates?.[0]?.content?.parts?.[0]?.text || "";
            };
            
            const performLegacyOCR = async (file) => {
                 setLoadingStatus('Tesseract 辨識中...');
                 const { data: { text } } = await Tesseract.recognize(file, 'chi_tra+eng');
                 return text;
            };

            const runOCR = async (file) => {
                setShowCropModal(false); 
                setIsLoading(true); 
                setSourceText(''); 
                setErrorMsg('');
                
                try {
                    let text = "";
                    
                    // 1. 檢查是否有 API Key
                    if (geminiKey) {
                        setLoadingStatus('AI 視覺分析中...');
                        text = await performGeminiOCR(file, currentTask); 
                    } else {
                        // 2. 沒有 Key，使用本機 OCR
                        setLoadingStatus('無 API Key，使用本機 OCR 辨識文字...');
                        // 如果當前任務是「識圖 (Vision)」，但沒有 Key，直接報錯提醒
                        if (currentTask === 'vision') {
                            throw new Error("「識圖模式」需要 AI 模型介入，請先至設定輸入 API Key。");
                        }
                        text = await performLegacyOCR(file);
                    }
                    
                    // 3. 檢查結果
                    if (!text || !text.trim()) {
                        if (!geminiKey) {
                            throw new Error("本機辨識找不到文字。若需辨識圖片內容(非文字)，請輸入 API Key。");
                        } else {
                            throw new Error("AI 無法識別此圖片，請嘗試更清晰的圖片。");
                        }
                    }

                    setSourceText(text);
                    callAI(currentTask, text);

                } catch (e) { 
                    if (e.message !== "Request cancelled") {
                        console.error(e); 
                        setErrorMsg(e.message); 
                    }
                    // 如果是 Vision 模式且失敗，自動切回文字模式以免卡住
                    if (currentTask === 'vision' && !geminiKey) {
                        setCurrentTask('notes');
                    }
                } finally {
                    setIsLoading(false);
                }
            };

            const switchToChat = () => {
                setMode('conversation');
                if(translatedText && chatMessages.length===0) setChatMessages([{role:'model', text:`已為您準備好內容。您可以針對剛才的分析結果提問。`}]);
            };

            const sendChat = async () => {
                if(!chatInput.trim())return;
                if(!geminiKey) {
                    setChatMessages(p=>[...p, {role:'user',text:chatInput}, {role:'model',text:"請先在設定中輸入 API Key 才能使用對話功能。"}]);
                    setChatInput('');
                    return;
                }

                const newUserMsg = {role:'user',text:chatInput}; 
                setChatMessages(prev => [...prev, newUserMsg]); 
                setChatInput(''); 
                setIsLoading(true);

                try {
                    const now = new Date().toLocaleString('zh-TW', { timeZone: 'Asia/Taipei' });
                    
                    let historyStr = '';
                    chatMessages.forEach(m => {
                        historyStr += `${m.role === 'user' ? 'User' : 'Model'}: ${m.text}\n`;
                    });

                    let ctx = `Current DateTime: ${now}.\nContext:\nSource:${sourceText}\nResult:${translatedText}`;
                    if(customInstruction) ctx += `\nSystem Instruction:${customInstruction}`;
                    ctx += `\n\nConversation History:\n${historyStr}`;
                    ctx += `User: ${newUserMsg.text}\nModel:`;
                    
                    const safetySettings = [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                    ];

                    const payload = {
                        contents:[{parts:[{text:ctx}]}],
                        safetySettings: safetySettings
                    };

                    const res = await runGeminiRequest(payload, geminiModel);
                    
                    // Safety check
                    if (res.promptFeedback && res.promptFeedback.blockReason) {
                         throw new Error(`⚠️ 內容被安全系統阻擋 (${res.promptFeedback.blockReason})`);
                    }

                    const candidate = res.candidates?.[0];
                    let responseText = "Error";
                    if (!candidate) {
                        responseText = "Error: No response from AI.";
                    } else if (candidate.finishReason !== "STOP" && !candidate.content) {
                        responseText = `Error: Blocked by safety settings (${candidate.finishReason})`;
                    } else {
                        responseText = candidate.content?.parts?.[0]?.text || "Error";
                    }

                    setChatMessages(p=>[...p,{role:'model',text:responseText}]);
                } catch(e) { 
                    if (e.message !== "Request cancelled") {
                        let errMsg = "Error: " + e.message;
                        if (e.message === "429_TOO_MANY_REQUESTS") {
                            errMsg = "系統目前流量過大，請稍後再試。";
                        }
                        setChatMessages(p=>[...p,{role:'model',text:errMsg}]); 
                    }
                }
                setIsLoading(false);
            };

             const getClientCoordinates = (e) => { const r = imageRef.current.getBoundingClientRect(); const c = e.touches?e.touches[0]:e; return {x: c.clientX-r.left, y: c.clientY-r.top}; };
            const handleCropStart = (e) => { const coords = getClientCoordinates(e); setCropSelection({x:coords.x,y:coords.y,w:0,h:0}); isDraggingRef.current=true; dragStartRef.current=coords; };
            const handleCropMove = (e) => { if(!isDraggingRef.current)return; const coords = getClientCoordinates(e); const r = imageRef.current.getBoundingClientRect(); const cx = Math.min(Math.max(0, coords.x), r.width); const cy = Math.min(Math.max(0, coords.y), r.height); setCropSelection({x:Math.min(dragStartRef.current.x,cx),y:Math.min(dragStartRef.current.y,cy),w:Math.abs(cx-dragStartRef.current.x),h:Math.abs(cy-dragStartRef.current.y)}); };
            const handleCropEnd = () => isDraggingRef.current = false;
            const handleFullImageConfirm = async () => { const res = await fetch(cropImageSrc); const blob = await res.blob(); const file = new File([blob], "full.jpg", {type:'image/jpeg'}); runOCR(file); };
            const handleCropConfirm = () => {
                if(!cropSelection) return;
                const img = imageRef.current; const canvas = document.createElement('canvas');
                const scaleX = img.naturalWidth / img.clientWidth; const scaleY = img.naturalHeight / img.clientHeight;
                canvas.width = cropSelection.w * scaleX; canvas.height = cropSelection.h * scaleY;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, cropSelection.x*scaleX, cropSelection.y*scaleY, cropSelection.w*scaleX, cropSelection.h*scaleY, 0, 0, canvas.width, canvas.height);
                canvas.toBlob(blob => { runOCR(new File([blob], "crop.jpg", {type:'image/jpeg'})); }, 'image/jpeg');
            };
            
             const handleVisualDragStart = (e) => {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                visualDragStartRef.current = { x: clientX, y: clientY };
                setVisualDragging(true);
            };
            const handleVisualResizeStart = (e) => {
                e.preventDefault(); e.stopPropagation();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                visualResizeStartRef.current = { startX: clientX, startY: clientY, startW: visualBox.w, startH: typeof visualBox.h === 'number' ? visualBox.h : 200, fontSize: visualFontSize };
                setVisualResizing(true);
            };
            const handleVisualMove = (e) => {
                if (visualDragging && visualDragStartRef.current && visualContainerRef.current) {
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const containerRect = visualContainerRef.current.getBoundingClientRect();
                    const deltaX = ((clientX - visualDragStartRef.current.x) / containerRect.width) * 100;
                    const deltaY = ((clientY - visualDragStartRef.current.y) / containerRect.height) * 100;
                    setVisualBox(prev => ({ ...prev, x: Math.max(0, Math.min(100, prev.x + deltaX)), y: Math.max(0, Math.min(100, prev.y + deltaY)) }));
                    visualDragStartRef.current = { x: clientX, y: clientY };
                } else if (visualResizing && visualResizeStartRef.current) {
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const deltaX = clientX - visualResizeStartRef.current.startX;
                    const deltaY = clientY - visualResizeStartRef.current.startY;
                    const newWidth = Math.max(100, visualResizeStartRef.current.startW + deltaX);
                    const newHeight = Math.max(50, visualResizeStartRef.current.startH + deltaY);
                    const scaleRatio = newWidth / visualResizeStartRef.current.startW;
                    const newFontSize = Math.max(10, Math.min(100, visualResizeStartRef.current.fontSize * scaleRatio));
                    setVisualBox(prev => ({ ...prev, w: newWidth, h: newHeight }));
                    setVisualFontSize(newFontSize);
                }
            };
            const handleVisualEnd = () => { setVisualDragging(false); setVisualResizing(false); visualDragStartRef.current = null; visualResizeStartRef.current = null; };
            const handleSaveVisualImage = async () => {
                if (!visualContainerRef.current) return;
                try {
                    const canvas = await html2canvas(visualContainerRef.current, { useCORS: true, backgroundColor: '#000000' });
                    const link = document.createElement('a'); link.download = `visual_translation_${new Date().getTime()}.png`; link.href = canvas.toDataURL('image/png'); link.click();
                    showToast("圖片已儲存", "success");
                } catch (err) { showToast("儲存失敗", "error"); }
            };
            
            const toggleListening = () => {
                if (isListening) {
                    if (recognitionRef.current) {
                        recognitionRef.current.stop();
                    }
                    setIsListening(false);
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    setErrorMsg("瀏覽器不支援語音辨識");
                    return;
                }

                const recognition = new SpeechRecognition();
                recognitionRef.current = recognition;
                
                let langCode = sourceLang;
                if (langCode === 'auto' || langCode === 'nan' || langCode === 'yue') langCode = 'zh-TW'; 
                
                recognition.lang = langCode;
                recognition.continuous = true;
                recognition.interimResults = true;

                recognition.onstart = () => setIsListening(true);
                recognition.onend = () => setIsListening(false);
                recognition.onerror = (e) => {
                    console.error("Speech recognition error", e);
                    setIsListening(false);
                    showToast("語音辨識錯誤: " + e.error, "error");
                };

                recognition.onresult = (e) => {
                    let final = '';
                    for (let i = e.resultIndex; i < e.results.length; ++i) {
                        if (e.results[i].isFinal) {
                            final += e.results[i][0].transcript;
                        }
                    }
                    
                    if (final) {
                        if (mode === 'conversation') {
                            setChatInput(prev => prev + final);
                        } else {
                            setSourceText(prev => prev + (prev ? ' ' : '') + final);
                        }
                    }
                };

                recognition.start();
            };
            
             const handleSelection = () => { 
                 const selection = window.getSelection(); 
                 const text = selection.toString().trim(); 
                 if (text.length > 0 && (selection.anchorNode.parentElement.tagName === 'TEXTAREA' || selection.anchorNode.parentElement.closest('.prose'))) { 
                     const range = selection.getRangeAt(0); 
                     const rect = range.getBoundingClientRect(); 
                     setSelectionMenu({ visible: true, x: rect.left + window.scrollX + rect.width / 2, y: rect.top + window.scrollY - 10, text: text }); 
                 } else { 
                     setSelectionMenu({ ...selectionMenu, visible: false }); 
                 } 
             };
            
            const handleSelectionAction = async (action) => { 
                setSelectionMenu({ ...selectionMenu, visible: false }); 
                const text = selectionMenu.text; 
                if (action === 'explain') { await callAI('grammar', `Explain: "${text}"`); } 
                else if (action === 'glossary') { setNewGlossaryTerm(text); setShowSettings(true); setActiveTab('data'); } 
                else if (action === 'speak') { speak(text, targetLang); } 
            };
            
            const copy = (t, isS) => { if(!t)return; navigator.clipboard.writeText(t); showToast(isS?"已複製原文":"已複製譯文", 'success'); };
            const speak = (t, l) => { if(!t)return; window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(t); u.lang = LANGUAGES.find(lang => lang.code === l)?.code || l; u.rate = voiceRate; u.pitch = voicePitch; if (selectedVoiceURI) { const v = availableVoices.find(v => v.voiceURI === selectedVoiceURI); if (v) u.voice = v; } window.speechSynthesis.speak(u); };
            
            const handleDownload = () => { 
                if (!translatedText) return; 
                const blob = new Blob([translatedText], { type: 'text/plain' }); 
                const url = window.URL.createObjectURL(blob); 
                const a = document.createElement('a'); 
                a.href = url; 
                a.download = `translation_${new Date().toISOString().slice(0,10)}.md`; 
                document.body.appendChild(a); 
                a.click(); 
                document.body.removeChild(a); 
                window.URL.revokeObjectURL(url); 
            };

            const handleExportData = () => {
                const data = { settings: { geminiKey, geminiModel, customInstruction, voiceRate, voicePitch, fsSize, globalFontSize, aiTemperature, firebaseConfigStr, syncId }, glossary, history, chatMessages };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `gemini_backup_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); window.URL.revokeObjectURL(url);
                showToast("備份已下載", "success");
            };

            const handleImportData = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.settings) {
                            if (data.settings.geminiKey) setGeminiKey(data.settings.geminiKey);
                            if (data.settings.geminiModel) setGeminiModel(data.settings.geminiModel);
                            if (data.settings.customInstruction) setCustomInstruction(data.settings.customInstruction);
                            if (data.settings.voiceRate) setVoiceRate(data.settings.voiceRate);
                            if (data.settings.voicePitch) setVoicePitch(data.settings.voicePitch);
                            if (data.settings.fsSize) setFsSize(data.settings.fsSize);
                            if (data.settings.globalFontSize) setGlobalFontSize(data.settings.globalFontSize);
                            if (data.settings.aiTemperature) setAiTemperature(data.settings.aiTemperature);
                            if (data.settings.firebaseConfigStr) setFirebaseConfigStr(data.settings.firebaseConfigStr);
                            if (data.settings.syncId) setSyncId(data.settings.syncId);
                        }
                        if (data.glossary) setGlossary(data.glossary);
                        if (data.history) setHistory(data.history);
                        if (data.chatMessages) setChatMessages(data.chatMessages);
                        showToast("設定與資料匯入成功！", "success");
                    } catch (err) { showToast("匯入失敗：檔案格式錯誤", "error"); }
                };
                reader.readAsText(file);
            };
            
            const handleScreenCapture = async () => {
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "never" }, audio: false });
                    const video = document.createElement('video'); video.srcObject = stream; await video.play();
                    const canvas = document.createElement('canvas'); canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d'); ctx.drawImage(video, 0, 0);
                    stream.getTracks().forEach(track => track.stop());
                    canvas.toBlob(blob => { const file = new File([blob], "screenshot.png", { type: 'image/png' }); processFile(file); });
                } catch (e) { showToast("截圖取消或失敗", "error"); }
            };
            
            const handleFullScreenDownload = async () => {
                if (!fsInnerRef.current) return; 
                setIsLoading(true);
                setLoadingStatus('正在產生全螢幕截圖...');
                
                try {
                    const element = fsInnerRef.current;
                    const height = element.scrollHeight;
                    let dynamicScale = 4;
                    
                    if (height > 6000) {
                        dynamicScale = 2; // 超長內容使用 2x (確保成功率)
                    } else if (height > 2500) {
                        dynamicScale = 3; // 中長內容使用 3x
                    }
                    // 短內容維持 4x (最高畫質)

                    const canvas = await html2canvas(element, {
                        useCORS: true,
                        backgroundColor: darkMode ? '#0f172a' : '#ffffff',
                        scale: dynamicScale, 
                        logging: false,
                        allowTaint: false,
                        scrollY: -window.scrollY
                    });
                    const link = document.createElement('a');
                    link.download = `fullscreen_capture_${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    showToast(`全螢幕截圖已下載 (${dynamicScale}x 畫質)`, "success");
                } catch (err) {
                    console.error("FS Download Error:", err);
                    showToast("截圖失敗，內容可能過長", "error");
                } finally {
                    setIsLoading(false);
                    setLoadingStatus('');
                }
            };

            const handleScreenshotMsg = async (id) => {
                const element = document.getElementById(id);
                if (!element) return;
                try {
                    const canvas = await html2canvas(element, { useCORS: true, backgroundColor: null, scale: 3 });
                    const link = document.createElement('a');
                    link.download = `chat_capture_${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    showToast("截圖已下載", "success");
                } catch (err) {
                    showToast("截圖失敗", "error");
                }
            };

            const handlePasteClick = async () => {
                try {
                    try {
                        const items = await navigator.clipboard.read();
                        for (const item of items) {
                            if (item.types.some(type => type.startsWith('image/'))) {
                                const type = item.types.find(type => type.startsWith('image/'));
                                const blob = await item.getType(type);
                                const file = new File([blob], "pasted_image.png", { type });
                                processFile(file);
                                showToast("已貼上剪貼簿圖片", "success");
                                return;
                            }
                        }
                    } catch (err) {
                        console.log("Clipboard read() failed or denied, falling back to text.");
                    }

                    const text = await navigator.clipboard.readText();
                    if (text) {
                        if (currentTask === 'vision') {
                             showToast("識圖模式僅限貼上圖片 (Vision mode only accepts images)", "error");
                             return;
                        }
                        setSourceText(prev => prev + text);
                        showToast("已貼上剪貼簿內容", "success");
                    } else {
                        showToast("無法讀取剪貼簿內容", "error");
                    }
                } catch (err) {
                    console.error('Clipboard Error: ', err);
                    showToast("無法讀取剪貼簿，請嘗試使用 Ctrl+V", "error");
                }
            };

            const processFileRef = useRef(processFile);
            useEffect(() => { processFileRef.current = processFile; }, [processFile]);

            useEffect(() => {
                const handleGlobalPaste = (e) => {
                    if (e.clipboardData && e.clipboardData.files.length > 0) {
                        const file = e.clipboardData.files[0];
                        if (file.type.startsWith('image/')) {
                            e.preventDefault();
                            processFileRef.current(file);
                            showToast("已偵測到圖片貼上", "success");
                        }
                    }
                };
                window.addEventListener('paste', handleGlobalPaste);
                return () => window.removeEventListener('paste', handleGlobalPaste);
            }, []);

            useEffect(() => { document.addEventListener('mouseup', handleSelection); document.addEventListener('touchend', handleSelection); return () => { document.removeEventListener('mouseup', handleSelection); document.removeEventListener('touchend', handleSelection); }; }, [selectionMenu]);

            // --- IMAGE GEN FUNCTIONS ---
            const handleRefineImage = async () => {
                if (!imageGenState.prompt) return;
                setIsLoading(true);
                setLoadingStatus('AI 正在優化提示詞...');
                try {
                    const prompt = `Please rewrite and improve the following image generation prompt to be more descriptive, artistic, and detailed. Keep the original intent but enhance the visual description. Output ONLY the improved prompt text.\n\nOriginal Prompt:\n${imageGenState.prompt}`;
                    const payload = { contents:[{parts:[{text:prompt}]}] };
                    const res = await runGeminiRequest(payload, geminiModel);
                    const newPrompt = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    if (newPrompt) {
                        setImageGenState(prev => ({ ...prev, prompt: newPrompt }));
                        showToast("提示詞已優化", "success");
                    }
                } catch(e) {
                    if (e.message !== "Request cancelled") showToast("優化失敗: " + e.message, "error");
                } finally {
                    setIsLoading(false);
                }
            };

            const handleGenerateImageFinal = async () => {
                const textToUse = imageGenState.prompt;
                if (!textToUse) return;
                
                try {
                    await navigator.clipboard.writeText("請幫我畫一張圖: " + textToUse);
                    showToast("提示詞已複製！正在開啟 Gemini...", "success");
                } catch (err) {
                    // Fallback copy
                    const ta = document.createElement('textarea');
                    ta.value = "請幫我畫一張圖: " + textToUse;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    showToast("提示詞已複製！正在開啟 Gemini...", "success");
                }

                setTimeout(() => {
                    window.open("https://gemini.google.com/app", "_blank");
                }, 500);
                
                // Add to chat history so user knows what happened
                setChatMessages(prev => [...prev, {role:'model', text: `### 🎨 外部繪圖已啟動\n\n使用了以下提示詞：\n> ${textToUse}\n\n(已自動複製並開啟 Gemini 網頁)`}]);
                setImageGenState({ show: false, prompt: '' });
            };
            
            // --- NEW: REVERSE IMAGE PROMPT ---
            const handleImageToPrompt = async () => {
                if(!cropImageSrc) return;
                setIsLoading(true);
                setLoadingStatus("正在分析圖片並轉換為繪圖指令...");
                setShowCropModal(false);
                
                try {
                    // Extract base64 without prefix
                    const b64 = cropImageSrc.split(',')[1];
                    const prompt = `Describe this image in detail as an image generation prompt in English. Focus on visual style, colors, composition, and mood. Output ONLY the prompt text.`;
                    const payload = {contents:[{parts:[{text: prompt},{inline_data:{mime_type:'image/jpeg',data:b64}}]}]};
                    const res = await runGeminiRequest(payload, geminiModel);
                    const newPrompt = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    
                    setMode('conversation');
                    setChatMessages(prev => [...prev, {role:'model', text: `### 🎨 圖片轉繪圖指令\n\n已分析您上傳的圖片，並產生對應的 Prompt。您可以修改後再重新生成。`}]);
                    
                    if (newPrompt) {
                        setImageGenState({ show: true, prompt: newPrompt });
                    }
                } catch(e) {
                    if (e.message !== "Request cancelled") showToast("分析失敗: " + e.message, "error");
                } finally {
                    setIsLoading(false);
                }
            };

            return (
                <div className="pb-12 dark:bg-slate-900 min-h-screen transition-colors flex flex-col">
                    {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
                    <header className="bg-white/90 dark:bg-slate-900/90 backdrop-blur shadow-sm border-b dark:border-slate-800 sticky top-0 z-20 h-14 flex items-center justify-between px-4">
                        <div className="flex items-center gap-2 font-bold text-lg text-slate-800 dark:text-white"><Icons.Languages className="text-blue-600"/> Gemini 助手 <span className="text-xs font-normal text-white bg-gradient-to-r from-blue-500 to-purple-500 px-2 py-0.5 rounded-full flex items-center gap-1"><Icons.Cloud className="w-3 h-3"/>Sync</span></div>
                        <div className="flex gap-2">
                            <button onClick={handleClearAll} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800" title="清除所有內容"><Icons.Trash className="text-red-500"/></button>
                            <button onClick={()=>setDarkMode(!darkMode)} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800">{darkMode?<Icons.Sun className="text-yellow-400"/>:<Icons.Moon className="text-slate-600"/>}</button>
                            <button onClick={()=>setShowHistory(true)} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800"><Icons.Clock/></button>
                            <button onClick={()=>setShowSettings(true)} className={`p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 ${isSyncing ? 'text-green-500' : ''}`}><Icons.Settings/></button>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto px-4 py-6 gap-4 flex-1 flex flex-col w-full">
                          <div className="flex flex-col gap-3">
                            {/* --- Modified Mode Switcher with Voice Button --- */}
                            <div className="flex bg-white dark:bg-slate-800 p-1 rounded-lg border dark:border-slate-700 w-full md:w-fit">
                                <button onClick={()=>setMode('text')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='text'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.Type className="w-4 h-4"/>文字</button>
                                <button onClick={()=>setMode('file')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='file'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.FileText className="w-4 h-4"/>文件</button>
                                <button onClick={()=>setMode('conversation')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='conversation'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.MessageSquare className="w-4 h-4"/>對話</button>
                                <button onClick={()=>setMode('voice')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='voice'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.Mic className="w-4 h-4"/>即時語音</button>
                            </div>

                            {/* --- New Voice Mode UI --- */}
{mode === 'voice' && (
    <div className="flex-1 flex flex-col bg-white dark:bg-slate-800 rounded-2xl shadow-xl border dark:border-slate-700 overflow-hidden animate-pop-in h-[60vh] md:h-[600px] w-full">
        
        {/* 1. 【修復】頂部固定標題列 (不再懸浮，保證不消失) */}
        <div className="flex justify-between items-center p-3 bg-slate-100/80 dark:bg-slate-900/80 border-b dark:border-slate-700 shrink-0 backdrop-blur-sm z-30">
            <div className="flex items-center gap-2 text-slate-500 dark:text-slate-400 font-bold text-sm">
                <Icons.Mic className="w-4 h-4"/>
                <span className="hidden md:inline">即時翻譯</span>
            </div>
            <select 
                value={voiceTargetLang} 
                onChange={e=>setVoiceTargetLang(e.target.value)} 
                className="bg-white dark:bg-slate-700 border dark:border-slate-600 rounded-lg px-4 py-2 text-sm font-bold outline-none dark:text-white shadow-sm min-w-[120px]"
            >
                <option value="en">翻譯成英文</option>
                <option value="ja">翻譯成日文</option>
                <option value="zh">翻譯成中文</option>
            </select>
        </div>

        {/* 2. 中間主要內容區 (自動填滿剩餘空間) */}
        <div className="flex-1 relative w-full overflow-hidden flex flex-col bg-slate-50/30 dark:bg-black/20">
            {isLoading ? (
                <div className="flex-1 flex flex-col items-center justify-center gap-4 animate-pulse">
                    <div className="w-16 h-16 rounded-full bg-blue-100 dark:bg-blue-900/50 flex items-center justify-center">
                        <Icons.RotateCw className="w-8 h-8 text-blue-500 animate-spin"/>
                    </div>
                    <p className="text-lg font-bold text-slate-600 dark:text-slate-300">{loadingStatus}</p>
                </div>
            ) : (
                <>
                    {chatMessages.length === 0 ? (
                        <div className="flex-1 flex flex-col items-center justify-center opacity-50 gap-4 p-4 text-center">
                            <div className="w-20 h-20 bg-slate-200 dark:bg-slate-700 rounded-full flex items-center justify-center">
                                <Icons.Mic className="w-10 h-10 text-slate-400"/>
                            </div>
                            <p className="text-slate-500 dark:text-slate-400 text-sm">請按住下方按鈕說話<br/>系統將自動翻譯並朗讀</p>
                        </div>
                    ) : (
                        // 3. 對話列表
                        <div className="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar w-full scroll-smooth">
                            {chatMessages.map((m, i) => (
                                <div key={i} className={`p-4 rounded-2xl text-left shadow-sm max-w-[95%] mx-auto animate-slide-up ${m.role==='model' ? 'bg-white dark:bg-slate-700 border border-blue-100 dark:border-slate-600' : 'bg-blue-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-600 ml-auto'}`}>
                                    <div className="flex items-center gap-2 mb-2 opacity-60 text-xs font-bold uppercase tracking-wider text-slate-500 dark:text-slate-300">
                                        {m.role === 'user' ? '👤 You' : '🤖 AI'}
                                    </div>
                                    
                                    {/* 4. 【修復】強制文字顏色，防止變透明 */}
                                    <div className="text-slate-800 dark:text-slate-100 leading-relaxed break-words text-lg font-medium">
                                         <SafeMarkdown content={m.text} fontSize={globalFontSize} isUser={m.role==='user'}/>
                                    </div>
                                </div>
                            ))}
                            <div ref={chatEndRef} className="h-2"></div>
                        </div>
                    )}
                </>
            )}
        </div>

        {/* 5. 底部按鈕區 (固定高度，確保不被鍵盤或瀏覽器底部遮擋) */}
        <div className="w-full p-4 bg-white dark:bg-slate-800 border-t dark:border-slate-700 flex flex-col items-center gap-2 shrink-0 z-20 pb-8 safe-area-pb shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
            {isRecording && (
                 <div className="flex gap-1 h-6 items-center mb-1">
                    <div className="wave-bar h-3 bg-red-500"></div>
                    <div className="wave-bar h-5 bg-red-500"></div>
                    <div className="wave-bar h-4 bg-red-500"></div>
                    <div className="wave-bar h-6 bg-red-500"></div>
                    <div className="wave-bar h-3 bg-red-500"></div>
                </div>
            )}
            <button 
                onMouseDown={startRecording} 
                onMouseUp={stopRecordingAndProcess}
                onTouchStart={(e) => { e.preventDefault(); startRecording(); }}
                onTouchEnd={(e) => { e.preventDefault(); stopRecordingAndProcess(); }}
                disabled={isLoading}
                className={`w-20 h-20 rounded-full shadow-2xl flex items-center justify-center transition-all duration-200 border-4 select-none touch-none ${
                    isLoading ? 'bg-slate-300 border-slate-200 opacity-50' :
                    isRecording ? 'bg-red-500 border-red-200 scale-110 ring-4 ring-red-200' : 'bg-blue-600 border-blue-100 hover:bg-blue-700 active:scale-95'
                }`}
            >
                <Icons.Mic className="w-9 h-9 text-white" />
            </button>
            <p className={`text-xs font-bold mt-2 uppercase tracking-wider ${isRecording ? 'text-red-500 animate-pulse' : 'text-slate-400'}`}>
                {isRecording ? '放開以結束 (Release)' : '按住說話 (Hold)'}
            </p>
        </div>
    </div>
)}
                            {/* --- Original Text/File Mode UI (Visible when not conversation and not voice) --- */}
                            {mode!=='conversation' && mode!=='voice' && <div className="grid grid-cols-4 md:grid-cols-8 gap-2 bg-white dark:bg-slate-800 p-1 rounded-lg border dark:border-slate-700 w-full">
                                {TASKS.map(t => (
                                    <button 
                                        key={t.id} 
                                        onClick={() => { 
                                            setCurrentTask(t.id); setTranslatedText(''); setErrorMsg(''); 
                                        }} 
                                        className={`px-1 py-2 md:px-3 text-xs md:text-sm font-bold rounded-md flex flex-col md:flex-row items-center justify-center gap-1 md:gap-2 transition-all ${currentTask === t.id && mode !== 'conversation' ? 'bg-slate-800 text-white' : 'text-slate-500 hover:bg-slate-50 dark:hover:bg-slate-700'}`}
                                    >
                                        {t.icon} 
                                        <span>{t.name}</span>
                                    </button>
                                ))}
                            </div>}
                        </div>

                        {mode !== 'conversation' && mode !== 'voice' && (
                            <div className="bg-white dark:bg-slate-800 p-2 rounded-lg border dark:border-slate-700 flex flex-wrap gap-2 items-center justify-between">
                                <div className="flex items-center gap-2 flex-1 min-w-[200px]">
                                    <select value={sourceLang} onChange={(e)=>setSourceLang(e.target.value)} className="p-1.5 rounded-md border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white flex-1">
                                        {LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name}</option>)}
                                    </select>
                                    <button onClick={()=>{const t=targetLang; setTargetLang(sourceLang==='auto'?'en':sourceLang); setSourceLang(t);}} className="p-1.5 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-full text-slate-400"><Icons.ArrowRightLeft className="w-4 h-4"/></button>
                                    <select value={targetLang} onChange={(e)=>setTargetLang(e.target.value)} className="p-1.5 rounded-md border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white flex-1">
                                        {LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name}</option>)}
                                    </select>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-xs text-slate-400 font-bold hidden md:inline">語氣:</span>
                                    <select value={selectedTone} onChange={(e)=>setSelectedTone(e.target.value)} className="p-1.5 rounded-md border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white min-w-[100px]">
                                        {TONES.map(t=><option key={t.id} value={t.id}>{t.name}</option>)}
                                    </select>
                                </div>
                            </div>
                        )}
                        {mode!=='conversation' && mode!=='voice' && <button onClick={()=>callAI(currentTask)} disabled={isLoading||!sourceText} className={`w-full py-3 rounded-xl font-bold text-white shadow transition-all active:scale-[0.99] disabled:opacity-50 ${TASKS.find(t=>t.id===currentTask)?.btnColor}`}>{isLoading?'處理中...':TASKS.find(t=>t.id===currentTask)?.name}</button>}
                        {mode!=='conversation' && mode!=='voice' && (
                            <div className="grid md:grid-cols-2 gap-4 flex-1 min-h-[500px]">
                                <div className="flex flex-col bg-white dark:bg-slate-800 rounded-xl border dark:border-slate-700 overflow-hidden relative">
                                    <div className="px-3 py-2 bg-slate-50 dark:bg-slate-800 border-b dark:border-slate-700 flex justify-between items-center">
                                        <div className="flex items-center gap-2">
                                            <span className="text-xs font-bold text-slate-500">原文</span>
                                            {isListening && <span className="text-xs text-red-500 animate-pulse">● 聽寫中</span>}
                                        </div>
                                        <div className="flex gap-1">
                                            <input type="file" ref={cameraInputRef} className="hidden" accept="image/*" onChange={handleFileChange} />
                                            <button onClick={handlePasteClick} className="p-1 text-slate-400 hover:text-blue-600" title="貼上"><Icons.Paste className="w-4 h-4"/></button>
                                            <button onClick={handleScreenCapture} className="p-1 text-slate-400 hover:text-blue-600" title="截圖"><Icons.Scissors className="w-4 h-4"/></button>
                                            <button onClick={() => cameraInputRef.current?.click()} className="p-1 text-slate-400 hover:text-blue-600" title="上傳圖片/拍照"><Icons.Camera className="w-4 h-4"/></button>
                                            <button onClick={toggleListening} className={`p-1 ${isListening ? 'text-red-500' : 'text-slate-400 hover:text-blue-600'}`} title="語音輸入"><Icons.Mic className="w-4 h-4"/></button>
                                            <button onClick={()=>setSourceText('')} className="p-1 text-slate-400 hover:text-red-500" title="清除"><Icons.X className="w-4 h-4"/></button>
                                        </div>
                                    </div>
                                    <textarea value={sourceText} onChange={e=>setSourceText(e.target.value)} className="flex-1 p-4 bg-transparent outline-none resize-none dark:text-slate-200 text-lg" placeholder={currentTask === 'vision' ? "請上傳或貼上圖片以進行辨識..." : "輸入文字..."} style={{fontSize: `${globalFontSize}px`}}/>
                                    {mode==='file' && !sourceText && <div onClick={()=>fileInputRef.current.click()} className={`absolute inset-0 flex flex-col items-center justify-center bg-slate-50/80 dark:bg-slate-900/80 cursor-pointer border-2 border-dashed m-4 rounded-xl transition-colors ${isDragOver ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-slate-300 dark:border-slate-700'}`} onDragOver={e=>{e.preventDefault();setIsDragOver(true)}} onDragLeave={()=>{setIsDragOver(false)}} onDrop={e=>{e.preventDefault();setIsDragOver(false);processFile(e.dataTransfer.files[0])}}><Icons.UploadCloud className="w-8 h-8 text-blue-400"/><span className="text-sm text-slate-500 mt-2">{currentTask === 'vision' ? '上傳圖片 (Vision Mode Only)' : '上傳文件 / 圖片'}</span><input type="file" ref={fileInputRef} className="hidden" onChange={handleFileChange} accept={currentTask==='vision' ? "image/*" : "*/*"}/></div>}
                                </div>
                                <div className="flex flex-col bg-white dark:bg-slate-800 rounded-xl border dark:border-slate-700 overflow-hidden relative">
                                    <div className="px-3 py-2 bg-slate-50 dark:bg-slate-800 border-b dark:border-slate-700 flex justify-between items-center">
                                        <span className="text-xs font-bold text-slate-500">結果</span>
                                        <div className="flex gap-1">
                                            <button onClick={handleResultToImageGen} className="p-1 text-pink-500 hover:text-pink-600 bg-pink-50 dark:bg-pink-900/30 rounded" title="聯想繪圖 (AI Image Gen)"><Icons.Palette className="w-4 h-4"/></button>
                                            {displayImage && <button onClick={()=>setShowVisualMode(true)} className="p-1 text-slate-400 hover:text-blue-600"><Icons.Image className="w-4 h-4"/></button>}
                                            {currentTask!=='mindmap' && currentTask!=='image-gen' && <button onClick={()=>setIsMarkdownMode(!isMarkdownMode)} className="p-1 text-slate-400 hover:text-blue-600"><Icons.Code className="w-4 h-4"/></button>}
                                            <button onClick={handleDownload} className="p-1 text-slate-400 hover:text-blue-600" title="下載"><Icons.Download className="w-4 h-4"/></button>
                                            <button onClick={()=>copy(translatedText, false)} className="p-1 text-slate-400 hover:text-blue-600" title="複製"><Icons.Copy className="w-4 h-4"/></button>
                                            <button onClick={()=>speak(translatedText, targetLang)} className="p-1 text-slate-400 hover:text-blue-600" title="朗讀"><Icons.Volume2 className="w-4 h-4"/></button>
                                            <button onClick={()=>setShowBigText(true)} className="p-1 text-slate-400 hover:text-blue-600" title="全螢幕"><Icons.Maximize className="w-4 h-4"/></button>
                                        </div>
                                    </div>
                                    <div className="flex-1 overflow-y-auto bg-slate-50/30 dark:bg-slate-900/30 relative">
                                        {isLoading && <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/80 dark:bg-slate-900/80 z-10">
                                            <Icons.RotateCw className="w-8 h-8 text-blue-500 animate-spin mb-2"/>
                                            <span className="text-xs font-bold text-blue-500 mb-2">{loadingStatus}</span>
                                            <button onClick={handleCancelRequest} className="px-3 py-1 bg-red-100 text-red-600 rounded-full text-xs font-bold hover:bg-red-200">取消</button>
                                        </div>}
                                        {currentTask==='mindmap' ? <div className="p-4"><MermaidDiagram code={translatedText} darkMode={darkMode}/></div> : isMarkdownMode ? <div className="p-4"><SafeMarkdown content={translatedText} fontSize={globalFontSize}/></div> : <textarea readOnly value={translatedText} className="w-full h-full p-4 bg-transparent outline-none resize-none text-lg dark:text-slate-200" style={{fontSize: `${globalFontSize}px`}}/>}
                                    </div>
                                    <div className="absolute bottom-3 right-3"><button onClick={switchToChat} className="bg-blue-600 text-white text-xs px-3 py-1.5 rounded-full shadow hover:bg-blue-700 flex items-center gap-1"><Icons.MessageSquare className="w-3 h-3"/> 針對結果對話</button></div>
                                </div>
                            </div>
                        )}

                        {mode === 'conversation' && (
                            <div className="bg-white dark:bg-slate-800 rounded-xl border dark:border-slate-700 flex-1 flex flex-col min-h-[500px] relative overflow-hidden">
                                {/* Header for Chat */}
                                <div className="flex items-center justify-between p-3 border-b dark:border-slate-700 bg-white/50 dark:bg-slate-800/50 backdrop-blur">
                                     <button onClick={() => setMode('text')} className="flex items-center gap-2 text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-700 px-3 py-1.5 rounded-lg transition-colors group">
                                        <Icons.ArrowLeft className="w-4 h-4 group-hover:-translate-x-1 transition-transform"/>
                                        <span className="text-sm font-bold">返回文件</span>
                                     </button>
                                </div>
                                
                                <div className="flex-1 overflow-y-auto p-4 space-y-4 relative">
                                    {chatMessages.map((m,i)=><div key={i} className={`flex ${m.role==='user'?'justify-end':'justify-start'}`}>
                                        <div id={`msg-${i}`} className={`max-w-[85%] p-3 rounded-2xl text-sm flex flex-col gap-1 ${m.role==='user'?'bg-blue-600 text-white':'bg-slate-100 dark:bg-slate-700 dark:text-slate-200'}`}>
                                            <SafeMarkdown content={m.text} fontSize={globalFontSize} isUser={m.role==='user'}/>
                                            {m.role==='model' && (
                                                <div className="flex items-center gap-2 mt-1 self-end">
                                                     <button onClick={() => copy(m.text)} className="text-slate-400 hover:text-blue-500" title="複製"><Icons.Copy className="w-3 h-3" /></button>
                                                     <button onClick={() => handleScreenshotMsg(`msg-${i}`)} className="text-slate-400 hover:text-blue-500" title="截圖"><Icons.Camera className="w-3 h-3" /></button>
                                                     <button onClick={() => speak(m.text, targetLang)} className="text-slate-400 hover:text-blue-500" title="朗讀"><Icons.Volume2 className="w-3 h-3" /></button>
                                                </div>
                                            )}
                                        </div>
                                    </div>)}
                                    <div ref={chatEndRef}/>
                                </div>

                                {/* --- IMAGE GEN PANEL (Discussion Area) --- */}
                                {imageGenState.show && (
                                    <div className="absolute bottom-[130px] left-0 right-0 bg-slate-50 dark:bg-slate-900 border-t dark:border-slate-700 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)] z-20 animate-slide-in-bottom rounded-t-2xl overflow-hidden flex flex-col max-h-[300px]">
                                        <div className="bg-pink-100 dark:bg-pink-900/40 px-4 py-2 flex justify-between items-center border-b border-pink-200 dark:border-pink-800">
                                            <div className="flex items-center gap-2 font-bold text-pink-700 dark:text-pink-300 text-sm">
                                                <Icons.Palette className="w-4 h-4"/> 繪圖工坊 (Image Studio)
                                            </div>
                                            <button onClick={() => setImageGenState({show:false, prompt:''})} className="text-pink-700 dark:text-pink-300 hover:bg-pink-200 dark:hover:bg-pink-800 rounded-full p-1"><Icons.X className="w-4 h-4"/></button>
                                        </div>
                                        <div className="p-3 flex-1 flex flex-col gap-2">
                                            <textarea 
                                                value={imageGenState.prompt}
                                                onChange={e => setImageGenState(prev => ({ ...prev, prompt: e.target.value }))}
                                                className="w-full h-full min-h-[80px] p-3 bg-white dark:bg-slate-800 border dark:border-slate-700 rounded-lg text-sm dark:text-slate-200 resize-none focus:ring-2 focus:ring-pink-500 outline-none"
                                                placeholder="AI 正在構思提示詞，您也可以直接輸入..."
                                            />
                                            <div className="flex gap-2 justify-end">
                                                <button 
                                                    onClick={handleRefineImage} 
                                                    disabled={isLoading || !imageGenState.prompt}
                                                    className="px-3 py-1.5 bg-indigo-100 dark:bg-indigo-900/50 text-indigo-600 dark:text-indigo-300 rounded-lg text-xs font-bold hover:bg-indigo-200 dark:hover:bg-indigo-800 transition-colors flex items-center gap-1"
                                                >
                                                    {isLoading ? <Icons.RotateCw className="w-3 h-3 animate-spin"/> : <Icons.Sparkles className="w-3 h-3"/>}
                                                    AI 優化
                                                </button>
                                                <button 
                                                    onClick={handleGenerateImageFinal}
                                                    disabled={!imageGenState.prompt}
                                                    className="px-4 py-1.5 bg-pink-600 hover:bg-pink-700 text-white rounded-lg text-xs font-bold shadow transition-transform active:scale-95 flex items-center gap-1"
                                                >
                                                    <Icons.Image className="w-3 h-3"/>
                                                    生成圖片 (開啟 Gemini)
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                <div className="border-t dark:border-slate-700 bg-white dark:bg-slate-800 z-30 relative">
                                    {/* Moved Buttons Toolbar */}
                                    <div className="flex items-center gap-2 px-3 py-2 overflow-x-auto hide-scrollbar border-b border-slate-100 dark:border-slate-700/50">
                                        <button onClick={() => handleSmartAction('summary')} className="flex-shrink-0 flex items-center gap-1.5 bg-teal-50 dark:bg-teal-900/30 text-teal-600 dark:text-teal-400 hover:bg-teal-100 dark:hover:bg-teal-900/50 px-3 py-1.5 rounded-lg text-xs font-bold transition-colors">
                                            <Icons.List className="w-3 h-3"/> 整理重點
                                        </button>
                                        <button onClick={() => handleSmartAction('image_prompt')} className="flex-shrink-0 flex items-center gap-1.5 bg-pink-50 dark:bg-pink-900/30 text-pink-600 dark:text-pink-400 hover:bg-pink-100 dark:hover:bg-pink-900/50 px-3 py-1.5 rounded-lg text-xs font-bold transition-colors">
                                            <Icons.Palette className="w-3 h-3"/> 聯想繪圖
                                        </button>
                                        <button onClick={() => setImageGenState(prev => ({...prev, show: !prev.show}))} className={`flex-shrink-0 flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-bold transition-colors ${imageGenState.show ? 'bg-indigo-100 text-indigo-600 dark:bg-indigo-900/50 dark:text-indigo-300' : 'bg-slate-100 text-slate-600 hover:bg-slate-200 dark:bg-slate-700 dark:text-slate-300'}`}>
                                            <Icons.Image className="w-3 h-3"/> 繪圖工坊
                                        </button>
                                    </div>
                                    
                                    {/* Input Area */}
                                    <div className="p-3 flex gap-2 items-center">
                                        <button onClick={() => chatFileInputRef.current?.click()} className="p-2 rounded-full transition-colors bg-slate-100 text-slate-500 hover:bg-slate-200 dark:bg-slate-700 dark:text-slate-300" title="上傳圖片分析風格"><Icons.Image className="w-5 h-5"/></button>
                                        <input type="file" ref={chatFileInputRef} className="hidden" accept="image/*" onChange={handleChatImageUpload} />
                                        
                                        <button onClick={toggleListening} className={`p-2 rounded-full transition-colors ${isListening ? 'bg-red-100 text-red-500' : 'bg-slate-100 text-slate-500 hover:bg-slate-200 dark:bg-slate-700 dark:text-slate-300'}`} title="語音輸入"><Icons.Mic className="w-5 h-5"/></button>
                                        <textarea 
                                            value={chatInput} 
                                            onChange={e=>setChatInput(e.target.value)} 
                                            onKeyDown={e=>{if(e.key==='Enter' && !e.shiftKey){e.preventDefault();sendChat();}}} 
                                            className="flex-1 p-2 bg-slate-50 dark:bg-slate-900 border dark:border-slate-600 rounded-lg outline-none dark:text-white chat-input resize-none hide-scrollbar" 
                                            placeholder="輸入訊息..."
                                        />
                                        <button onClick={isLoading ? handleCancelRequest : sendChat} className={`p-2 ${isLoading ? 'bg-red-500' : 'bg-blue-600'} text-white rounded-lg`}>{isLoading?<Icons.X className="w-5 h-5"/>:<Icons.Send className="w-5 h-5"/>}</button>
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {errorMsg && <div className="text-red-500 text-xs text-center bg-red-50 p-2 rounded">{errorMsg}</div>}
                    </main>
                    
                    {showHistory && (
                        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 animate-in fade-in" onClick={() => setShowHistory(false)}>
                            <div className="bg-white dark:bg-slate-800 w-full max-w-md p-6 rounded-2xl shadow-xl max-h-[80vh] flex flex-col animate-pop-in" onClick={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4 border-b border-slate-100 dark:border-slate-700 pb-3">
                                    <h3 className="font-bold text-lg dark:text-white flex items-center gap-2"><Icons.Clock className="w-5 h-5 text-blue-500"/> 歷史紀錄</h3>
                                    <div className="flex gap-2">
                                        <button onClick={clearHistory} className="text-red-500 text-xs font-bold hover:bg-red-50 dark:hover:bg-red-900/20 px-3 py-1.5 rounded-full transition-colors">清除全部</button>
                                        <button onClick={() => setShowHistory(false)} className="p-1 rounded-full hover:bg-slate-100 dark:hover:bg-slate-700"><Icons.X className="w-5 h-5 text-slate-500" /></button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto space-y-3 pr-1 custom-scrollbar">
                                    {history.length === 0 ? (
                                        <div className="text-center text-slate-400 py-12 flex flex-col items-center">
                                            <Icons.Clock className="w-12 h-12 mb-3 opacity-20"/>
                                            <span>尚無歷史紀錄</span>
                                        </div>
                                    ) : (
                                        history.map(h => (
                                            <div key={h.id} className="group bg-slate-50 dark:bg-slate-900 p-4 rounded-xl border border-slate-100 dark:border-slate-700 cursor-pointer hover:border-blue-300 dark:hover:border-blue-700 hover:shadow-md transition-all" onClick={() => { setSourceText(h.src); setTranslatedText(h.res); setSourceLang(h.s); setTargetLang(h.t); setShowHistory(false); }}>
                                                <div className="flex justify-between text-[10px] uppercase tracking-wider text-slate-400 mb-2">
                                                    <span>{h.timestamp}</span>
                                                    <span className="bg-slate-200 dark:bg-slate-800 px-1.5 py-0.5 rounded text-slate-500 dark:text-slate-400 font-bold">{LANGUAGES.find(l=>l.code===h.s)?.name || h.s} → {LANGUAGES.find(l=>l.code===h.t)?.name || h.t}</span>
                                                </div>
                                                <div className="text-sm text-slate-600 dark:text-slate-300 line-clamp-2 mb-1.5 font-medium">{h.src}</div>
                                                <div className="text-sm text-slate-900 dark:text-slate-100 line-clamp-2 pl-2 border-l-2 border-blue-500">{h.res.substring(0, 100)}...</div>
                                            </div>
                                        ))
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- RE-ADDED MISSING MODALS --- */}
                    {showSettings && (
                        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 animate-in fade-in" onClick={() => setShowSettings(false)}>
                            <div className="bg-white dark:bg-slate-800 w-full max-w-2xl p-6 rounded-2xl shadow-xl max-h-[90vh] flex flex-col animate-pop-in" onClick={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-6 border-b border-slate-100 dark:border-slate-700 pb-4">
                                    <h3 className="font-bold text-xl dark:text-white flex items-center gap-2"><Icons.Settings className="w-6 h-6 text-slate-500"/> 設定</h3>
                                    <button onClick={() => setShowSettings(false)} className="p-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-full transition-colors"><Icons.X className="w-5 h-5 text-slate-500"/></button>
                                </div>
                                <div className="flex gap-4 mb-6 border-b border-slate-100 dark:border-slate-700">
                                    {['general', 'voice', 'sync', 'data'].map(tab => (
                                        <button key={tab} onClick={() => setActiveTab(tab)} className={`pb-2 px-1 text-sm font-bold capitalize transition-colors relative ${activeTab === tab ? 'text-blue-600 dark:text-blue-400' : 'text-slate-400 hover:text-slate-600 dark:hover:text-slate-300'}`}>{tab === 'general' ? '一般' : tab === 'voice' ? '語音' : tab === 'sync' ? '同步' : '資料'}{activeTab === tab && <span className="absolute bottom-0 left-0 w-full h-0.5 bg-blue-600 rounded-full"></span>}</button>
                                    ))}
                                </div>
                                <div className="flex-1 overflow-y-auto space-y-6 pr-2 custom-scrollbar">
                                    {activeTab === 'general' && (
                                        <div className="space-y-4">
                                            <div>
                                                <label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">Gemini API Key</label>
<div className="flex gap-2 items-start">
    <textarea 
        value={geminiKey} 
        onChange={e => setGeminiKey(e.target.value)}
        className="flex-1 p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-xs font-mono outline-none focus:ring-2 focus:ring-blue-500 transition-all dark:text-white resize-none h-20" 
        placeholder="請輸入 API Key (支援多組，一行一組)&#10;Key_1...&#10;Key_2..." 
    />
    <button onClick={testApiKey} disabled={isLoading} className="px-3 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg text-xs font-bold whitespace-nowrap disabled:opacity-50 flex items-center gap-1 h-20 justify-center">
        {isLoading ? <Icons.RotateCw className="w-3 h-3 animate-spin"/> : <Icons.Check className="w-3 h-3"/>}
        驗證 Keys
    </button>
</div>
<div className="mt-1 text-xs text-slate-400">當一組 Key 額度用盡 (429) 時，系統會自動切換至下一行 Key。</div>
                                                <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="mt-1 text-xs text-blue-500 hover:underline block">請至 Google AI Studio 申請 API Key (點此前往)</a>
                                            </div>
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">模型選擇 (Model)</label><select value={geminiModel} onChange={e => setGeminiModel(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white">{GEMINI_MODELS.map(m => <option key={m.id} value={m.id}>{m.name}</option>)}</select></div>
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">自訂指令 (System Instruction)</label><textarea value={customInstruction} onChange={e => setCustomInstruction(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm h-24 resize-none outline-none dark:text-white" placeholder="例如：你是一位專業的翻譯人員，請使用優雅的詞彙..." /></div>
                                            <div className="grid grid-cols-2 gap-4"><div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">字體大小 (結果區)</label><input type="range" min="12" max="32" value={globalFontSize} onChange={e => setGlobalFontSize(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" /><div className="text-right text-xs text-slate-400">{globalFontSize}px</div></div><div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">創意程度 (Temperature)</label><input type="range" min="0" max="1" step="0.1" value={aiTemperature} onChange={e => setAiTemperature(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" /><div className="text-right text-xs text-slate-400">{aiTemperature}</div></div></div>
                                        </div>
                                    )}
                                    {activeTab === 'voice' && (
                                        <div className="space-y-4">
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">語音引擎</label><select value={selectedVoiceURI} onChange={e => setSelectedVoiceURI(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white"><option value="">預設</option>{availableVoices.map(v => <option key={v.voiceURI} value={v.voiceURI}>{v.name} ({v.lang})</option>)}</select></div>
                                            <div className="grid grid-cols-2 gap-4"><div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">語速 (Rate)</label><input type="range" min="0.5" max="2" step="0.1" value={voiceRate} onChange={e => setVoiceRate(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" /><div className="text-right text-xs text-slate-400">{voiceRate}x</div></div><div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">音調 (Pitch)</label><input type="range" min="0.5" max="2" step="0.1" value={voicePitch} onChange={e => setVoicePitch(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" /><div className="text-right text-xs text-slate-400">{voicePitch}</div></div></div>
                                        </div>
                                    )}
                                    {activeTab === 'sync' && (
                                        <div className="space-y-4">
                                            <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg text-sm text-blue-600 dark:text-blue-300"><p className="font-bold mb-1">☁️ Firebase 雲端同步</p><p>設定此功能可讓您在不同裝置間同步歷史紀錄與設定。</p></div>
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">Firebase Config (JSON)</label><textarea value={firebaseConfigStr} onChange={e => setFirebaseConfigStr(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-xs font-mono h-32 resize-none outline-none dark:text-white" placeholder='{"apiKey": "...", ...}' /></div>
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">Sync ID (自訂識別碼)</label><input type="text" value={syncId} onChange={e => setSyncId(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white" placeholder="例如：my-gemini-sync-001" /></div>
                                            <div className="flex justify-between items-center"><span className={`text-xs font-bold ${syncStatusMsg.includes('成功') || syncStatusMsg.includes('已連線') ? 'text-green-500' : 'text-red-500'}`}>{syncStatusMsg}</span><button onClick={testConnection} disabled={isLoading} className="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-bold hover:bg-blue-700 disabled:opacity-50">{isLoading ? '連線中...' : '測試連線'}</button></div>
                                        </div>
                                    )}
                                    {activeTab === 'data' && (
                                        <div className="space-y-6">
                                            <div>
                                                <label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-2">自訂術語表 (Glossary)</label>
                                                <div className="flex gap-2 mb-2"><input type="text" value={newGlossaryTerm} onChange={e => setNewGlossaryTerm(e.target.value)} placeholder="原文 (如: Apple)" className="flex-1 p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white" /><input type="text" value={newGlossaryTrans} onChange={e => setNewGlossaryTrans(e.target.value)} placeholder="譯文 (如: 蘋果)" className="flex-1 p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white" /><button onClick={addGlossaryTerm} className="p-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700"><Icons.Check className="w-4 h-4"/></button></div>
                                                <div className="max-h-40 overflow-y-auto rounded-lg border dark:border-slate-700">{glossary.length === 0 ? <div className="p-4 text-center text-slate-400 text-sm">尚無術語</div> : glossary.map((g, i) => (<div key={i} className="flex justify-between items-center p-2 border-b dark:border-slate-700 last:border-0 hover:bg-slate-50 dark:hover:bg-slate-700/50"><span className="text-sm dark:text-slate-300">{g.term} → {g.trans}</span><button onClick={() => removeGlossaryTerm(i)} className="text-red-400 hover:text-red-500"><Icons.X className="w-3 h-3"/></button></div>))}</div>
                                            </div>
                                            <div className="border-t border-slate-100 dark:border-slate-700 pt-4">
                                                <label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-2">資料管理</label>
                                                <div className="flex gap-2 flex-wrap">
                                                    <button onClick={handleExportData} className="px-4 py-2 bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 rounded-lg text-sm font-bold hover:bg-slate-300 dark:hover:bg-slate-600 flex items-center gap-2"><Icons.Download className="w-4 h-4"/> 備份資料</button>
                                                    <label className="px-4 py-2 bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 rounded-lg text-sm font-bold hover:bg-slate-300 dark:hover:bg-slate-600 flex items-center gap-2 cursor-pointer"><Icons.UploadCloud className="w-4 h-4"/> 匯入備份<input type="file" className="hidden" accept=".json" onChange={handleImportData}/></label>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {showBigText && (
                        <div ref={fsContentRef} className="fixed inset-0 bg-white dark:bg-slate-900 z-[200] flex flex-col animate-in fade-in">
                            <div className="p-4 border-b dark:border-slate-700 flex justify-between items-center bg-slate-50 dark:bg-slate-800">
                                <div className="flex items-center gap-3"><button onClick={()=>setShowBigText(false)} className="p-2 hover:bg-slate-200 dark:hover:bg-slate-700 rounded-full"><Icons.ArrowLeft/></button><span className="font-bold text-lg">全螢幕閱讀</span></div>
                                <div className="flex items-center gap-4"><input type="range" min="16" max="64" value={fsSize} onChange={e=>setFsSize(Number(e.target.value))} className="w-32"/><input type="range" min="600" max="1200" step="100" value={fsWidth} onChange={e=>setFsWidth(Number(e.target.value))} className="w-32 hidden md:block"/><button onClick={handleFullScreenDownload} className="p-2 hover:bg-slate-200 dark:hover:bg-slate-700 rounded-full" title="下載長圖"><Icons.Camera/></button></div>
                            </div>
                            <div className="flex-1 overflow-y-auto p-8 flex justify-center bg-white dark:bg-slate-900">
                                <div ref={fsInnerRef} className="h-fit min-h-full bg-white dark:bg-slate-900 p-8" style={{width: `${fsWidth}px`, maxWidth: '100%'}}><SafeMarkdown content={translatedText} fontSize={fsSize} /></div>
                            </div>
                        </div>
                    )}

                    {showCropModal && (
                        <div className="fixed inset-0 bg-black/80 z-[200] flex flex-col animate-in fade-in crop-modal">
                            <div className="p-4 flex justify-between items-center text-white"><span className="font-bold">裁切圖片 / 選取範圍 (Crop)</span><button onClick={()=>setShowCropModal(false)}><Icons.X className="w-6 h-6"/></button></div>
                            <div className="flex-1 overflow-hidden relative flex items-center justify-center bg-black" onTouchMove={(e)=>e.preventDefault()}>
                                <img ref={imageRef} src={cropImageSrc} className="max-w-full max-h-full object-contain touch-none select-none" onMouseDown={handleCropStart} onMouseMove={handleCropMove} onMouseUp={handleCropEnd} onTouchStart={handleCropStart} onTouchMove={handleCropMove} onTouchEnd={handleCropEnd} alt="Crop Target" draggable="false" />
                                {cropSelection && <div className="absolute border-2 border-blue-500 bg-blue-500/20 pointer-events-none" style={{left:cropSelection.x, top:cropSelection.y, width:cropSelection.w, height:cropSelection.h}}></div>}
                            </div>
                            <div className="p-4 bg-black flex gap-4 justify-center pb-8 safe-area-pb">
                                <button onClick={handleFullImageConfirm} className="px-6 py-3 bg-slate-700 text-white rounded-xl font-bold flex-1">使用原圖</button>
                                <button onClick={handleCropConfirm} disabled={!cropSelection} className="px-6 py-3 bg-blue-600 text-white rounded-xl font-bold flex-1 disabled:opacity-50">確認裁切</button>
                                {currentTask === 'image-gen' && <button onClick={handleImageToPrompt} className="px-6 py-3 bg-pink-600 text-white rounded-xl font-bold flex-1">轉繪圖指令</button>}
                            </div>
                        </div>
                    )}

                    {showVisualMode && displayImage && (
                        <div className="fixed inset-0 bg-black/90 z-[150] flex flex-col animate-in fade-in">
                            <div className="p-4 flex justify-between items-center text-white bg-black/50 backdrop-blur-sm z-10"><span className="font-bold">視覺化模式 (Visual Mode)</span><div className="flex gap-2"><button onClick={handleSaveVisualImage} className="p-2 bg-blue-600 rounded-full"><Icons.Save className="w-5 h-5"/></button><button onClick={()=>setShowVisualMode(false)} className="p-2 hover:bg-white/10 rounded-full"><Icons.X className="w-6 h-6"/></button></div></div>
                            <div ref={visualContainerRef} className="flex-1 relative overflow-hidden flex items-center justify-center bg-black" onTouchMove={(e)=>e.preventDefault()}>
                                <img src={displayImage} className="max-w-full max-h-full object-contain pointer-events-none select-none" alt="Visual Background" />
                                <div className="absolute visual-text-box border-2 border-white/30 rounded-xl" style={{left:`${visualBox.x}%`, top:`${visualBox.y}%`, width: `${visualBox.w}px`, height: `${visualBox.h}px`, backgroundColor: visualStyle.bg}} onMouseDown={handleVisualDragStart} onTouchStart={handleVisualDragStart} onTouchMove={handleVisualMove} onTouchEnd={handleVisualEnd}>
                                    <div className="w-full h-full overflow-y-auto p-4 custom-scrollbar" style={{fontSize: `${visualFontSize}px`, color: visualStyle.color}}><SafeMarkdown content={translatedText} fontSize={visualFontSize}/></div>
                                    <div className="absolute bottom-0 right-0 w-6 h-6 bg-blue-500/50 cursor-se-resize" onMouseDown={handleVisualResizeStart} onTouchStart={handleVisualResizeStart}></div>
                                </div>
                            </div>
                            <div className="p-4 bg-black/80 backdrop-blur-sm flex gap-4 justify-center items-center pb-8 safe-area-pb z-10">
                                <button onClick={()=>setVisualStyle({...visualStyle, color: visualStyle.color==='white'?'black':'white'})} className="w-8 h-8 rounded-full border border-white" style={{background: visualStyle.color==='white'?'black':'white'}}></button>
                                <button onClick={()=>setVisualStyle({...visualStyle, bg: visualStyle.bg==='rgba(0,0,0,0.6)'?'rgba(255,255,255,0.8)':'rgba(0,0,0,0.6)'})} className="w-8 h-8 rounded-full border border-white" style={{background: visualStyle.bg}}></button>
                            </div>
                        </div>
                    )}

                    {selectionMenu.visible && (
                        <div className="fixed bg-slate-800 text-white rounded-lg shadow-xl flex overflow-hidden z-50 animate-pop-in" style={{ left: selectionMenu.x, top: selectionMenu.y, transform: 'translate(-50%, -100%)' }}>
                            <button onClick={()=>handleSelectionAction('explain')} className="px-3 py-2 hover:bg-slate-700 border-r border-slate-700 text-xs font-bold">解釋</button>
                            <button onClick={()=>handleSelectionAction('glossary')} className="px-3 py-2 hover:bg-slate-700 border-r border-slate-700 text-xs font-bold">存術語</button>
                            <button onClick={()=>handleSelectionAction('speak')} className="px-3 py-2 hover:bg-slate-700 text-xs font-bold">朗讀</button>
                        </div>
                    )}

                    <div className="text-center text-xs text-slate-300 mt-8">Gemini AI Assistant • Pro v5.0 (Voice Studio)</div>
                </div>
            );
        }
        
        // Helper needed for crop
// Helper needed for crop
        function dataURItoBlob(dataURI) { 
            const byteString = atob(dataURI.split(',')[1]); 
            const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; 
            const ab = new ArrayBuffer(byteString.length); 
            const ia = new Uint8Array(ab); 
            for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i); 
            return new Blob([ab], {type: mimeString}); 
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />); // 確保這裡是單行且正確閉合
    </script>
</body>
</html>






