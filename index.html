<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini AI æ–‡ä»¶åŠ©æ‰‹ (Pro v4.4 Studio)</title>
    
    <!-- Favicon (Logo) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22%232563eb%22 stroke-width=%222%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22><path d=%22m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z%22/></svg>">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    animation: { 
                        'slide-up': 'slideUp 0.3s ease-out forwards', 
                        'fade-out': 'fadeOut 0.3s ease-in forwards',
                        'pop-in': 'popIn 0.2s ease-out forwards',
                        'slide-in-bottom': 'slideInBottom 0.3s ease-out forwards'
                    },
                    keyframes: {
                        slideUp: { '0%': { transform: 'translate(-50%, 100%)', opacity: '0' }, '100%': { transform: 'translate(-50%, -1rem)', opacity: '1' } },
                        fadeOut: { '0%': { opacity: '1' }, '100%': { opacity: '0' } },
                        popIn: { '0%': { opacity: '0', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' } },
                        slideInBottom: { '0%': { transform: 'translateY(100%)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } }
                    }
                }
            }
        }
    </script>
    
    <!-- KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Fonts & Libs -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- File Processing Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

    <!-- Firebase SDKs (Compat version for easier HTML usage) -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <style>
        body { font-family: 'Zen Maru Gothic', sans-serif; -webkit-tap-highlight-color: transparent; overscroll-behavior-y: none; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 3px; }
        .dark ::-webkit-scrollbar-thumb { background-color: #475569; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .visual-text-box { touch-action: none; backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center; overflow: hidden; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .mermaid { display: flex; justify-content: center; padding: 20px; background: white; border-radius: 10px; overflow-x: auto; }
        .dark .mermaid { background: #1e293b; }
        .prose { max-width: none; }
        .crop-modal { touch-action: none; }
        input[type=range] { accent-color: #2563eb; }

        /* Force dark mode overrides */
        .dark .prose { color: #e2e8f0 !important; }
        .dark .prose h1, .dark .prose h2, .dark .prose h3, .dark .prose h4, .dark .prose h5, .dark .prose h6 { color: #f1f5f9 !important; }
        .dark .prose strong { color: #fcd34d !important; background-color: rgba(255,255,255,0.1); padding: 0 4px; border-radius: 4px; }
        .dark .prose li { color: #e2e8f0 !important; }
        .dark .prose ul > li::marker { color: #94a3b8 !important; }
        .dark .prose ol > li::marker { color: #94a3b8 !important; }
        .dark .prose code { color: #fca5a5 !important; background-color: #1e293b !important; border: 1px solid #334155; }
        .dark .prose a { color: #60a5fa !important; }
        .dark .prose blockquote { color: #cbd5e1 !important; border-left-color: #60a5fa !important; background-color: #1e293b !important; }
        
        /* Chat Input Styling */
        .chat-input { min-height: 40px; max-height: 120px; line-height: 1.5; }
        
        /* Dashed Border Animation */
        .dashed-border {
            background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='8' ry='8' stroke='%23333' stroke-width='2' stroke-dasharray='10%2c 10' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
        }
        
        /* Safe Area for Mobile */
        .safe-area-pb { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body class="bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-100 min-h-screen transition-colors duration-300">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        if (typeof mermaid !== 'undefined') mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose', fontFamily: 'Zen Maru Gothic' });

        // --- User's Pre-configured Firebase Settings (Locked) ---
        const DEFAULT_FIREBASE_CONFIG = {
          "apiKey": "AIzaSyAwbquRwB2p_2zXXHYo_Vzk_EDPYyOSeKY",
          "authDomain": "aitools-40017.firebaseapp.com",
          "databaseURL": "https://aitools-40017-default-rtdb.firebaseio.com",
          "projectId": "aitools-40017",
          "storageBucket": "aitools-40017.appspot.com",
          "messagingSenderId": "aitools712238",
          "appId": "aitools712238"
        };

        // --- Global Helper Functions ---
        const loadPdfWithPassword = (data) => {
            const loadingTask = window.pdfjsLib.getDocument({ data });
            loadingTask.onPassword = (updatePassword, reason) => {
                let msg = 'æ­¤ PDF å—å¯†ç¢¼ä¿è­·ï¼Œè«‹è¼¸å…¥å¯†ç¢¼ï¼š';
                if (reason === window.pdfjsLib.PasswordResponses.INCORRECT_PASSWORD) msg = 'å¯†ç¢¼éŒ¯èª¤ï¼Œè«‹é‡æ–°è¼¸å…¥ï¼š';
                const password = prompt(msg);
                if (password) updatePassword(password); else loadingTask.destroy();
            };
            return loadingTask.promise;
        };

        const compressImage = (file) => new Promise((resolve, reject) => {
            const r = new FileReader(); r.readAsDataURL(file);
            r.onload = e => {
                const img = new Image(); img.src = e.target.result;
                img.onload = () => {
                    const c = document.createElement('canvas');
                    let w=img.width, h=img.height, m=1500;
                    if(w>h && w>m){h*=m/w;w=m;} else if(h>m){w*=m/h;h=m;}
                    c.width=w; c.height=h; c.getContext('2d').drawImage(img,0,0,w,h);
                    resolve(c.toDataURL('image/jpeg',0.8).split(',')[1]);
                };
                img.onerror = reject;
            };
            r.onerror = reject;
        });

        const renderPdfToImages = async (ab) => {
            const pdf = await loadPdfWithPassword(ab);
            const imgs = [];
            const count = Math.min(pdf.numPages, 5); 
            for(let i=1;i<=count;i++){
                const p = await pdf.getPage(i);
                const v = p.getViewport({scale:1.5});
                const c = document.createElement('canvas'); c.width=v.width; c.height=v.height;
                await p.render({canvasContext:c.getContext('2d'),viewport:v}).promise;
                imgs.push(c.toDataURL('image/jpeg',0.8).split(',')[1]);
            }
            return imgs;
        };

        // Optimized fetchWithRetry handling cancellations and abort signals
        const fetchWithRetry = async (url, options, retries = 3, delay = 1000, onRetry) => {
            try {
                if (options.signal && options.signal.aborted) throw new Error("Request cancelled");
                
                const res = await fetch(url, options);
                
                if (res.status === 429) {
                    if (retries > 0) {
                        if(onRetry) onRetry(delay / 1000);
                        // Wait with abort check
                        await new Promise((resolve, reject) => {
                            const timer = setTimeout(resolve, delay);
                            if (options.signal) {
                                options.signal.addEventListener('abort', () => {
                                    clearTimeout(timer);
                                    reject(new Error("Request cancelled"));
                                });
                            }
                        });
                        // Exponential backoff capped at 8s
                        return fetchWithRetry(url, options, retries - 1, Math.min(delay * 2, 8000), onRetry);
                    }
                    throw new Error("429_TOO_MANY_REQUESTS");
                }
                
                return await res.json().then(data => ({ status: res.status, ok: res.ok, data }));
            } catch (e) {
                if (e.message === "Request cancelled") throw e;
                if (retries > 0) {
                    if(onRetry) onRetry(delay / 1000);
                    await new Promise((resolve, reject) => {
                        const timer = setTimeout(resolve, delay);
                        if (options.signal) {
                            options.signal.addEventListener('abort', () => {
                                clearTimeout(timer);
                                reject(new Error("Request cancelled"));
                            });
                        }
                    });
                    return fetchWithRetry(url, options, retries - 1, delay * 1.5, onRetry);
                }
                throw e;
            }
        };

        // --- Components ---
        const SafeMarkdown = ({ content, fontSize, isUser }) => {
            const [html, setHtml] = useState('');
            const containerRef = useRef(null);
            useEffect(() => {
                try {
                    if (typeof marked === 'function') setHtml(marked(content));
                    else if (typeof marked !== 'undefined' && typeof marked.parse === 'function') setHtml(marked.parse(content));
                    else setHtml(content);
                } catch (e) { setHtml(content); }
            }, [content]);
            useEffect(() => {
                if(containerRef.current && typeof renderMathInElement === 'function') {
                    try { renderMathInElement(containerRef.current, { delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}, {left: "\\(", right: "\\)", display: false}, {left: "\\[", right: "\\]", display: true}], throwOnError: false }); } catch(e) { console.error("KaTeX render error", e); }
                }
            }, [html]);
            const userClasses = "text-white [&_*]:text-white";
            const aiClasses = "prose prose-sm dark:prose-invert max-w-none leading-relaxed [&_img]:max-h-[500px] [&_img]:rounded-lg [&_img]:shadow-lg";
            return <div ref={containerRef} className={isUser ? userClasses : aiClasses} style={{ fontSize: `${fontSize}px` }} dangerouslySetInnerHTML={{__html: html}} />;
        };

        const MermaidDiagram = ({code, darkMode}) => {
            const [svg, setSvg] = useState('');
            const [err, setErr] = useState(null);
            useEffect(() => {
                setSvg(''); setErr(null);
                if(code && typeof mermaid !== 'undefined') {
                    const id = `mermaid-${Date.now()}`;
                    const run = async () => {
                        try {
                            mermaid.initialize({startOnLoad:true, theme:darkMode?'dark':'default', securityLevel:'loose', fontFamily:'Zen Maru Gothic', darkMode});
                            const {svg} = await mermaid.render(id, code);
                            setSvg(svg);
                        } catch(e) { console.error(e); setErr('ç„¡æ³•ç¹ªè£½åœ–è¡¨'); const el=document.getElementById(id); if(el)el.remove(); }
                    };
                    setTimeout(run, 100);
                }
            }, [code, darkMode]);
            if(err) return <div className="text-red-500 text-sm p-4 bg-red-50 rounded">{err}<br/><span className="text-xs text-gray-500">Code: {code.substring(0,50)}...</span></div>;
            return <div className="w-full overflow-x-auto flex justify-center bg-white dark:bg-slate-800 p-4 rounded-lg" dangerouslySetInnerHTML={{__html:svg}}/>;
        };

        const Icon = ({ children, className = "w-6 h-6" }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>;
        const Icons = {
            Languages: () => <Icon><path d="m5 8 6 6"/><path d="m4 14 6-6 2-3"/><path d="M2 5h12"/><path d="M7 2h1"/><path d="m22 22-5-10-5 10"/><path d="M14 18h6"/></Icon>,
            FileText: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></Icon>,
            Type: () => <Icon><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></Icon>,
            UploadCloud: () => <Icon><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></Icon>,
            ArrowRightLeft: () => <Icon><path d="m16 3 4 4-4 4"/><path d="M20 7H4"/><path d="m8 21-4-4 4-4"/><path d="M4 17h16"/></Icon>,
            ArrowLeft: () => <Icon><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></Icon>,
            Copy: () => <Icon><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></Icon>,
            Paste: () => <Icon><rect width="8" height="4" x="8" y="2" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/></Icon>,
            Check: () => <Icon className="w-4 h-4 text-green-500"><polyline points="20 6 9 17 4 12"/></Icon>,
            Volume2: () => <Icon><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></Icon>,
            X: () => <Icon><path d="M18 6 6 18"/><path d="m6 6 12 12"/></Icon>,
            RotateCw: () => <Icon className="w-5 h-5 animate-spin"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 12"/><path d="M21 3v9h-9"/></Icon>,
            Sparkles: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/></Icon>,
            AlertCircle: () => <Icon><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></Icon>,
            Mic: () => <Icon><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="22"/></Icon>,
            Settings: () => <Icon><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Save: () => <Icon><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></Icon>,
            Camera: () => <Icon><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></Icon>,
            Magic: () => <Icon><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275-1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H1"/><path d="M19 18v4"/><path d="M21 20h-4"/></Icon>,
            List: () => <Icon><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></Icon>,
            Search: () => <Icon><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></Icon>,
            Eye: () => <Icon><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></Icon>,
            Clock: () => <Icon><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></Icon>,
            Trash: () => <Icon><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></Icon>,
            Zap: () => <Icon><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></Icon>,
            Scissors: () => <Icon><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></Icon>,
            MessageSquare: () => <Icon><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><line x1="9" y1="10" x2="15" y2="10"/><line x1="12" y1="7" x2="12" y2="13"/></Icon>,
            Maximize: () => <Icon><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></Icon>,
            CPU: () => <Icon><rect width="16" height="16" x="4" y="4" rx="2"/><rect width="6" height="6" x="9" y="9"/><path d="M9 1v3"/><path d="M15 1v3"/><path d="M9 20v3"/><path d="M15 20v3"/><path d="M20 9h3"/><path d="M20 14h3"/><path d="M1 9h3"/><path d="M1 14h3"/></Icon>,
            Image: () => <Icon><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></Icon>,
            Code: () => <Icon><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></Icon>,
            Download: () => <Icon><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></Icon>,
            MessageSquarePlus: () => <Icon><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><line x1="9" y1="10" x2="15" y2="10"/><line x1="12" y1="7" x2="12" y2="13"/></Icon>,
            Book: () => <Icon><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></Icon>,
            Columns: () => <Icon><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="12" y1="3" x2="12" y2="21"/></Icon>,
            Monitor: () => <Icon><rect width="20" height="14" x="2" y="3" rx="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></Icon>,
            FileDown: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m9 15 3 3 3-3"/></Icon>,
            FileUp: () => <Icon><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 12v6"/><path d="m9 15 3-3 3 3"/></Icon>,
            Palette: () => <Icon><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></Icon>,
            Scaling: () => <Icon><path d="M16 16l5 5"/><path d="M15 21h6v-6"/><path d="M21 9v-6h-6"/><path d="M21 3l-5 5"/><path d="M3 9v-6h6"/><path d="M3 3l5 5"/><path d="M9 21h-6v-6"/><path d="M3 21l5-5"/></Icon>,
            Moon: () => <Icon><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></Icon>,
            Sun: () => <Icon><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></Icon>,
            Brain: () => <Icon><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"/></Icon>,
            ExternalLink: () => <Icon><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></Icon>,
            Notebook: () => <Icon><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></Icon>,
            Send: () => <Icon><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></Icon>,
            Cloud: () => <Icon><path d="M17.5 19c0-3.037-2.463-5.5-5.5-5.5S6.5 15.963 6.5 19"/><path d="M19 19h.5c1.933 0 3.5-1.567 3.5-3.5S21.433 12 19.5 12c-.22 0-.435.02-.646.06A5.505 5.505 0 0 0 12 7a5.505 5.505 0 0 0-6.854 5.06c-.211-.04-.426-.06-.646-.06C2.567 12 1 13.567 1 15.5S2.567 19 4.5 19h.5"/></Icon>,
            Wifi: () => <Icon><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></Icon>
        };

        const GEMINI_MODELS = [
    // --- ä¸‹ä¸€ä»£æ¨¡å‹ (Experimental) ---
    {id:'gemini-3.0-pro-exp', name:'Gemini 3.0 Pro (Exp)'},
    {id:'gemini-3.0-flash-exp', name:'Gemini 3.0 Flash (Exp)'}, // é å…ˆåŠ å…¥ï¼Œè‹¥ç„¡æ³•ä½¿ç”¨è«‹æ”¹é¸ 2.5 Flash
    
    // --- æœ€æ–°é è¦½ç‰ˆ (æ¨è–¦å‚™æ´) ---
    {id:'gemini-2.5-flash-preview-09-2025', name:'Gemini 2.5 Flash (Preview)'},
    {id:'gemini-2.0-flash-exp', name:'Gemini 2.0 Flash (Exp)'},
    
    // --- ç•¶å‰ç©©å®šç‰ˆ ---
    {id:'gemini-1.5-pro-002', name:'Gemini 1.5 Pro (002)'},
    {id:'gemini-1.5-flash-002', name:'Gemini 1.5 Flash (002)'},
    {id:'gemini-1.5-flash-8b', name:'Gemini 1.5 Flash-8B'},
    
    // --- èˆŠç‰ˆç›¸å®¹ ---
    {id:'gemini-1.5-pro', name:'Gemini 1.5 Pro (Legacy)'},
    {id:'gemini-1.5-flash', name:'Gemini 1.5 Flash (Legacy)'}
        ];
        
        const LANGUAGES = [
            {code:'auto',name:'è‡ªå‹•'},
            {code:'zh-TW',name:'ç¹ä¸­'},
            {code:'en',name:'English'},
            {code:'ja',name:'æ—¥æœ¬èª'},
            {code:'ko',name:'éŸ“èª'},
            {code:'vi',name:'è¶Šå—'},
            {code:'th',name:'æ³°æ–‡'},
            {code:'nan',name:'å°èª'},
            {code:'yue',name:'ç²µèª'},
            {code:'fr',name:'æ³•æ–‡'},
            {code:'de',name:'å¾·æ–‡'},
            {code:'nl',name:'è·è˜­æ–‡'}
        ];
        const TASKS = [
            {id:'notes',name:'ç­†è¨˜',icon:<Icons.Notebook/>,btnColor:'bg-teal-600'},
            {id:'translate',name:'ç¿»è­¯',icon:<Icons.Languages/>,btnColor:'bg-blue-600'},
            {id:'summarize',name:'æ‘˜è¦',icon:<Icons.List/>,btnColor:'bg-orange-500'},
            {id:'polish',name:'æ½¤é£¾',icon:<Icons.Magic/>,btnColor:'bg-purple-600'},
            {id:'grammar',name:'æ–‡æ³•',icon:<Icons.Search/>,btnColor:'bg-emerald-600'},
            {id:'analyze',name:'åˆ†æ',icon:<Icons.Brain/>,btnColor:'bg-pink-600'},
            {id:'mindmap',name:'å¿ƒæ™ºåœ–',icon:<Icons.Brain/>,btnColor:'bg-indigo-600'},
            {id:'vision',name:'è­˜åœ–',icon:<Icons.Eye/>,btnColor:'bg-violet-600'}
        ];
        const TONES = [{id:'standard',name:'æ¨™æº–'},{id:'formal',name:'ç¦®è²Œ'},{id:'casual',name:'è¼•é¬†'},{id:'academic',name:'å°ˆæ¥­'},{id:'creative',name:'å„ªç¾'}];
        
        // æ›´ç©©å®šçš„å‚™æ´æ¨¡å‹
        const FALLBACK_MODEL = 'gemini-1.5-flash';

        const Toast = ({ message, type, onClose }) => {
            useEffect(() => { const timer = setTimeout(onClose, 3000); return () => clearTimeout(timer); }, [onClose]);
           return <div className={`fixed bottom-4 left-1/2 -translate-x-1/2 px-4 py-2 rounded-full shadow-lg text-white text-sm font-bold flex items-center gap-2 z-[9999] animate-slide-up ${type==='success'?'bg-slate-800/90':'bg-red-500/90'}`}>{type==='success'?<Icons.Check className="w-4 h-4 text-green-400"/>:<Icons.AlertCircle className="w-4 h-4 text-white"/>}{message}</div>;

        };

        function App() {
            const [mode, setMode] = useState('text');
            const [currentTask, setCurrentTask] = useState('notes');
            const [sourceText, setSourceText] = useState('');
            const [translatedText, setTranslatedText] = useState('');
            const [sourceLang, setSourceLang] = useState('auto');
            const [targetLang, setTargetLang] = useState('zh-TW');
            const [selectedTone, setSelectedTone] = useState('standard');
            const [isLoading, setIsLoading] = useState(false);
            const [loadingStatus, setLoadingStatus] = useState('');
            const [errorMsg, setErrorMsg] = useState('');
            const [fileName, setFileName] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [showHistory, setShowHistory] = useState(false);
            const [showBigText, setShowBigText] = useState(false);
            const [isRealTime, setIsRealTime] = useState(false);
            const [isMarkdownMode, setIsMarkdownMode] = useState(true);
            const [usePdfVision, setUsePdfVision] = useState(false);
            const [fsSize, setFsSize] = useState(24);
            const [globalFontSize, setGlobalFontSize] = useState(16);
            const [fsWidth, setFsWidth] = useState(1000); 
            const [aiTemperature, setAiTemperature] = useState(0.7);
            const [bilingualMode, setBilingualMode] = useState(false);
            const [darkMode, setDarkMode] = useState(()=>localStorage.getItem('gemini_dark_mode')==='true');
            const [geminiKey, setGeminiKey] = useState(localStorage.getItem('gemini_api_key')||'');
            const [geminiModel, setGeminiModel] = useState(localStorage.getItem('gemini_model')||'gemini-2.5-flash-preview-09-2025');
            const [history, setHistory] = useState(() => { try { return JSON.parse(localStorage.getItem('translate_history') || '[]'); } catch(e) { return []; } });
            const [chatMessages, setChatMessages] = useState([]);
            const [chatInput, setChatInput] = useState('');
            const [showCropModal, setShowCropModal] = useState(false);
            const [cropImageSrc, setCropImageSrc] = useState(null);
            const [cropSelection, setCropSelection] = useState(null);
            const [showVisualMode, setShowVisualMode] = useState(false);
            const [displayImage, setDisplayImage] = useState(null);
            const [visualBox, setVisualBox] = useState({ x: 50, y: 50, w: 300, h: 'auto' });
            const [visualFontSize, setVisualFontSize] = useState(18);
            const [visualDragging, setVisualDragging] = useState(false);
            const [visualResizing, setVisualResizing] = useState(false);
            const [visualStyle, setVisualStyle] = useState({ color: 'white', bg: 'rgba(0,0,0,0.6)' });
            const dragStartRef = useRef(null);
            const isDraggingRef = useRef(false);
            const imageRef = useRef(null);
            const visualContainerRef = useRef(null);
            const visualDragStartRef = useRef(null);
            const visualResizeStartRef = useRef(null);
            const fileInputRef = useRef(null);
            const cameraInputRef = useRef(null);
            const chatFileInputRef = useRef(null); // New ref for chat image upload
            const requestCounter = useRef(0);
            const chatEndRef = useRef(null);
            const [isListening, setIsListening] = useState(false);
            const [selectionMenu, setSelectionMenu] = useState({ visible: false, x: 0, y: 0, text: '' });
            const [activeTab, setActiveTab] = useState('general');
            const [toast, setToast] = useState(null);
            const [availableVoices, setAvailableVoices] = useState([]);
            const [selectedVoiceURI, setSelectedVoiceURI] = useState('');
            const [voiceRate, setVoiceRate] = useState(1);
            const [voicePitch, setVoicePitch] = useState(1);
            const [glossary, setGlossary] = useState(() => { try { return JSON.parse(localStorage.getItem('gemini_glossary') || '[]'); } catch(e) { return []; } });
            const [newGlossaryTerm, setNewGlossaryTerm] = useState('');
            const [newGlossaryTrans, setNewGlossaryTrans] = useState('');
            const [customInstruction, setCustomInstruction] = useState(localStorage.getItem('gemini_custom_instruction') || '');
            const [isDragOver, setIsDragOver] = useState(false);
            const fsContentRef = useRef(null);
            const fsInnerRef = useRef(null);
            const recognitionRef = useRef(null);
            const abortControllerRef = useRef(null);
            
            // --- NEW: IMAGE GEN STATE ---
            const [imageGenState, setImageGenState] = useState({ show: false, prompt: '' });
            
            // --- FIREBASE SYNC STATES ---
            const [firebaseConfigStr, setFirebaseConfigStr] = useState(localStorage.getItem('firebase_config_str') || JSON.stringify(DEFAULT_FIREBASE_CONFIG, null, 2));
            const [syncId, setSyncId] = useState(localStorage.getItem('sync_id') || '');
            const [isSyncing, setIsSyncing] = useState(false);
            const [syncStatusMsg, setSyncStatusMsg] = useState('');
            const [isCloudInitialized, setIsCloudInitialized] = useState(false); // SAFETY LOCK
            const dbRef = useRef(null);
            const isRemoteUpdate = useRef(false);

            // --- FIREBASE LOGIC ---
            useEffect(() => {
                if (firebaseConfigStr && syncId && typeof firebase !== 'undefined') {
                    try {
                        const config = JSON.parse(firebaseConfigStr);
                        if (!firebase.apps.length) {
                            firebase.initializeApp(config);
                        }
                        const db = firebase.firestore();
                        dbRef.current = db;
                        
                        // Initial Fetch to prevent overwriting cloud data with empty local state
                        db.collection('gemini_sync_data').doc(syncId).get().then((doc) => {
                            if (doc.exists) {
                                const data = doc.data();
                                isRemoteUpdate.current = true;
                                if (data.history) setHistory(data.history);
                                if (data.glossary) setGlossary(data.glossary);
                                if (data.customInstruction) setCustomInstruction(data.customInstruction);
                                showToast("è³‡æ–™å·²å¾é›²ç«¯è¼‰å…¥ (åˆå§‹åŒ–)", "success");
                                setTimeout(() => { isRemoteUpdate.current = false; setIsCloudInitialized(true); }, 500); // UNLOCK
                            } else {
                                setIsCloudInitialized(true); // New ID, safe to write
                            }
                        }).catch(e => {
                            console.error("Init fetch failed", e);
                            setIsCloudInitialized(true); // Fallback to allow local usage
                        });

                        // Real-time listener
                        const unsubscribe = db.collection('gemini_sync_data').doc(syncId).onSnapshot((doc) => {
                            setIsSyncing(true);
                            setSyncStatusMsg('å·²é€£ç·š');
                            if (doc.exists && isCloudInitialized) { // Only process updates if initialized
                                const data = doc.data();
                                isRemoteUpdate.current = true;
                                if (data.history) setHistory(data.history);
                                if (data.glossary) setGlossary(data.glossary);
                                if (data.customInstruction) setCustomInstruction(data.customInstruction);
                                setTimeout(() => { isRemoteUpdate.current = false; }, 1000);
                            }
                        }, (error) => {
                            console.error("Sync Error:", error);
                            setIsSyncing(false);
                            if (error.code === 'permission-denied') {
                                setSyncStatusMsg('æ¬Šé™ä¸è¶³ï¼šè«‹æª¢æŸ¥ Firebase Rules');
                            } else if (error.code === 'unavailable') {
                                setSyncStatusMsg('ç„¡æ³•é€£ç·šï¼šè«‹æª¢æŸ¥ç¶²è·¯æˆ– Firestore ç‹€æ…‹');
                            } else {
                                setSyncStatusMsg('é€£ç·šå¤±æ•—ï¼šè«‹æª¢æŸ¥ Config æˆ– ID');
                            }
                        });

                        return () => unsubscribe();
                    } catch (e) {
                        console.error("Firebase Init Error", e);
                        setIsSyncing(false);
                        setSyncStatusMsg('è¨­å®šéŒ¯èª¤ï¼šJSON æ ¼å¼ä¸æ­£ç¢º');
                    }
                }
            }, [firebaseConfigStr, syncId]);

            const pushToCloud = useCallback((type, data) => {
                if (dbRef.current && syncId && !isRemoteUpdate.current && isCloudInitialized) {
                    dbRef.current.collection('gemini_sync_data').doc(syncId).set({
                        [type]: data,
                        lastUpdated: new Date().toISOString()
                    }, { merge: true }).catch(err => {
                        console.error("Upload failed", err);
                        if (err.code === 'permission-denied') {
                            showToast("åŒæ­¥å¤±æ•—ï¼šè³‡æ–™åº«æ¬Šé™ä¸è¶³", "error");
                        }
                    });
                }
            }, [syncId, isCloudInitialized]);
            
            const testConnection = async () => {
                if (!dbRef.current || !syncId) {
                    showToast("è«‹å…ˆè¼¸å…¥å®Œæ•´çš„ Firebase Config å’Œ Sync ID", "error");
                    return;
                }
                setIsLoading(true);
                try {
                    await dbRef.current.collection('gemini_sync_data').doc(syncId).set({
                        lastTest: new Date().toISOString()
                    }, { merge: true });
                    showToast("æ¸¬è©¦æˆåŠŸï¼å¯«å…¥æ¬Šé™æ­£å¸¸", "success");
                    setSyncStatusMsg("é€£ç·šæ­£å¸¸ï¼Œå¯åŒæ­¥");
                } catch (error) {
                    console.error("Test Connection Failed:", error);
                    let msg = "æ¸¬è©¦å¤±æ•—";
                    if (error.code === 'permission-denied') msg = "æ¬Šé™ä¸è¶³ (Permission Denied) - è«‹æª¢æŸ¥ Firestore Rules";
                    else if (error.code === 'unavailable') msg = "æœå‹™ç„¡æ³•ä½¿ç”¨ - è«‹ç¢ºèªæ˜¯å¦å·²å»ºç«‹ Firestore è³‡æ–™åº«";
                    else if (error.code === 'invalid-argument') msg = "åƒæ•¸éŒ¯èª¤ - è«‹æª¢æŸ¥ Config æ ¼å¼";
                    else msg = `é€£ç·šéŒ¯èª¤: ${error.message}`;
                    
                    showToast(msg, "error");
                    setSyncStatusMsg(msg);
                } finally {
                    setIsLoading(false);
                }
            };

// --- ä¿®æ”¹å€å¡Šé–‹å§‹ï¼štestApiKey ---
const testApiKey = async () => {
    // è§£ææ‰€æœ‰ Keys
    const allKeys = geminiKey.split(/[\n,]+/).map(k => k.trim()).filter(k => k);

    if (allKeys.length === 0) {
        showToast("è«‹å…ˆè¼¸å…¥ API Key", "error");
        return;
    }

    const originalStatus = loadingStatus;
    setIsLoading(true);
    setLoadingStatus(`æ­£åœ¨é©—è­‰ ${allKeys.length} çµ„ API Key...`);

    try {
        const modelToTest = geminiModel || 'gemini-1.5-flash';
        
        // åªæ¸¬è©¦ç¬¬ä¸€çµ„ï¼Œæˆ–è€…ä½ å¯ä»¥å¯«è¿´åœˆæ¸¬è©¦å…¨éƒ¨
        // é€™è£¡ç¤ºç¯„æ¸¬è©¦ç¬¬ä¸€çµ„å³å¯ï¼Œå› ç‚º runGeminiRequest æœƒè‡ªå‹•è¼ªè©¢
        const keyToTest = allKeys[0]; 

        const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelToTest}:generateContent?key=${keyToTest}`;
        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: [{ parts: [{ text: "Hello" }] }] })
        });

        const data = await res.json();

        if (!res.ok) {
            let errorMsg = data.error?.message || `HTTP Error: ${res.status}`;
            if (res.status === 400) errorMsg = "ç„¡æ•ˆçš„ Key";
            else if (res.status === 429) errorMsg = "ç¬¬ä¸€çµ„ Key é¡åº¦å·²æ»¿ (ä½†ç³»çµ±æœƒå˜—è©¦å…¶ä»–çµ„)";
            throw new Error(errorMsg);
        }

        showToast(`âœ… é©—è­‰æˆåŠŸï¼å·²è¼‰å…¥ ${allKeys.length} çµ„ Key`, "success");

    } catch (e) {
        showToast("âŒ é©—è­‰å¤±æ•—: " + e.message, "error");
    } finally {
        setIsLoading(false);
        setLoadingStatus(originalStatus);
    }
};
// --- ä¿®æ”¹å€å¡ŠçµæŸ ---

            // Auto-sync triggers
            useEffect(() => { localStorage.setItem('translate_history', JSON.stringify(history)); pushToCloud('history', history); }, [history, pushToCloud]);
            useEffect(() => { localStorage.setItem('gemini_glossary', JSON.stringify(glossary)); pushToCloud('glossary', glossary); }, [glossary, pushToCloud]);
            useEffect(() => { localStorage.setItem('gemini_custom_instruction', customInstruction); pushToCloud('customInstruction', customInstruction); }, [customInstruction, pushToCloud]);

            // Normal LocalStorage effects
            useEffect(() => { if(darkMode){document.documentElement.classList.add('dark');localStorage.setItem('gemini_dark_mode','true');}else{document.documentElement.classList.remove('dark');localStorage.setItem('gemini_dark_mode','false');} }, [darkMode]);
            useEffect(() => { localStorage.setItem('gemini_api_key', geminiKey); }, [geminiKey]);
            useEffect(() => { localStorage.setItem('gemini_model', geminiModel); }, [geminiModel]);
            useEffect(() => { localStorage.setItem('firebase_config_str', firebaseConfigStr); }, [firebaseConfigStr]);
            useEffect(() => { localStorage.setItem('sync_id', syncId); }, [syncId]);
            useEffect(() => { 
                const getVoices = () => { const v = window.speechSynthesis.getVoices(); setAvailableVoices(v); }; 
                getVoices(); window.speechSynthesis.onvoiceschanged = getVoices; 
            }, []);
            useEffect(() => { chatEndRef.current?.scrollIntoView({behavior:'smooth'}); }, [chatMessages, imageGenState.show]);

            // --- Helper Functions ---
            const addToHistory = (src, res, s, t) => setHistory(prev => [{ id: Date.now(), src, res, s, t, timestamp: new Date().toLocaleString() }, ...prev].slice(0, 50));
            const clearHistory = () => { if(confirm("ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ­·å²ç´€éŒ„å—ï¼Ÿ")) { setHistory([]); } };
            const addGlossaryTerm = () => { if(newGlossaryTerm && newGlossaryTrans) { setGlossary([...glossary, { term: newGlossaryTerm, trans: newGlossaryTrans }]); setNewGlossaryTerm(''); setNewGlossaryTrans(''); } };
            const removeGlossaryTerm = (index) => { const newG = [...glossary]; newG.splice(index, 1); setGlossary(newG); };
            
            const showToast = (msg, type = 'success') => { setToast({ message: msg, type }); };

            const resetApp = () => {
                setSourceText('');
                setTranslatedText('');
                setErrorMsg('');
                setCropImageSrc(null);
                setDisplayImage(null);
                setCropSelection(null);
                setShowCropModal(false);
                setShowVisualMode(false);
                setChatMessages([]);
                setLoadingStatus('');
                setImageGenState({ show: false, prompt: '' });
                if (fileInputRef.current) fileInputRef.current.value = '';
                if (cameraInputRef.current) cameraInputRef.current.value = '';
                if (chatFileInputRef.current) chatFileInputRef.current.value = '';
            };

            const handleClearAll = () => {
                if(confirm("ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰å…§å®¹ï¼ˆåŸæ–‡ã€çµæœã€å°è©±ï¼‰å—ï¼Ÿ")) {
                    resetApp();
                    setFileName(null);
                    showToast("å·²æ¸…é™¤æ‰€æœ‰å…§å®¹", "success");
                }
            };
            
            const handleCancelRequest = () => {
                if (abortControllerRef.current) {
                    abortControllerRef.current.abort();
                    abortControllerRef.current = null;
                }
                setIsLoading(false);
                setLoadingStatus('');
                showToast("å·²å–æ¶ˆè«‹æ±‚", "success");
            };

          // --- ä¿®æ”¹å€å¡Šé–‹å§‹ï¼šrunGeminiRequest ---
const runGeminiRequest = async (payload, preferredModel) => {
    if (abortControllerRef.current) abortControllerRef.current.abort();
    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    // 1. è§£ææ‰€æœ‰ Keys (æ”¯æ´æ›è¡Œæˆ–é€—è™Ÿåˆ†éš”)
    const allKeys = geminiKey.split(/[\n,]+/).map(k => k.trim()).filter(k => k);

    if (allKeys.length === 0) throw new Error("è«‹å…ˆè¼¸å…¥ API Key");

    // å…§éƒ¨è«‹æ±‚å‡½å¼ (å–®æ¬¡å˜—è©¦)
    const executeFetch = async (modelId, key) => {
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${key}`;
        const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            signal
        };
        const res = await fetch(url, options);
        // å¦‚æœæ˜¯ 429 (é¡åº¦æ»¿)ï¼Œæ‹‹å‡ºç‰¹å®šéŒ¯èª¤ä»¥ä¾¿å¤–å±¤æ•æ‰æ› Key
        if (res.status === 429) throw new Error("429_QUOTA");
        return await res.json().then(data => ({ status: res.status, ok: res.ok, data }));
    };

    // å˜—è©¦æ‰€æœ‰ Keys çš„è¿´åœˆé‚è¼¯
    const attemptWithKeyRotation = async (modelId) => {
        let lastError = null;

        for (let i = 0; i < allKeys.length; i++) {
            const currentKey = allKeys[i];
            try {
                // å¦‚æœä¸æ˜¯ç¬¬ä¸€çµ„ Keyï¼Œé¡¯ç¤ºåˆ‡æ›ç‹€æ…‹
                if (i > 0) setLoadingStatus(`Key #${i} é¡åº¦å·²æ»¿ï¼Œåˆ‡æ›è‡³ Key #${i + 1}...`);
                
                return await executeFetch(modelId, currentKey);
            } catch (e) {
                if (e.message === "Request cancelled") throw e;
                if (e.message === "429_QUOTA") {
                    console.warn(`Key ending in ...${currentKey.slice(-4)} exhausted.`);
                    lastError = e;
                    continue; // å˜—è©¦ä¸‹ä¸€çµ„ Key
                }
                throw e; // å…¶ä»–éŒ¯èª¤ (å¦‚ 400, 500) ç›´æ¥æ‹‹å‡º
            }
        }
        // å¦‚æœæ‰€æœ‰ Keys éƒ½è·‘å®Œé‚„æ˜¯ 429
        throw new Error("429_TOO_MANY_REQUESTS"); 
    };

    try {
        // å„ªå…ˆå˜—è©¦é¸å®šçš„æ¨¡å‹
        let resultWrapper = await attemptWithKeyRotation(preferredModel);
        let resData = resultWrapper.data;

        // æª¢æŸ¥æ˜¯å¦æœ‰ API éŒ¯èª¤
        if (resData.error) throw new Error(resData.error.message || "API Error");

        // å¦‚æœæˆåŠŸä¸”æœ‰å…§å®¹
        if (resData && resData.candidates && resData.candidates.length > 0) {
            return resData;
        }

        // å¦‚æœæ˜¯ PromptFeedback è¢«æ“‹
        if (resData.promptFeedback) console.warn("Safety Filter triggered:", resData.promptFeedback);

        // å¦‚æœä¸»è¦æ¨¡å‹å¤±æ•—ä¸”ä¸æ˜¯ Flash 1.5ï¼Œå˜—è©¦å‚™æ´æ¨¡å‹ (Fallback)
        if (preferredModel !== FALLBACK_MODEL) {
            console.log("Primary model empty/failed, trying fallback...");
            setLoadingStatus(`åˆ‡æ›è‡³ç©©å®šæ¨¡å‹ (${FALLBACK_MODEL})...`);
            resultWrapper = await attemptWithKeyRotation(FALLBACK_MODEL);
            if (resultWrapper.data.error) throw new Error(resultWrapper.data.error.message);
            return resultWrapper.data;
        }

        return resData;

    } catch (e) {
        if (e.message === 'Request cancelled') throw new Error("Request cancelled");

        console.error("Gemini Request Failed:", e);

        // å¦‚æœæ‰€æœ‰ Key éƒ½æ»¿äº†ï¼Œæˆ–æ˜¯å…¶ä»–éŒ¯èª¤ï¼Œä¸”é‚„æ²’è©¦éå‚™æ´æ¨¡å‹
        if (preferredModel !== FALLBACK_MODEL) {
            const errorType = e.message.includes("404") ? "æ¨¡å‹ä¸å­˜åœ¨" : "é€£ç·šç•°å¸¸æˆ–é¡åº¦å…¨æ»¿";
            showToast(`${errorType}ï¼Œå˜—è©¦å‚™æ´æ¨¡å‹`, "error");
            setLoadingStatus("å•Ÿå‹•å‚™æ´æ¨¡å‹...");
            try {
                const fbWrapper = await attemptWithKeyRotation(FALLBACK_MODEL);
                return fbWrapper.data;
            } catch (fbError) {
                throw fbError; // å‚™æ´ä¹Ÿå¤±æ•—ï¼Œå¾¹åº•å¤±æ•—
            }
        }
        throw e;
    }
};
// --- ä¿®æ”¹å€å¡ŠçµæŸ ---
            
            const handleSmartAction = async (actionType) => {
                if(chatMessages.length === 0 && actionType !== 'image_prompt') {
                    showToast("è«‹å…ˆé€²è¡Œå°è©±å†ä½¿ç”¨æ­¤åŠŸèƒ½", "error");
                    return;
                }
                
                setIsLoading(true);
                const currentRequestId = ++requestCounter.current;
                
                let historyStr = '';
                chatMessages.forEach(m => {
                    historyStr += `${m.role === 'user' ? 'User' : 'Model'}: ${m.text}\n`;
                });

                if (actionType === 'summary') {
                    setLoadingStatus('æ­£åœ¨æ•´ç†å°è©±é‡é»...');
                    const prompt = `Based on the following conversation history, please provide a concise summary in Traditional Chinese bullet points. Highlight key takeaways and action items if any.\n\nConversation:\n${historyStr}`;
                    
                    try {
                         const payload = { contents:[{parts:[{text:prompt}]}] };
                         const res = await runGeminiRequest(payload, geminiModel);
                         const summary = res.candidates?.[0]?.content?.parts?.[0]?.text;
                         
                         if(summary) {
                             setChatMessages(prev => [...prev, {role:'model', text: `### ğŸ“ å°è©±é‡é»æ•´ç†\n\n${summary}`}]);
                         }
                    } catch(e) {
                        if (e.message !== "Request cancelled") showToast("æ•´ç†å¤±æ•—: " + e.message, "error");
                    }
                } 
                else if (actionType === 'image_prompt') {
                    setLoadingStatus('æ­£åœ¨æ§‹æ€ç¹ªåœ–æŒ‡ä»¤...');
                    // If no history, assume user wants to start fresh
                    let context = historyStr;
                    if (!context && sourceText) context = `Source Text: ${sourceText}`;
                    if (!context) context = "A creative and artistic scene.";

                    const prompt = `Based on the visual concepts discussed in this conversation (or the source text provided), create a detailed image generation prompt (in English, as it works best for image models). The prompt should be descriptive, artistic, and suitable for a high-quality image generator. Output ONLY the prompt text, no intro/outro.\n\nContext:\n${context}`;
                    
                    try {
                         const payload = { contents:[{parts:[{text:prompt}]}] };
                         const res = await runGeminiRequest(payload, geminiModel);
                         const promptText = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                         
                         if(promptText) {
                             setImageGenState({ show: true, prompt: promptText });
                             // Don't auto-send message, just open panel
                         }
                    } catch(e) {
                        if (e.message !== "Request cancelled") showToast("ç”¢ç”ŸæŒ‡ä»¤å¤±æ•—: " + e.message, "error");
                    }
                }
                
                setIsLoading(false);
            };
            
            // --- NEW: Handle Image Upload in Chat for Style Analysis ---
            const handleChatImageUpload = async (e) => {
                const file = e.target.files[0];
                if(!file) return;
                
                if(!geminiKey) {
                    showToast("è«‹å…ˆåœ¨è¨­å®šä¸­è¼¸å…¥ API Key æ‰èƒ½ä½¿ç”¨åœ–ç‰‡åˆ†æåŠŸèƒ½", "error");
                    return;
                }

                setIsLoading(true);
                setLoadingStatus("æ­£åœ¨åˆ†æåœ–ç‰‡é¢¨æ ¼...");
                
                try {
                    const b64 = await compressImage(file);
                    
                    let prompt = "";
                    let successTitle = "";
                    
                    // Check if there is text in the input box to combine
                    if (chatInput.trim()) {
                        prompt = `Analyze the artistic style of the provided image. Then, create a detailed image generation prompt in English that depicts the following subject: "${chatInput}". The image must be generated strictly in the analyzed style (colors, brushstrokes, lighting, mood) of the provided image. Output ONLY the prompt text.`;
                        successTitle = "ğŸ¨ é¢¨æ ¼+å…§å®¹æ•´åˆå®Œæˆ";
                    } else {
                        // Original Style Analysis
                        prompt = `Analyze the artistic style, color palette, lighting, and composition of this image. Create a detailed image generation prompt in English that would allow an AI to generate a NEW image with this exact same style and aesthetic. Output ONLY the prompt text.`;
                        successTitle = "ğŸ¨ é¢¨æ ¼åˆ†æå®Œæˆ";
                    }
                    
                    const payload = {contents:[{parts:[{text: prompt},{inline_data:{mime_type:'image/jpeg',data:b64}}]}]};
                    const res = await runGeminiRequest(payload, geminiModel);
                    const newPrompt = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    
                    const successBody = chatInput.trim() 
                        ? `å·²å°‡æ‚¨çš„æè¿°ã€Œ${chatInput}ã€èˆ‡åœ–ç‰‡é¢¨æ ¼çµåˆã€‚`
                        : `å·²æ ¹æ“šæ‚¨ä¸Šå‚³çš„åœ–ç‰‡æå–é¢¨æ ¼æç¤ºè©ã€‚`;

                    setChatMessages(prev => [...prev, {
                        role: 'model', 
                        text: `### ${successTitle}\n\n${successBody} æ‚¨å¯ä»¥åœ¨ä¸‹æ–¹ã€Œç¹ªåœ–å·¥åŠã€æŸ¥çœ‹æˆ–ä¿®æ”¹ï¼Œä¸¦ç”Ÿæˆæ–°åœ–ç‰‡ã€‚`
                    }]);

                    if (newPrompt) {
                        setImageGenState({ show: true, prompt: newPrompt });
                    }
                } catch(e) {
                    if (e.message !== "Request cancelled") showToast("åˆ†æåœ–ç‰‡å¤±æ•—: " + e.message, "error");
                } finally {
                    setIsLoading(false);
                    setLoadingStatus('');
                    if(chatFileInputRef.current) chatFileInputRef.current.value = '';
                }
            };

            const handleResultToImageGen = async () => {
                if (!translatedText) {
                    showToast("æ²’æœ‰å…§å®¹å¯ä¾›ç¹ªåœ–", "error");
                    return;
                }
                setIsLoading(true);
                setLoadingStatus("æ­£åœ¨å°‡å…§å®¹è½‰æ›ç‚ºç¹ªåœ–æç¤ºè©...");
                try {
                    const prompt = `Based on the following text, create a detailed, artistic image generation prompt in English. Output ONLY the prompt text.\n\nText:\n${translatedText.substring(0, 2000)}`;
                    const payload = { contents:[{parts:[{text:prompt}]}] };
                    const res = await runGeminiRequest(payload, geminiModel);
                    const newPrompt = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    
                    setMode('conversation');
                    // Add a context message to chat
                    setChatMessages(prev => [...prev, {role:'model', text: `### ğŸ¨ è¯æƒ³ç¹ªåœ–æ¨¡å¼\n\nå·²æ ¹æ“šæ‚¨çš„å…§å®¹ç”¢ç”Ÿåˆæ­¥æç¤ºè©ï¼Œè«‹åœ¨ä¸‹æ–¹ã€Œç¹ªåœ–å·¥åŠã€é¢æ¿é€²è¡Œç¢ºèªæˆ–ä¿®æ”¹ã€‚`}]);
                    
                    if (newPrompt) {
                        setImageGenState({ show: true, prompt: newPrompt });
                    } else {
                        setImageGenState({ show: true, prompt: translatedText }); 
                    }
                } catch(e) {
                    if (e.message !== "Request cancelled") showToast("è½‰æ›å¤±æ•—: " + e.message, "error");
                    setMode('conversation');
                    setImageGenState({ show: true, prompt: translatedText });
                } finally {
                    setIsLoading(false);
                }
            };

            const callAI = async (promptType, textOverride = null) => {
                const textToUse = textOverride !== null ? textOverride : sourceText;
                if (!textToUse.trim()) return;
                
                const currentRequestId = ++requestCounter.current;
                setIsLoading(true);
                setErrorMsg('');
                if (!isRealTime && textOverride === null) setTranslatedText('');

                // Image Generation Branch - NOW REDIRECTS TO CHAT PANEL
                if (promptType === 'image-gen') {
                    setIsLoading(false);
                    // Switch to chat mode
                    setMode('conversation');
                    // If there is source text, use it as initial prompt
                    if (textToUse) {
                        setImageGenState({ show: true, prompt: textToUse });
                    } else {
                        // Just open empty panel
                        setImageGenState({ show: true, prompt: '' });
                    }
                    return;
                }
                
                // Text Generation Branch
                const tName = LANGUAGES.find(l=>l.code===targetLang)?.name || targetLang;
                const toneInfo = TONES.find(t => t.id === selectedTone)?.name || 'Standard';
                
                const now = new Date().toLocaleString('zh-TW', { timeZone: 'Asia/Taipei' });
                let sys = `Current DateTime: ${now}. Task: ${promptType}. Target: ${tName}. Tone: ${toneInfo}. Input: ${textToUse}.`;
                
                if(promptType==='translate') {
                    if (targetLang === 'nan') {
                        sys = `Current DateTime: ${now}. Translate the following text to Taiwanese Hokkien (å°èª). You may use Traditional Chinese characters (æ¼¢å­—) or PeÌh-Åe-jÄ« (POJ) mixed as appropriate for natural Taiwanese reading. Source: Auto. Tone: ${toneInfo}. Output ONLY the translated result in Markdown. Text:\n${textToUse}`;
                    } else if (targetLang === 'yue') {
                        sys = `Current DateTime: ${now}. Translate the following text to Cantonese (ç²µèª). Use Traditional Chinese characters. Source: Auto. Tone: ${toneInfo}. Output ONLY the translated result in Markdown. Text:\n${textToUse}`;
                    } else {
                        sys = `Current DateTime: ${now}. Translate the following text to ${tName}. Source language: Auto. Tone: ${toneInfo}. Output ONLY the translated result in Markdown format. Text to translate:\n${textToUse}`;
                    }
                } else if(promptType==='mindmap') {
                    sys = `Current DateTime: ${now}. Generate a Mind Map for the following text using Mermaid JS syntax (mindmap). Output ONLY the code block starting with \`\`\`mermaid. Do NOT include intro/outro. Use ${tName} for node labels. Text to analyze:\n${textToUse}`;
                } else if (promptType === 'vision') {
                    sys = `Current DateTime: ${now}. The user has provided a description of an image. Please organize this description into a clear, readable Markdown format. Input:\n${textToUse}`;
                }
                
                if(glossary.length>0) sys += `\nGlossary:${JSON.stringify(glossary)}`;
                if(customInstruction) sys += `\nSystem Instruction:${customInstruction}`;

                try {
                    let out = "";
                    if(!geminiKey) { setShowSettings(true); throw new Error("è«‹è¼¸å…¥ API Key"); }
                    
                    const safetySettings = [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                    ];

                    const payload = {
                        contents:[{parts:[{text:sys}]}], 
                        generationConfig:{temperature:aiTemperature},
                        safetySettings: safetySettings
                    };

                    const res = await runGeminiRequest(payload, geminiModel);
                    
                    // Safety check
                    if (res.promptFeedback && res.promptFeedback.blockReason) {
                         throw new Error(`âš ï¸ å…§å®¹è¢«å®‰å…¨ç³»çµ±é˜»æ“‹ (${res.promptFeedback.blockReason})`);
                    }

                    const candidate = res.candidates?.[0];
                    if (!candidate) {
                       console.error("AI Response Error:", res);
                       throw new Error("No response candidates from AI. (å¯èƒ½åŸå› : æ¨¡å‹è² è¼‰éé«˜æˆ–å…§å®¹è¢«éæ¿¾)");
                    }
                    if (candidate.finishReason !== "STOP" && !candidate.content) {
                       throw new Error(`AI response blocked. Reason: ${candidate.finishReason}`);
                    }
                    
                    out = candidate.content?.parts?.[0]?.text || "Error: Empty content";
                    
                    if(currentRequestId === requestCounter.current) {
                        if(promptType==='mindmap') {
                            let cleaned = out;
                            if(cleaned.includes('```mermaid')) {
                                cleaned = cleaned.split('```mermaid')[1];
                            } else if(cleaned.includes('```')) {
                                cleaned = cleaned.split('```')[1]; 
                            }
                            if(cleaned.includes('```')) {
                                cleaned = cleaned.split('```')[0];
                            }
                            cleaned = cleaned.trim();
                            if (!cleaned.startsWith('mindmap')) {
                                cleaned = 'mindmap\n' + cleaned;
                            } else {
                                const firstLineEnd = cleaned.indexOf('\n');
                                if (firstLineEnd === -1) {
                                    cleaned = cleaned.replace('mindmap', 'mindmap\n');
                                } else {
                                    const firstLine = cleaned.substring(0, firstLineEnd).trim();
                                    if (firstLine !== 'mindmap') {
                                       cleaned = cleaned.replace('mindmap', 'mindmap\n');
                                    }
                                }
                            }
                            setTranslatedText(cleaned);
                        } else {
                            setTranslatedText(out);
                        }
                        if(!out.startsWith('Error') && !out.startsWith('æ­¤æ¨¡å¼')) addToHistory(textToUse, out, sourceLang, targetLang);
                    }
                } catch(e) { 
                    if(currentRequestId === requestCounter.current) {
                        if (e.message !== "Request cancelled") {
                            setErrorMsg(e.message); 
                            setTranslatedText(`éŒ¯èª¤: ${e.message}\n\n1. è«‹æª¢æŸ¥ API Key æ˜¯å¦æ­£ç¢º\n2. å˜—è©¦æ›´æ›å…¶ä»–æ¨¡å‹ (Flash/Pro)\n3. å…§å®¹å¯èƒ½æ¶‰åŠæ•æ„Ÿè©±é¡Œ`);
                        }
                    }
                }
                if(currentRequestId === requestCounter.current) setIsLoading(false);
            };

            const processFile = async (f) => {
                if(!f) return;
                resetApp(); // HARD RESET ON NEW FILE
                
                if (currentTask === 'vision' && !f.type.startsWith('image/')) {
                    showToast("è­˜åœ–æ¨¡å¼åƒ…é™ä¸Šå‚³åœ–ç‰‡", "error");
                    return;
                }

                setFileName(f.name); 
                if(f.type.startsWith('image/')) {
                      const r = new FileReader(); 
                      r.onload = e => { 
                          setTimeout(() => {
                              setCropImageSrc(e.target.result); 
                              setDisplayImage(e.target.result); 
                              setShowCropModal(true); 
                          }, 50);
                      }; 
                      r.readAsDataURL(f);
                      return;
                }
                setMode('text'); setIsLoading(true); setLoadingStatus('è®€å–ä¸­...'); setErrorMsg('');
                try {
                    let text = "";
                    if(f.name.endsWith('.pdf')) {
                        const ab = await f.arrayBuffer();
                        if(usePdfVision && geminiKey) {
                            setLoadingStatus('AI è¦–è¦ºè®€å– PDF...');
                            const imgs = await renderPdfToImages(ab.slice(0));
                            text = await performGeminiOCR_Multi(imgs.images || imgs); 
                        } else {
                            const pdf = await loadPdfWithPassword(ab.slice(0));
                            for(let i=1;i<=pdf.numPages;i++) text += (await (await pdf.getPage(i)).getTextContent()).items.map(s=>s.str).join(' ')+'\n';
                            if((!text || text.length<50) && geminiKey) {
                                setLoadingStatus('æ–‡å­—éå°‘ï¼Œåˆ‡æ›è‡³ AI è¦–è¦ºè®€å–...');
                                const imgs = await renderPdfToImages(ab.slice(0));
                                text = await performGeminiOCR_Multi(imgs.images || imgs);
                            }
                        }
                    } else if(f.name.endsWith('.docx')) {
                        text = (await window.mammoth.extractRawText({arrayBuffer:await f.arrayBuffer()})).value;
                    } else {
                        text = await new Promise(r=>{const rd=new FileReader(); rd.onload=e=>r(e.target.result); rd.readAsText(f);});
                    }
                    if(!text.trim()) throw new Error("ç„¡æ³•è®€å–æ–‡å­—");
                    setSourceText(text);
                    callAI(currentTask, text);
                } catch(e) { console.error(e); setErrorMsg(e.message||"è®€å–å¤±æ•—"); setIsLoading(false); }
            };
            
            const handleFileChange = (e) => { 
                const f = e.target.files[0]; 
                if(f) processFile(f); 
                e.target.value = ''; 
            };

            const performGeminiOCR = async (file, task) => {
                const b64 = await compressImage(file);
                let promptText = "OCR this image. Output text only.";
                if (task === 'vision') promptText = "è«‹ç”¨ç¹é«”ä¸­æ–‡è©³ç´°æè¿°é€™å¼µåœ–ç‰‡çš„å…§å®¹ã€‚å¦‚æœæœ‰æ–‡å­—ï¼Œè«‹ä¹Ÿä¸€ä½µåˆ—å‡ºã€‚ (Describe this image in detail in Traditional Chinese)";
                
                const payload = {contents:[{parts:[{text: promptText},{inline_data:{mime_type:'image/jpeg',data:b64}}]}]};
                const res = await runGeminiRequest(payload, geminiModel);
                return res.candidates?.[0]?.content?.parts?.[0]?.text || "";
            };

            const performGeminiOCR_Multi = async (imgs) => {
                const parts = [{text:"OCR these pages sequentially. Output text only."}];
                imgs.forEach(b64 => parts.push({inline_data:{mime_type:'image/jpeg',data:b64}}));
                const payload = {contents:[{parts}]};
                const res = await runGeminiRequest(payload, geminiModel);
                return res.candidates?.[0]?.content?.parts?.[0]?.text || "";
            };
            
            const performLegacyOCR = async (file) => {
                 setLoadingStatus('Tesseract è¾¨è­˜ä¸­...');
                 const { data: { text } } = await Tesseract.recognize(file, 'chi_tra+eng');
                 return text;
            };

            const runOCR = async (file) => {
                setShowCropModal(false); 
                setIsLoading(true); 
                setSourceText(''); 
                setErrorMsg('');
                
                try {
                    let text = "";
                    
                    // 1. æª¢æŸ¥æ˜¯å¦æœ‰ API Key
                    if (geminiKey) {
                        setLoadingStatus('AI è¦–è¦ºåˆ†æä¸­...');
                        text = await performGeminiOCR(file, currentTask); 
                    } else {
                        // 2. æ²’æœ‰ Keyï¼Œä½¿ç”¨æœ¬æ©Ÿ OCR
                        setLoadingStatus('ç„¡ API Keyï¼Œä½¿ç”¨æœ¬æ©Ÿ OCR è¾¨è­˜æ–‡å­—...');
                        // å¦‚æœç•¶å‰ä»»å‹™æ˜¯ã€Œè­˜åœ– (Vision)ã€ï¼Œä½†æ²’æœ‰ Keyï¼Œç›´æ¥å ±éŒ¯æé†’
                        if (currentTask === 'vision') {
                            throw new Error("ã€Œè­˜åœ–æ¨¡å¼ã€éœ€è¦ AI æ¨¡å‹ä»‹å…¥ï¼Œè«‹å…ˆè‡³è¨­å®šè¼¸å…¥ API Keyã€‚");
                        }
                        text = await performLegacyOCR(file);
                    }
                    
                    // 3. æª¢æŸ¥çµæœ
                    if (!text || !text.trim()) {
                        if (!geminiKey) {
                            throw new Error("æœ¬æ©Ÿè¾¨è­˜æ‰¾ä¸åˆ°æ–‡å­—ã€‚è‹¥éœ€è¾¨è­˜åœ–ç‰‡å…§å®¹(éæ–‡å­—)ï¼Œè«‹è¼¸å…¥ API Keyã€‚");
                        } else {
                            throw new Error("AI ç„¡æ³•è­˜åˆ¥æ­¤åœ–ç‰‡ï¼Œè«‹å˜—è©¦æ›´æ¸…æ™°çš„åœ–ç‰‡ã€‚");
                        }
                    }

                    setSourceText(text);
                    callAI(currentTask, text);

                } catch (e) { 
                    if (e.message !== "Request cancelled") {
                        console.error(e); 
                        setErrorMsg(e.message); 
                    }
                    // å¦‚æœæ˜¯ Vision æ¨¡å¼ä¸”å¤±æ•—ï¼Œè‡ªå‹•åˆ‡å›æ–‡å­—æ¨¡å¼ä»¥å…å¡ä½
                    if (currentTask === 'vision' && !geminiKey) {
                        setCurrentTask('notes');
                    }
                } finally {
                    setIsLoading(false);
                }
            };

            const switchToChat = () => {
                setMode('conversation');
                if(translatedText && chatMessages.length===0) setChatMessages([{role:'model', text:`å·²ç‚ºæ‚¨æº–å‚™å¥½å…§å®¹ã€‚æ‚¨å¯ä»¥é‡å°å‰›æ‰çš„åˆ†æçµæœæå•ã€‚`}]);
            };

            const sendChat = async () => {
                if(!chatInput.trim())return;
                if(!geminiKey) {
                    setChatMessages(p=>[...p, {role:'user',text:chatInput}, {role:'model',text:"è«‹å…ˆåœ¨è¨­å®šä¸­è¼¸å…¥ API Key æ‰èƒ½ä½¿ç”¨å°è©±åŠŸèƒ½ã€‚"}]);
                    setChatInput('');
                    return;
                }

                const newUserMsg = {role:'user',text:chatInput}; 
                setChatMessages(prev => [...prev, newUserMsg]); 
                setChatInput(''); 
                setIsLoading(true);

                try {
                    const now = new Date().toLocaleString('zh-TW', { timeZone: 'Asia/Taipei' });
                    
                    let historyStr = '';
                    chatMessages.forEach(m => {
                        historyStr += `${m.role === 'user' ? 'User' : 'Model'}: ${m.text}\n`;
                    });

                    let ctx = `Current DateTime: ${now}.\nContext:\nSource:${sourceText}\nResult:${translatedText}`;
                    if(customInstruction) ctx += `\nSystem Instruction:${customInstruction}`;
                    ctx += `\n\nConversation History:\n${historyStr}`;
                    ctx += `User: ${newUserMsg.text}\nModel:`;
                    
                    const safetySettings = [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                    ];

                    const payload = {
                        contents:[{parts:[{text:ctx}]}],
                        safetySettings: safetySettings
                    };

                    const res = await runGeminiRequest(payload, geminiModel);
                    
                    // Safety check
                    if (res.promptFeedback && res.promptFeedback.blockReason) {
                         throw new Error(`âš ï¸ å…§å®¹è¢«å®‰å…¨ç³»çµ±é˜»æ“‹ (${res.promptFeedback.blockReason})`);
                    }

                    const candidate = res.candidates?.[0];
                    let responseText = "Error";
                    if (!candidate) {
                        responseText = "Error: No response from AI.";
                    } else if (candidate.finishReason !== "STOP" && !candidate.content) {
                        responseText = `Error: Blocked by safety settings (${candidate.finishReason})`;
                    } else {
                        responseText = candidate.content?.parts?.[0]?.text || "Error";
                    }

                    setChatMessages(p=>[...p,{role:'model',text:responseText}]);
                } catch(e) { 
                    if (e.message !== "Request cancelled") {
                        let errMsg = "Error: " + e.message;
                        if (e.message === "429_TOO_MANY_REQUESTS") {
                            errMsg = "ç³»çµ±ç›®å‰æµé‡éå¤§ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚";
                        }
                        setChatMessages(p=>[...p,{role:'model',text:errMsg}]); 
                    }
                }
                setIsLoading(false);
            };

             const getClientCoordinates = (e) => { const r = imageRef.current.getBoundingClientRect(); const c = e.touches?e.touches[0]:e; return {x: c.clientX-r.left, y: c.clientY-r.top}; };
            const handleCropStart = (e) => { const coords = getClientCoordinates(e); setCropSelection({x:coords.x,y:coords.y,w:0,h:0}); isDraggingRef.current=true; dragStartRef.current=coords; };
            const handleCropMove = (e) => { if(!isDraggingRef.current)return; const coords = getClientCoordinates(e); const r = imageRef.current.getBoundingClientRect(); const cx = Math.min(Math.max(0, coords.x), r.width); const cy = Math.min(Math.max(0, coords.y), r.height); setCropSelection({x:Math.min(dragStartRef.current.x,cx),y:Math.min(dragStartRef.current.y,cy),w:Math.abs(cx-dragStartRef.current.x),h:Math.abs(cy-dragStartRef.current.y)}); };
            const handleCropEnd = () => isDraggingRef.current = false;
            const handleFullImageConfirm = async () => { const res = await fetch(cropImageSrc); const blob = await res.blob(); const file = new File([blob], "full.jpg", {type:'image/jpeg'}); runOCR(file); };
            const handleCropConfirm = () => {
                if(!cropSelection) return;
                const img = imageRef.current; const canvas = document.createElement('canvas');
                const scaleX = img.naturalWidth / img.clientWidth; const scaleY = img.naturalHeight / img.clientHeight;
                canvas.width = cropSelection.w * scaleX; canvas.height = cropSelection.h * scaleY;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, cropSelection.x*scaleX, cropSelection.y*scaleY, cropSelection.w*scaleX, cropSelection.h*scaleY, 0, 0, canvas.width, canvas.height);
                canvas.toBlob(blob => { runOCR(new File([blob], "crop.jpg", {type:'image/jpeg'})); }, 'image/jpeg');
            };
            
             const handleVisualDragStart = (e) => {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                visualDragStartRef.current = { x: clientX, y: clientY };
                setVisualDragging(true);
            };
            const handleVisualResizeStart = (e) => {
                e.preventDefault(); e.stopPropagation();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                visualResizeStartRef.current = { startX: clientX, startY: clientY, startW: visualBox.w, startH: typeof visualBox.h === 'number' ? visualBox.h : 200, fontSize: visualFontSize };
                setVisualResizing(true);
            };
            const handleVisualMove = (e) => {
                if (visualDragging && visualDragStartRef.current && visualContainerRef.current) {
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const containerRect = visualContainerRef.current.getBoundingClientRect();
                    const deltaX = ((clientX - visualDragStartRef.current.x) / containerRect.width) * 100;
                    const deltaY = ((clientY - visualDragStartRef.current.y) / containerRect.height) * 100;
                    setVisualBox(prev => ({ ...prev, x: Math.max(0, Math.min(100, prev.x + deltaX)), y: Math.max(0, Math.min(100, prev.y + deltaY)) }));
                    visualDragStartRef.current = { x: clientX, y: clientY };
                } else if (visualResizing && visualResizeStartRef.current) {
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const deltaX = clientX - visualResizeStartRef.current.startX;
                    const deltaY = clientY - visualResizeStartRef.current.startY;
                    const newWidth = Math.max(100, visualResizeStartRef.current.startW + deltaX);
                    const newHeight = Math.max(50, visualResizeStartRef.current.startH + deltaY);
                    const scaleRatio = newWidth / visualResizeStartRef.current.startW;
                    const newFontSize = Math.max(10, Math.min(100, visualResizeStartRef.current.fontSize * scaleRatio));
                    setVisualBox(prev => ({ ...prev, w: newWidth, h: newHeight }));
                    setVisualFontSize(newFontSize);
                }
            };
            const handleVisualEnd = () => { setVisualDragging(false); setVisualResizing(false); visualDragStartRef.current = null; visualResizeStartRef.current = null; };
            const handleSaveVisualImage = async () => {
                if (!visualContainerRef.current) return;
                try {
                    const canvas = await html2canvas(visualContainerRef.current, { useCORS: true, backgroundColor: '#000000' });
                    const link = document.createElement('a'); link.download = `visual_translation_${new Date().getTime()}.png`; link.href = canvas.toDataURL('image/png'); link.click();
                    showToast("åœ–ç‰‡å·²å„²å­˜", "success");
                } catch (err) { showToast("å„²å­˜å¤±æ•—", "error"); }
            };
            
            const toggleListening = () => {
                if (isListening) {
                    if (recognitionRef.current) {
                        recognitionRef.current.stop();
                    }
                    setIsListening(false);
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    setErrorMsg("ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è¾¨è­˜");
                    return;
                }

                const recognition = new SpeechRecognition();
                recognitionRef.current = recognition;
                
                let langCode = sourceLang;
                if (langCode === 'auto' || langCode === 'nan' || langCode === 'yue') langCode = 'zh-TW'; 
                
                recognition.lang = langCode;
                recognition.continuous = true;
                recognition.interimResults = true;

                recognition.onstart = () => setIsListening(true);
                recognition.onend = () => setIsListening(false);
                recognition.onerror = (e) => {
                    console.error("Speech recognition error", e);
                    setIsListening(false);
                    showToast("èªéŸ³è¾¨è­˜éŒ¯èª¤: " + e.error, "error");
                };

                recognition.onresult = (e) => {
                    let final = '';
                    for (let i = e.resultIndex; i < e.results.length; ++i) {
                        if (e.results[i].isFinal) {
                            final += e.results[i][0].transcript;
                        }
                    }
                    
                    if (final) {
                        if (mode === 'conversation') {
                            setChatInput(prev => prev + final);
                        } else {
                            setSourceText(prev => prev + (prev ? ' ' : '') + final);
                        }
                    }
                };

                recognition.start();
            };
            
             const handleSelection = () => { 
                 const selection = window.getSelection(); 
                 const text = selection.toString().trim(); 
                 if (text.length > 0 && (selection.anchorNode.parentElement.tagName === 'TEXTAREA' || selection.anchorNode.parentElement.closest('.prose'))) { 
                     const range = selection.getRangeAt(0); 
                     const rect = range.getBoundingClientRect(); 
                     setSelectionMenu({ visible: true, x: rect.left + window.scrollX + rect.width / 2, y: rect.top + window.scrollY - 10, text: text }); 
                 } else { 
                     setSelectionMenu({ ...selectionMenu, visible: false }); 
                 } 
             };
            
            const handleSelectionAction = async (action) => { 
                setSelectionMenu({ ...selectionMenu, visible: false }); 
                const text = selectionMenu.text; 
                if (action === 'explain') { await callAI('grammar', `Explain: "${text}"`); } 
                else if (action === 'glossary') { setNewGlossaryTerm(text); setShowSettings(true); setActiveTab('data'); } 
                else if (action === 'speak') { speak(text, targetLang); } 
            };
            
            const copy = (t, isS) => { if(!t)return; navigator.clipboard.writeText(t); showToast(isS?"å·²è¤‡è£½åŸæ–‡":"å·²è¤‡è£½è­¯æ–‡", 'success'); };
            const speak = (t, l) => { if(!t)return; window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(t); u.lang = LANGUAGES.find(lang => lang.code === l)?.codeFull || l; u.rate = voiceRate; u.pitch = voicePitch; if (selectedVoiceURI) { const v = availableVoices.find(v => v.voiceURI === selectedVoiceURI); if (v) u.voice = v; } window.speechSynthesis.speak(u); };
            
            const handleDownload = () => { 
                if (!translatedText) return; 
                const blob = new Blob([translatedText], { type: 'text/plain' }); 
                const url = window.URL.createObjectURL(blob); 
                const a = document.createElement('a'); 
                a.href = url; 
                a.download = `translation_${new Date().toISOString().slice(0,10)}.md`; 
                document.body.appendChild(a); 
                a.click(); 
                document.body.removeChild(a); 
                window.URL.revokeObjectURL(url); 
            };

            const handleExportData = () => {
                const data = { settings: { geminiKey, geminiModel, customInstruction, voiceRate, voicePitch, fsSize, globalFontSize, aiTemperature, firebaseConfigStr, syncId }, glossary, history, chatMessages };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `gemini_backup_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); window.URL.revokeObjectURL(url);
                showToast("å‚™ä»½å·²ä¸‹è¼‰", "success");
            };

            const handleImportData = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.settings) {
                            if (data.settings.geminiKey) setGeminiKey(data.settings.geminiKey);
                            if (data.settings.geminiModel) setGeminiModel(data.settings.geminiModel);
                            if (data.settings.customInstruction) setCustomInstruction(data.settings.customInstruction);
                            if (data.settings.voiceRate) setVoiceRate(data.settings.voiceRate);
                            if (data.settings.voicePitch) setVoicePitch(data.settings.voicePitch);
                            if (data.settings.fsSize) setFsSize(data.settings.fsSize);
                            if (data.settings.globalFontSize) setGlobalFontSize(data.settings.globalFontSize);
                            if (data.settings.aiTemperature) setAiTemperature(data.settings.aiTemperature);
                            if (data.settings.firebaseConfigStr) setFirebaseConfigStr(data.settings.firebaseConfigStr);
                            if (data.settings.syncId) setSyncId(data.settings.syncId);
                        }
                        if (data.glossary) setGlossary(data.glossary);
                        if (data.history) setHistory(data.history);
                        if (data.chatMessages) setChatMessages(data.chatMessages);
                        showToast("è¨­å®šèˆ‡è³‡æ–™åŒ¯å…¥æˆåŠŸï¼", "success");
                    } catch (err) { showToast("åŒ¯å…¥å¤±æ•—ï¼šæª”æ¡ˆæ ¼å¼éŒ¯èª¤", "error"); }
                };
                reader.readAsText(file);
            };
            
            const handleScreenCapture = async () => {
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "never" }, audio: false });
                    const video = document.createElement('video'); video.srcObject = stream; await video.play();
                    const canvas = document.createElement('canvas'); canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d'); ctx.drawImage(video, 0, 0);
                    stream.getTracks().forEach(track => track.stop());
                    canvas.toBlob(blob => { const file = new File([blob], "screenshot.png", { type: 'image/png' }); processFile(file); });
                } catch (e) { showToast("æˆªåœ–å–æ¶ˆæˆ–å¤±æ•—", "error"); }
            };
            
            const handleFullScreenDownload = async () => {
                if (!fsInnerRef.current) return; 
                setIsLoading(true);
                setLoadingStatus('æ­£åœ¨ç”¢ç”Ÿå…¨è¢å¹•æˆªåœ–...');
                
                try {
                    const element = fsInnerRef.current;
                    const height = element.scrollHeight;
                    let dynamicScale = 4;
                    
                    if (height > 6000) {
                        dynamicScale = 2; // è¶…é•·å…§å®¹ä½¿ç”¨ 2x (ç¢ºä¿æˆåŠŸç‡)
                    } else if (height > 2500) {
                        dynamicScale = 3; // ä¸­é•·å…§å®¹ä½¿ç”¨ 3x
                    }
                    // çŸ­å…§å®¹ç¶­æŒ 4x (æœ€é«˜ç•«è³ª)

                    const canvas = await html2canvas(element, {
                        useCORS: true,
                        backgroundColor: darkMode ? '#0f172a' : '#ffffff',
                        scale: dynamicScale, 
                        logging: false,
                        allowTaint: false,
                        scrollY: -window.scrollY
                    });
                    const link = document.createElement('a');
                    link.download = `fullscreen_capture_${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    showToast(`å…¨è¢å¹•æˆªåœ–å·²ä¸‹è¼‰ (${dynamicScale}x ç•«è³ª)`, "success");
                } catch (err) {
                    console.error("FS Download Error:", err);
                    showToast("æˆªåœ–å¤±æ•—ï¼Œå…§å®¹å¯èƒ½éé•·", "error");
                } finally {
                    setIsLoading(false);
                    setLoadingStatus('');
                }
            };

            const handleScreenshotMsg = async (id) => {
                const element = document.getElementById(id);
                if (!element) return;
                try {
                    const canvas = await html2canvas(element, { useCORS: true, backgroundColor: null, scale: 3 });
                    const link = document.createElement('a');
                    link.download = `chat_capture_${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    showToast("æˆªåœ–å·²ä¸‹è¼‰", "success");
                } catch (err) {
                    showToast("æˆªåœ–å¤±æ•—", "error");
                }
            };

            const handlePasteClick = async () => {
                try {
                    try {
                        const items = await navigator.clipboard.read();
                        for (const item of items) {
                            if (item.types.some(type => type.startsWith('image/'))) {
                                const type = item.types.find(type => type.startsWith('image/'));
                                const blob = await item.getType(type);
                                const file = new File([blob], "pasted_image.png", { type });
                                processFile(file);
                                showToast("å·²è²¼ä¸Šå‰ªè²¼ç°¿åœ–ç‰‡", "success");
                                return;
                            }
                        }
                    } catch (err) {
                        console.log("Clipboard read() failed or denied, falling back to text.");
                    }

                    const text = await navigator.clipboard.readText();
                    if (text) {
                        if (currentTask === 'vision') {
                             showToast("è­˜åœ–æ¨¡å¼åƒ…é™è²¼ä¸Šåœ–ç‰‡ (Vision mode only accepts images)", "error");
                             return;
                        }
                        setSourceText(prev => prev + text);
                        showToast("å·²è²¼ä¸Šå‰ªè²¼ç°¿å…§å®¹", "success");
                    } else {
                        showToast("ç„¡æ³•è®€å–å‰ªè²¼ç°¿å…§å®¹", "error");
                    }
                } catch (err) {
                    console.error('Clipboard Error: ', err);
                    showToast("ç„¡æ³•è®€å–å‰ªè²¼ç°¿ï¼Œè«‹å˜—è©¦ä½¿ç”¨ Ctrl+V", "error");
                }
            };

            const processFileRef = useRef(processFile);
            useEffect(() => { processFileRef.current = processFile; }, [processFile]);

            useEffect(() => {
                const handleGlobalPaste = (e) => {
                    if (e.clipboardData && e.clipboardData.files.length > 0) {
                        const file = e.clipboardData.files[0];
                        if (file.type.startsWith('image/')) {
                            e.preventDefault();
                            processFileRef.current(file);
                            showToast("å·²åµæ¸¬åˆ°åœ–ç‰‡è²¼ä¸Š", "success");
                        }
                    }
                };
                window.addEventListener('paste', handleGlobalPaste);
                return () => window.removeEventListener('paste', handleGlobalPaste);
            }, []);

            useEffect(() => { document.addEventListener('mouseup', handleSelection); document.addEventListener('touchend', handleSelection); return () => { document.removeEventListener('mouseup', handleSelection); document.removeEventListener('touchend', handleSelection); }; }, [selectionMenu]);

            // --- IMAGE GEN FUNCTIONS ---
            const handleRefineImage = async () => {
                if (!imageGenState.prompt) return;
                setIsLoading(true);
                setLoadingStatus('AI æ­£åœ¨å„ªåŒ–æç¤ºè©...');
                try {
                    const prompt = `Please rewrite and improve the following image generation prompt to be more descriptive, artistic, and detailed. Keep the original intent but enhance the visual description. Output ONLY the improved prompt text.\n\nOriginal Prompt:\n${imageGenState.prompt}`;
                    const payload = { contents:[{parts:[{text:prompt}]}] };
                    const res = await runGeminiRequest(payload, geminiModel);
                    const newPrompt = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    if (newPrompt) {
                        setImageGenState(prev => ({ ...prev, prompt: newPrompt }));
                        showToast("æç¤ºè©å·²å„ªåŒ–", "success");
                    }
                } catch(e) {
                    if (e.message !== "Request cancelled") showToast("å„ªåŒ–å¤±æ•—: " + e.message, "error");
                } finally {
                    setIsLoading(false);
                }
            };

            const handleGenerateImageFinal = async () => {
                const textToUse = imageGenState.prompt;
                if (!textToUse) return;
                
                try {
                    await navigator.clipboard.writeText("è«‹å¹«æˆ‘ç•«ä¸€å¼µåœ–: " + textToUse);
                    showToast("æç¤ºè©å·²è¤‡è£½ï¼æ­£åœ¨é–‹å•Ÿ Gemini...", "success");
                } catch (err) {
                    // Fallback copy
                    const ta = document.createElement('textarea');
                    ta.value = "è«‹å¹«æˆ‘ç•«ä¸€å¼µåœ–: " + textToUse;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    showToast("æç¤ºè©å·²è¤‡è£½ï¼æ­£åœ¨é–‹å•Ÿ Gemini...", "success");
                }

                setTimeout(() => {
                    window.open("https://gemini.google.com/app", "_blank");
                }, 500);
                
                // Add to chat history so user knows what happened
                setChatMessages(prev => [...prev, {role:'model', text: `### ğŸ¨ å¤–éƒ¨ç¹ªåœ–å·²å•Ÿå‹•\n\nä½¿ç”¨äº†ä»¥ä¸‹æç¤ºè©ï¼š\n> ${textToUse}\n\n(å·²è‡ªå‹•è¤‡è£½ä¸¦é–‹å•Ÿ Gemini ç¶²é )`}]);
                setImageGenState({ show: false, prompt: '' });
            };
            
            // --- NEW: REVERSE IMAGE PROMPT ---
            const handleImageToPrompt = async () => {
                if(!cropImageSrc) return;
                setIsLoading(true);
                setLoadingStatus("æ­£åœ¨åˆ†æåœ–ç‰‡ä¸¦è½‰æ›ç‚ºç¹ªåœ–æŒ‡ä»¤...");
                setShowCropModal(false);
                
                try {
                    // Extract base64 without prefix
                    const b64 = cropImageSrc.split(',')[1];
                    const prompt = `Describe this image in detail as an image generation prompt in English. Focus on visual style, colors, composition, and mood. Output ONLY the prompt text.`;
                    const payload = {contents:[{parts:[{text: prompt},{inline_data:{mime_type:'image/jpeg',data:b64}}]}]};
                    const res = await runGeminiRequest(payload, geminiModel);
                    const newPrompt = res.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    
                    setMode('conversation');
                    setChatMessages(prev => [...prev, {role:'model', text: `### ğŸ¨ åœ–ç‰‡è½‰ç¹ªåœ–æŒ‡ä»¤\n\nå·²åˆ†ææ‚¨ä¸Šå‚³çš„åœ–ç‰‡ï¼Œä¸¦ç”¢ç”Ÿå°æ‡‰çš„ Promptã€‚æ‚¨å¯ä»¥ä¿®æ”¹å¾Œå†é‡æ–°ç”Ÿæˆã€‚`}]);
                    
                    if (newPrompt) {
                        setImageGenState({ show: true, prompt: newPrompt });
                    }
                } catch(e) {
                    if (e.message !== "Request cancelled") showToast("åˆ†æå¤±æ•—: " + e.message, "error");
                } finally {
                    setIsLoading(false);
                }
            };

            return (
                <div className="pb-12 dark:bg-slate-900 min-h-screen transition-colors flex flex-col">
                    {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
                    <header className="bg-white/90 dark:bg-slate-900/90 backdrop-blur shadow-sm border-b dark:border-slate-800 sticky top-0 z-20 h-14 flex items-center justify-between px-4">
                        <div className="flex items-center gap-2 font-bold text-lg text-slate-800 dark:text-white"><Icons.Languages className="text-blue-600"/> Gemini åŠ©æ‰‹ <span className="text-xs font-normal text-white bg-gradient-to-r from-blue-500 to-purple-500 px-2 py-0.5 rounded-full flex items-center gap-1"><Icons.Cloud className="w-3 h-3"/>Sync</span></div>
                        <div className="flex gap-2">
                            <button onClick={handleClearAll} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800" title="æ¸…é™¤æ‰€æœ‰å…§å®¹"><Icons.Trash className="text-red-500"/></button>
                            <button onClick={()=>setDarkMode(!darkMode)} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800">{darkMode?<Icons.Sun className="text-yellow-400"/>:<Icons.Moon className="text-slate-600"/>}</button>
                            <button onClick={()=>setShowHistory(true)} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800"><Icons.Clock/></button>
                            <button onClick={()=>setShowSettings(true)} className={`p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 ${isSyncing ? 'text-green-500' : ''}`}><Icons.Settings/></button>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto px-4 py-6 gap-4 flex-1 flex flex-col w-full">
                          <div className="flex flex-col gap-3">
                            <div className="flex bg-white dark:bg-slate-800 p-1 rounded-lg border dark:border-slate-700 w-full md:w-fit">
                                <button onClick={()=>setMode('text')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='text'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.Type className="w-4 h-4"/>æ–‡å­—</button>
                                <button onClick={()=>setMode('file')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='file'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.FileText className="w-4 h-4"/>æ–‡ä»¶</button>
                                <button onClick={()=>setMode('conversation')} className={`flex-1 md:flex-none px-3 py-1.5 text-sm font-bold rounded-md flex items-center justify-center gap-1 ${mode==='conversation'?'bg-blue-50 text-blue-600':'text-slate-400'}`}><Icons.MessageSquare className="w-4 h-4"/>å°è©±</button>
                            </div>
                            {mode!=='conversation' && <div className="grid grid-cols-4 md:grid-cols-8 gap-2 bg-white dark:bg-slate-800 p-1 rounded-lg border dark:border-slate-700 w-full">
                                {TASKS.map(t => (
                                    <button 
                                        key={t.id} 
                                        onClick={() => { 
                                            setCurrentTask(t.id); setTranslatedText(''); setErrorMsg(''); 
                                        }} 
                                        className={`px-1 py-2 md:px-3 text-xs md:text-sm font-bold rounded-md flex flex-col md:flex-row items-center justify-center gap-1 md:gap-2 transition-all ${currentTask === t.id && mode !== 'conversation' ? 'bg-slate-800 text-white' : 'text-slate-500 hover:bg-slate-50 dark:hover:bg-slate-700'}`}
                                    >
                                        {t.icon} 
                                        <span>{t.name}</span>
                                    </button>
                                ))}
                            </div>}
                        </div>

                        {mode !== 'conversation' && (
                            <div className="bg-white dark:bg-slate-800 p-2 rounded-lg border dark:border-slate-700 flex flex-wrap gap-2 items-center justify-between">
                                <div className="flex items-center gap-2 flex-1 min-w-[200px]">
                                    <select value={sourceLang} onChange={(e)=>setSourceLang(e.target.value)} className="p-1.5 rounded-md border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white flex-1">
                                        {LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name}</option>)}
                                    </select>
                                    <button onClick={()=>{const t=targetLang; setTargetLang(sourceLang==='auto'?'en':sourceLang); setSourceLang(t);}} className="p-1.5 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-full text-slate-400"><Icons.ArrowRightLeft className="w-4 h-4"/></button>
                                    <select value={targetLang} onChange={(e)=>setTargetLang(e.target.value)} className="p-1.5 rounded-md border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white flex-1">
                                        {LANGUAGES.map(l=><option key={l.code} value={l.code}>{l.name}</option>)}
                                    </select>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-xs text-slate-400 font-bold hidden md:inline">èªæ°£:</span>
                                    <select value={selectedTone} onChange={(e)=>setSelectedTone(e.target.value)} className="p-1.5 rounded-md border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white min-w-[100px]">
                                        {TONES.map(t=><option key={t.id} value={t.id}>{t.name}</option>)}
                                    </select>
                                </div>
                            </div>
                        )}
      {mode!=='conversation' && <button onClick={()=>callAI(currentTask)} disabled={isLoading||!sourceText} className={`w-full py-3 rounded-xl font-bold text-white shadow transition-all active:scale-[0.99] disabled:opacity-50 ${TASKS.find(t=>t.id===currentTask)?.btnColor}`}>{isLoading?'è™•ç†ä¸­...':TASKS.find(t=>t.id===currentTask)?.name}</button>}
                        {mode!=='conversation' && (
                            <div className="grid md:grid-cols-2 gap-4 flex-1 min-h-[500px]">
                                <div className="flex flex-col bg-white dark:bg-slate-800 rounded-xl border dark:border-slate-700 overflow-hidden relative">
                                    <div className="px-3 py-2 bg-slate-50 dark:bg-slate-800 border-b dark:border-slate-700 flex justify-between items-center">
                                        <div className="flex items-center gap-2">
                                            <span className="text-xs font-bold text-slate-500">åŸæ–‡</span>
                                            {isListening && <span className="text-xs text-red-500 animate-pulse">â— è½å¯«ä¸­</span>}
                                        </div>
                                        <div className="flex gap-1">
                                            <input type="file" ref={cameraInputRef} className="hidden" accept="image/*" onChange={handleFileChange} />
                                            <button onClick={handlePasteClick} className="p-1 text-slate-400 hover:text-blue-600" title="è²¼ä¸Š"><Icons.Paste className="w-4 h-4"/></button>
                                            <button onClick={handleScreenCapture} className="p-1 text-slate-400 hover:text-blue-600" title="æˆªåœ–"><Icons.Scissors className="w-4 h-4"/></button>
                                            <button onClick={() => cameraInputRef.current?.click()} className="p-1 text-slate-400 hover:text-blue-600" title="ä¸Šå‚³åœ–ç‰‡/æ‹ç…§"><Icons.Camera className="w-4 h-4"/></button>
                                            <button onClick={toggleListening} className={`p-1 ${isListening ? 'text-red-500' : 'text-slate-400 hover:text-blue-600'}`} title="èªéŸ³è¼¸å…¥"><Icons.Mic className="w-4 h-4"/></button>
                                            <button onClick={()=>setSourceText('')} className="p-1 text-slate-400 hover:text-red-500" title="æ¸…é™¤"><Icons.X className="w-4 h-4"/></button>
                                        </div>
                                    </div>
                                    <textarea value={sourceText} onChange={e=>setSourceText(e.target.value)} className="flex-1 p-4 bg-transparent outline-none resize-none dark:text-slate-200 text-lg" placeholder={currentTask === 'vision' ? "è«‹ä¸Šå‚³æˆ–è²¼ä¸Šåœ–ç‰‡ä»¥é€²è¡Œè¾¨è­˜..." : "è¼¸å…¥æ–‡å­—..."} style={{fontSize: `${globalFontSize}px`}}/>
                                    {mode==='file' && !sourceText && <div onClick={()=>fileInputRef.current.click()} className={`absolute inset-0 flex flex-col items-center justify-center bg-slate-50/80 dark:bg-slate-900/80 cursor-pointer border-2 border-dashed m-4 rounded-xl transition-colors ${isDragOver ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-slate-300 dark:border-slate-700'}`} onDragOver={e=>{e.preventDefault();setIsDragOver(true)}} onDragLeave={()=>{setIsDragOver(false)}} onDrop={e=>{e.preventDefault();setIsDragOver(false);processFile(e.dataTransfer.files[0])}}><Icons.UploadCloud className="w-8 h-8 text-blue-400"/><span className="text-sm text-slate-500 mt-2">{currentTask === 'vision' ? 'ä¸Šå‚³åœ–ç‰‡ (Vision Mode Only)' : 'ä¸Šå‚³æ–‡ä»¶ / åœ–ç‰‡'}</span><input type="file" ref={fileInputRef} className="hidden" onChange={handleFileChange} accept={currentTask==='vision' ? "image/*" : "*/*"}/></div>}
                                </div>
                                <div className="flex flex-col bg-white dark:bg-slate-800 rounded-xl border dark:border-slate-700 overflow-hidden relative">
                                    <div className="px-3 py-2 bg-slate-50 dark:bg-slate-800 border-b dark:border-slate-700 flex justify-between items-center">
                                        <span className="text-xs font-bold text-slate-500">çµæœ</span>
                                        <div className="flex gap-1">
                                            <button onClick={handleResultToImageGen} className="p-1 text-pink-500 hover:text-pink-600 bg-pink-50 dark:bg-pink-900/30 rounded" title="è¯æƒ³ç¹ªåœ– (AI Image Gen)"><Icons.Palette className="w-4 h-4"/></button>
                                            {displayImage && <button onClick={()=>setShowVisualMode(true)} className="p-1 text-slate-400 hover:text-blue-600"><Icons.Image className="w-4 h-4"/></button>}
                                            {currentTask!=='mindmap' && currentTask!=='image-gen' && <button onClick={()=>setIsMarkdownMode(!isMarkdownMode)} className="p-1 text-slate-400 hover:text-blue-600"><Icons.Code className="w-4 h-4"/></button>}
                                            <button onClick={handleDownload} className="p-1 text-slate-400 hover:text-blue-600" title="ä¸‹è¼‰"><Icons.Download className="w-4 h-4"/></button>
                                            <button onClick={()=>copy(translatedText, false)} className="p-1 text-slate-400 hover:text-blue-600" title="è¤‡è£½"><Icons.Copy className="w-4 h-4"/></button>
                                            <button onClick={()=>speak(translatedText, targetLang)} className="p-1 text-slate-400 hover:text-blue-600" title="æœ—è®€"><Icons.Volume2 className="w-4 h-4"/></button>
                                            <button onClick={()=>setShowBigText(true)} className="p-1 text-slate-400 hover:text-blue-600" title="å…¨è¢å¹•"><Icons.Maximize className="w-4 h-4"/></button>
                                        </div>
                                    </div>
                                    <div className="flex-1 overflow-y-auto bg-slate-50/30 dark:bg-slate-900/30 relative">
                                        {isLoading && <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/80 dark:bg-slate-900/80 z-10">
                                            <Icons.RotateCw className="w-8 h-8 text-blue-500 animate-spin mb-2"/>
                                            <span className="text-xs font-bold text-blue-500 mb-2">{loadingStatus}</span>
                                            <button onClick={handleCancelRequest} className="px-3 py-1 bg-red-100 text-red-600 rounded-full text-xs font-bold hover:bg-red-200">å–æ¶ˆ</button>
                                        </div>}
                                        {currentTask==='mindmap' ? <div className="p-4"><MermaidDiagram code={translatedText} darkMode={darkMode}/></div> : isMarkdownMode ? <div className="p-4"><SafeMarkdown content={translatedText} fontSize={globalFontSize}/></div> : <textarea readOnly value={translatedText} className="w-full h-full p-4 bg-transparent outline-none resize-none text-lg dark:text-slate-200" style={{fontSize: `${globalFontSize}px`}}/>}
                                    </div>
                                    <div className="absolute bottom-3 right-3"><button onClick={switchToChat} className="bg-blue-600 text-white text-xs px-3 py-1.5 rounded-full shadow hover:bg-blue-700 flex items-center gap-1"><Icons.MessageSquare className="w-3 h-3"/> é‡å°çµæœå°è©±</button></div>
                                </div>
                            </div>
                        )}

                        {mode === 'conversation' && (
                            <div className="bg-white dark:bg-slate-800 rounded-xl border dark:border-slate-700 flex-1 flex flex-col min-h-[500px] relative overflow-hidden">
                                {/* Header for Chat */}
                                <div className="flex items-center justify-between p-3 border-b dark:border-slate-700 bg-white/50 dark:bg-slate-800/50 backdrop-blur">
                                     <button onClick={() => setMode('text')} className="flex items-center gap-2 text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-700 px-3 py-1.5 rounded-lg transition-colors group">
                                        <Icons.ArrowLeft className="w-4 h-4 group-hover:-translate-x-1 transition-transform"/>
                                        <span className="text-sm font-bold">è¿”å›æ–‡ä»¶</span>
                                     </button>
                                     {/* Top buttons removed as requested */}
                                </div>
                                
                                <div className="flex-1 overflow-y-auto p-4 space-y-4 relative">
                                    {chatMessages.map((m,i)=><div key={i} className={`flex ${m.role==='user'?'justify-end':'justify-start'}`}>
                                        <div id={`msg-${i}`} className={`max-w-[85%] p-3 rounded-2xl text-sm flex flex-col gap-1 ${m.role==='user'?'bg-blue-600 text-white':'bg-slate-100 dark:bg-slate-700 dark:text-slate-200'}`}>
                                            <SafeMarkdown content={m.text} fontSize={globalFontSize} isUser={m.role==='user'}/>
                                            {m.role==='model' && (
                                                <div className="flex items-center gap-2 mt-1 self-end">
                                                     <button onClick={() => copy(m.text)} className="text-slate-400 hover:text-blue-500" title="è¤‡è£½"><Icons.Copy className="w-3 h-3" /></button>
                                                     <button onClick={() => handleScreenshotMsg(`msg-${i}`)} className="text-slate-400 hover:text-blue-500" title="æˆªåœ–"><Icons.Camera className="w-3 h-3" /></button>
                                                     <button onClick={() => speak(m.text, targetLang)} className="text-slate-400 hover:text-blue-500" title="æœ—è®€"><Icons.Volume2 className="w-3 h-3" /></button>
                                                </div>
                                            )}
                                        </div>
                                    </div>)}
                                    <div ref={chatEndRef}/>
                                </div>

                                {/* --- IMAGE GEN PANEL (Discussion Area) --- */}
                                {imageGenState.show && (
                                    <div className="absolute bottom-[130px] left-0 right-0 bg-slate-50 dark:bg-slate-900 border-t dark:border-slate-700 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)] z-20 animate-slide-in-bottom rounded-t-2xl overflow-hidden flex flex-col max-h-[300px]">
                                        <div className="bg-pink-100 dark:bg-pink-900/40 px-4 py-2 flex justify-between items-center border-b border-pink-200 dark:border-pink-800">
                                            <div className="flex items-center gap-2 font-bold text-pink-700 dark:text-pink-300 text-sm">
                                                <Icons.Palette className="w-4 h-4"/> ç¹ªåœ–å·¥åŠ (Image Studio)
                                            </div>
                                            <button onClick={() => setImageGenState({show:false, prompt:''})} className="text-pink-700 dark:text-pink-300 hover:bg-pink-200 dark:hover:bg-pink-800 rounded-full p-1"><Icons.X className="w-4 h-4"/></button>
                                        </div>
                                        <div className="p-3 flex-1 flex flex-col gap-2">
                                            <textarea 
                                                value={imageGenState.prompt}
                                                onChange={e => setImageGenState(prev => ({ ...prev, prompt: e.target.value }))}
                                                className="w-full h-full min-h-[80px] p-3 bg-white dark:bg-slate-800 border dark:border-slate-700 rounded-lg text-sm dark:text-slate-200 resize-none focus:ring-2 focus:ring-pink-500 outline-none"
                                                placeholder="AI æ­£åœ¨æ§‹æ€æç¤ºè©ï¼Œæ‚¨ä¹Ÿå¯ä»¥ç›´æ¥è¼¸å…¥..."
                                            />
                                            <div className="flex gap-2 justify-end">
                                                <button 
                                                    onClick={handleRefineImage} 
                                                    disabled={isLoading || !imageGenState.prompt}
                                                    className="px-3 py-1.5 bg-indigo-100 dark:bg-indigo-900/50 text-indigo-600 dark:text-indigo-300 rounded-lg text-xs font-bold hover:bg-indigo-200 dark:hover:bg-indigo-800 transition-colors flex items-center gap-1"
                                                >
                                                    {isLoading ? <Icons.RotateCw className="w-3 h-3 animate-spin"/> : <Icons.Sparkles className="w-3 h-3"/>}
                                                    AI å„ªåŒ–
                                                </button>
                                                <button 
                                                    onClick={handleGenerateImageFinal}
                                                    disabled={!imageGenState.prompt}
                                                    className="px-4 py-1.5 bg-pink-600 hover:bg-pink-700 text-white rounded-lg text-xs font-bold shadow transition-transform active:scale-95 flex items-center gap-1"
                                                >
                                                    <Icons.Image className="w-3 h-3"/>
                                                    ç”Ÿæˆåœ–ç‰‡ (é–‹å•Ÿ Gemini)
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                <div className="border-t dark:border-slate-700 bg-white dark:bg-slate-800 z-30 relative">
                                    {/* Moved Buttons Toolbar */}
                                    <div className="flex items-center gap-2 px-3 py-2 overflow-x-auto hide-scrollbar border-b border-slate-100 dark:border-slate-700/50">
                                        <button onClick={() => handleSmartAction('summary')} className="flex-shrink-0 flex items-center gap-1.5 bg-teal-50 dark:bg-teal-900/30 text-teal-600 dark:text-teal-400 hover:bg-teal-100 dark:hover:bg-teal-900/50 px-3 py-1.5 rounded-lg text-xs font-bold transition-colors">
                                            <Icons.List className="w-3 h-3"/> æ•´ç†é‡é»
                                        </button>
                                        <button onClick={() => handleSmartAction('image_prompt')} className="flex-shrink-0 flex items-center gap-1.5 bg-pink-50 dark:bg-pink-900/30 text-pink-600 dark:text-pink-400 hover:bg-pink-100 dark:hover:bg-pink-900/50 px-3 py-1.5 rounded-lg text-xs font-bold transition-colors">
                                            <Icons.Palette className="w-3 h-3"/> è¯æƒ³ç¹ªåœ–
                                        </button>
                                        <button onClick={() => setImageGenState(prev => ({...prev, show: !prev.show}))} className={`flex-shrink-0 flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-bold transition-colors ${imageGenState.show ? 'bg-indigo-100 text-indigo-600 dark:bg-indigo-900/50 dark:text-indigo-300' : 'bg-slate-100 text-slate-600 hover:bg-slate-200 dark:bg-slate-700 dark:text-slate-300'}`}>
                                            <Icons.Image className="w-3 h-3"/> ç¹ªåœ–å·¥åŠ
                                        </button>
                                    </div>
                                    
                                    {/* Input Area */}
                                    <div className="p-3 flex gap-2 items-center">
                                        <button onClick={() => chatFileInputRef.current?.click()} className="p-2 rounded-full transition-colors bg-slate-100 text-slate-500 hover:bg-slate-200 dark:bg-slate-700 dark:text-slate-300" title="ä¸Šå‚³åœ–ç‰‡åˆ†æé¢¨æ ¼"><Icons.Image className="w-5 h-5"/></button>
                                        <input type="file" ref={chatFileInputRef} className="hidden" accept="image/*" onChange={handleChatImageUpload} />
                                        
                                        <button onClick={toggleListening} className={`p-2 rounded-full transition-colors ${isListening ? 'bg-red-100 text-red-500' : 'bg-slate-100 text-slate-500 hover:bg-slate-200 dark:bg-slate-700 dark:text-slate-300'}`} title="èªéŸ³è¼¸å…¥"><Icons.Mic className="w-5 h-5"/></button>
                                        <textarea 
                                            value={chatInput} 
                                            onChange={e=>setChatInput(e.target.value)} 
                                            onKeyDown={e=>{if(e.key==='Enter' && !e.shiftKey){e.preventDefault();sendChat();}}} 
                                            className="flex-1 p-2 bg-slate-50 dark:bg-slate-900 border dark:border-slate-600 rounded-lg outline-none dark:text-white chat-input resize-none hide-scrollbar" 
                                            placeholder="è¼¸å…¥è¨Šæ¯..."
                                        />
                                        <button onClick={isLoading ? handleCancelRequest : sendChat} className={`p-2 ${isLoading ? 'bg-red-500' : 'bg-blue-600'} text-white rounded-lg`}>{isLoading?<Icons.X className="w-5 h-5"/>:<Icons.Send className="w-5 h-5"/>}</button>
                                    </div>
                                </div>
                            </div>
                        )}

                     
                        {errorMsg && <div className="text-red-500 text-xs text-center bg-red-50 p-2 rounded">{errorMsg}</div>}
                    </main>
                    
                    {showHistory && (
                        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 animate-in fade-in" onClick={() => setShowHistory(false)}>
                            <div className="bg-white dark:bg-slate-800 w-full max-w-md p-6 rounded-2xl shadow-xl max-h-[80vh] flex flex-col animate-pop-in" onClick={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4 border-b border-slate-100 dark:border-slate-700 pb-3">
                                    <h3 className="font-bold text-lg dark:text-white flex items-center gap-2"><Icons.Clock className="w-5 h-5 text-blue-500"/> æ­·å²ç´€éŒ„</h3>
                                    <div className="flex gap-2">
                                        <button onClick={clearHistory} className="text-red-500 text-xs font-bold hover:bg-red-50 dark:hover:bg-red-900/20 px-3 py-1.5 rounded-full transition-colors">æ¸…é™¤å…¨éƒ¨</button>
                                        <button onClick={() => setShowHistory(false)} className="p-1 rounded-full hover:bg-slate-100 dark:hover:bg-slate-700"><Icons.X className="w-5 h-5 text-slate-500" /></button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto space-y-3 pr-1 custom-scrollbar">
                                    {history.length === 0 ? (
                                        <div className="text-center text-slate-400 py-12 flex flex-col items-center">
                                            <Icons.Clock className="w-12 h-12 mb-3 opacity-20"/>
                                            <span>å°šç„¡æ­·å²ç´€éŒ„</span>
                                        </div>
                                    ) : (
                                        history.map(h => (
                                            <div key={h.id} className="group bg-slate-50 dark:bg-slate-900 p-4 rounded-xl border border-slate-100 dark:border-slate-700 cursor-pointer hover:border-blue-300 dark:hover:border-blue-700 hover:shadow-md transition-all" onClick={() => { setSourceText(h.src); setTranslatedText(h.res); setSourceLang(h.s); setTargetLang(h.t); setShowHistory(false); }}>
                                                <div className="flex justify-between text-[10px] uppercase tracking-wider text-slate-400 mb-2">
                                                    <span>{h.timestamp}</span>
                                                    <span className="bg-slate-200 dark:bg-slate-800 px-1.5 py-0.5 rounded text-slate-500 dark:text-slate-400 font-bold">{LANGUAGES.find(l=>l.code===h.s)?.name || h.s} â†’ {LANGUAGES.find(l=>l.code===h.t)?.name || h.t}</span>
                                                </div>
                                                <div className="text-sm text-slate-600 dark:text-slate-300 line-clamp-2 mb-1.5 font-medium">{h.src}</div>
                                                <div className="text-sm text-slate-900 dark:text-slate-100 line-clamp-2 pl-2 border-l-2 border-blue-500">{h.res.substring(0, 100)}...</div>
                                            </div>
                                        ))
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- RE-ADDED MISSING MODALS --- */}
                    {showSettings && (
                        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 animate-in fade-in" onClick={() => setShowSettings(false)}>
                            <div className="bg-white dark:bg-slate-800 w-full max-w-2xl p-6 rounded-2xl shadow-xl max-h-[90vh] flex flex-col animate-pop-in" onClick={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-6 border-b border-slate-100 dark:border-slate-700 pb-4">
                                    <h3 className="font-bold text-xl dark:text-white flex items-center gap-2"><Icons.Settings className="w-6 h-6 text-slate-500"/> è¨­å®š</h3>
                                    <button onClick={() => setShowSettings(false)} className="p-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-full transition-colors"><Icons.X className="w-5 h-5 text-slate-500"/></button>
                                </div>
                                <div className="flex gap-4 mb-6 border-b border-slate-100 dark:border-slate-700">
                                    {['general', 'voice', 'sync', 'data'].map(tab => (
                                        <button key={tab} onClick={() => setActiveTab(tab)} className={`pb-2 px-1 text-sm font-bold capitalize transition-colors relative ${activeTab === tab ? 'text-blue-600 dark:text-blue-400' : 'text-slate-400 hover:text-slate-600 dark:hover:text-slate-300'}`}>{tab === 'general' ? 'ä¸€èˆ¬' : tab === 'voice' ? 'èªéŸ³' : tab === 'sync' ? 'åŒæ­¥' : 'è³‡æ–™'}{activeTab === tab && <span className="absolute bottom-0 left-0 w-full h-0.5 bg-blue-600 rounded-full"></span>}</button>
                                    ))}
                                </div>
                                <div className="flex-1 overflow-y-auto space-y-6 pr-2 custom-scrollbar">
                                    {activeTab === 'general' && (
                                        <div className="space-y-4">
                                            <div>
                                                <label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">Gemini API Key</label>
{/* --- ä¿®æ”¹ UI é–‹å§‹ï¼šå°‡ Input æ”¹ç‚º Textarea --- */}
<div className="flex gap-2 items-start">
    <textarea 
        value={geminiKey} 
        onChange={e => setGeminiKey(e.target.value)}
        className="flex-1 p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-xs font-mono outline-none focus:ring-2 focus:ring-blue-500 transition-all dark:text-white resize-none h-20" 
        placeholder="è«‹è¼¸å…¥ API Key (æ”¯æ´å¤šçµ„ï¼Œä¸€è¡Œä¸€çµ„)&#10;Key_1...&#10;Key_2..." 
    />
    <button onClick={testApiKey} disabled={isLoading} className="px-3 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg text-xs font-bold whitespace-nowrap disabled:opacity-50 flex items-center gap-1 h-20 justify-center">
        {isLoading ? <Icons.RotateCw className="w-3 h-3 animate-spin"/> : <Icons.Check className="w-3 h-3"/>}
        é©—è­‰ Keys
    </button>
</div>
<div className="mt-1 text-xs text-slate-400">ç•¶ä¸€çµ„ Key é¡åº¦ç”¨ç›¡ (429) æ™‚ï¼Œç³»çµ±æœƒè‡ªå‹•åˆ‡æ›è‡³ä¸‹ä¸€è¡Œ Keyã€‚</div>
{/* --- ä¿®æ”¹ UI çµæŸ --- */}
                                               <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="mt-1 text-xs text-blue-500 hover:underline block">è«‹è‡³ Google AI Studio ç”³è«‹ API Key (é»æ­¤å‰å¾€)</a>

                                            </div>
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">æ¨¡å‹é¸æ“‡ (Model)</label><select value={geminiModel} onChange={e => setGeminiModel(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white">{GEMINI_MODELS.map(m => <option key={m.id} value={m.id}>{m.name}</option>)}</select></div>
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">è‡ªè¨‚æŒ‡ä»¤ (System Instruction)</label><textarea value={customInstruction} onChange={e => setCustomInstruction(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm h-24 resize-none outline-none dark:text-white" placeholder="ä¾‹å¦‚ï¼šä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„ç¿»è­¯äººå“¡ï¼Œè«‹ä½¿ç”¨å„ªé›…çš„è©å½™..." /></div>
                                            <div className="grid grid-cols-2 gap-4"><div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">å­—é«”å¤§å° (çµæœå€)</label><input type="range" min="12" max="32" value={globalFontSize} onChange={e => setGlobalFontSize(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" /><div className="text-right text-xs text-slate-400">{globalFontSize}px</div></div><div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">å‰µæ„ç¨‹åº¦ (Temperature)</label><input type="range" min="0" max="1" step="0.1" value={aiTemperature} onChange={e => setAiTemperature(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" /><div className="text-right text-xs text-slate-400">{aiTemperature}</div></div></div>
                                        </div>
                                    )}
                                    {activeTab === 'voice' && (
                                        <div className="space-y-4">
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">èªéŸ³å¼•æ“</label><select value={selectedVoiceURI} onChange={e => setSelectedVoiceURI(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white"><option value="">é è¨­</option>{availableVoices.map(v => <option key={v.voiceURI} value={v.voiceURI}>{v.name} ({v.lang})</option>)}</select></div>
                                            <div className="grid grid-cols-2 gap-4"><div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">èªé€Ÿ (Rate)</label><input type="range" min="0.5" max="2" step="0.1" value={voiceRate} onChange={e => setVoiceRate(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" /><div className="text-right text-xs text-slate-400">{voiceRate}x</div></div><div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">éŸ³èª¿ (Pitch)</label><input type="range" min="0.5" max="2" step="0.1" value={voicePitch} onChange={e => setVoicePitch(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" /><div className="text-right text-xs text-slate-400">{voicePitch}</div></div></div>
                                        </div>
                                    )}
                                    {activeTab === 'sync' && (
                                        <div className="space-y-4">
                                            <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg text-sm text-blue-600 dark:text-blue-300"><p className="font-bold mb-1">â˜ï¸ Firebase é›²ç«¯åŒæ­¥</p><p>è¨­å®šæ­¤åŠŸèƒ½å¯è®“æ‚¨åœ¨ä¸åŒè£ç½®é–“åŒæ­¥æ­·å²ç´€éŒ„èˆ‡è¨­å®šã€‚</p></div>
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">Firebase Config (JSON)</label><textarea value={firebaseConfigStr} onChange={e => setFirebaseConfigStr(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-xs font-mono h-32 resize-none outline-none dark:text-white" placeholder='{"apiKey": "...", ...}' /></div>
                                            <div><label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-1">Sync ID (è‡ªè¨‚è­˜åˆ¥ç¢¼)</label><input type="text" value={syncId} onChange={e => setSyncId(e.target.value)} className="w-full p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white" placeholder="ä¾‹å¦‚ï¼šmy-gemini-sync-001" /></div>
                                            <div className="flex justify-between items-center"><span className={`text-xs font-bold ${syncStatusMsg.includes('æˆåŠŸ') || syncStatusMsg.includes('å·²é€£ç·š') ? 'text-green-500' : 'text-red-500'}`}>{syncStatusMsg}</span><button onClick={testConnection} disabled={isLoading} className="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-bold hover:bg-blue-700 disabled:opacity-50">{isLoading ? 'é€£ç·šä¸­...' : 'æ¸¬è©¦é€£ç·š'}</button></div>
                                        </div>
                                    )}
                                    {activeTab === 'data' && (
                                        <div className="space-y-6">
                                            <div>
                                                <label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-2">è‡ªè¨‚è¡“èªè¡¨ (Glossary)</label>
                                                <div className="flex gap-2 mb-2"><input type="text" value={newGlossaryTerm} onChange={e => setNewGlossaryTerm(e.target.value)} placeholder="åŸæ–‡ (å¦‚: Apple)" className="flex-1 p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white" /><input type="text" value={newGlossaryTrans} onChange={e => setNewGlossaryTrans(e.target.value)} placeholder="è­¯æ–‡ (å¦‚: è˜‹æœ)" className="flex-1 p-2 rounded-lg border dark:border-slate-600 bg-slate-50 dark:bg-slate-900 text-sm outline-none dark:text-white" /><button onClick={addGlossaryTerm} className="p-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700"><Icons.Check className="w-4 h-4"/></button></div>
                                                <div className="max-h-40 overflow-y-auto rounded-lg border dark:border-slate-700">{glossary.length === 0 ? <div className="p-4 text-center text-slate-400 text-sm">å°šç„¡è¡“èª</div> : glossary.map((g, i) => (<div key={i} className="flex justify-between items-center p-2 border-b dark:border-slate-700 last:border-0 hover:bg-slate-50 dark:hover:bg-slate-700/50"><span className="text-sm dark:text-slate-300">{g.term} â†’ {g.trans}</span><button onClick={() => removeGlossaryTerm(i)} className="text-red-400 hover:text-red-500"><Icons.X className="w-3 h-3"/></button></div>))}</div>
                                            </div>
                                            <div className="border-t border-slate-100 dark:border-slate-700 pt-4">
                                                <label className="block text-sm font-bold text-slate-600 dark:text-slate-300 mb-2">è³‡æ–™ç®¡ç†</label>
                                                <div className="flex gap-2 flex-wrap">
                                                    <button onClick={handleExportData} className="px-4 py-2 bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 rounded-lg text-sm font-bold hover:bg-slate-300 dark:hover:bg-slate-600 flex items-center gap-2"><Icons.Download className="w-4 h-4"/> å‚™ä»½è³‡æ–™</button>
                                                    <label className="px-4 py-2 bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 rounded-lg text-sm font-bold hover:bg-slate-300 dark:hover:bg-slate-600 flex items-center gap-2 cursor-pointer"><Icons.UploadCloud className="w-4 h-4"/> åŒ¯å…¥å‚™ä»½<input type="file" className="hidden" accept=".json" onChange={handleImportData}/></label>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {showBigText && (
                        <div ref={fsContentRef} className="fixed inset-0 bg-white dark:bg-slate-900 z-[200] flex flex-col animate-in fade-in">
                            <div className="p-4 border-b dark:border-slate-700 flex justify-between items-center bg-slate-50 dark:bg-slate-800">
                                <div className="flex items-center gap-3"><button onClick={()=>setShowBigText(false)} className="p-2 hover:bg-slate-200 dark:hover:bg-slate-700 rounded-full"><Icons.ArrowLeft/></button><span className="font-bold text-lg">å…¨è¢å¹•é–±è®€</span></div>
                                <div className="flex items-center gap-4"><input type="range" min="16" max="64" value={fsSize} onChange={e=>setFsSize(Number(e.target.value))} className="w-32"/><input type="range" min="600" max="1200" step="100" value={fsWidth} onChange={e=>setFsWidth(Number(e.target.value))} className="w-32 hidden md:block"/><button onClick={handleFullScreenDownload} className="p-2 hover:bg-slate-200 dark:hover:bg-slate-700 rounded-full" title="ä¸‹è¼‰é•·åœ–"><Icons.Camera/></button></div>
                            </div>
                            <div className="flex-1 overflow-y-auto p-8 flex justify-center bg-white dark:bg-slate-900">
                                <div ref={fsInnerRef} className="h-fit min-h-full bg-white dark:bg-slate-900 p-8" style={{width: `${fsWidth}px`, maxWidth: '100%'}}><SafeMarkdown content={translatedText} fontSize={fsSize} /></div>
                            </div>
                        </div>
                    )}

                    {showCropModal && (
                        <div className="fixed inset-0 bg-black/80 z-[200] flex flex-col animate-in fade-in crop-modal">
                            <div className="p-4 flex justify-between items-center text-white"><span className="font-bold">è£åˆ‡åœ–ç‰‡ / é¸å–ç¯„åœ (Crop)</span><button onClick={()=>setShowCropModal(false)}><Icons.X className="w-6 h-6"/></button></div>
                            <div className="flex-1 overflow-hidden relative flex items-center justify-center bg-black" onTouchMove={(e)=>e.preventDefault()}>
                                <img ref={imageRef} src={cropImageSrc} className="max-w-full max-h-full object-contain touch-none select-none" onMouseDown={handleCropStart} onMouseMove={handleCropMove} onMouseUp={handleCropEnd} onTouchStart={handleCropStart} onTouchMove={handleCropMove} onTouchEnd={handleCropEnd} alt="Crop Target" draggable="false" />
                                {cropSelection && <div className="absolute border-2 border-blue-500 bg-blue-500/20 pointer-events-none" style={{left:cropSelection.x, top:cropSelection.y, width:cropSelection.w, height:cropSelection.h}}></div>}
                            </div>
                            <div className="p-4 bg-black flex gap-4 justify-center pb-8 safe-area-pb">
                                <button onClick={handleFullImageConfirm} className="px-6 py-3 bg-slate-700 text-white rounded-xl font-bold flex-1">ä½¿ç”¨åŸåœ–</button>
                                <button onClick={handleCropConfirm} disabled={!cropSelection} className="px-6 py-3 bg-blue-600 text-white rounded-xl font-bold flex-1 disabled:opacity-50">ç¢ºèªè£åˆ‡</button>
                                {currentTask === 'image-gen' && <button onClick={handleImageToPrompt} className="px-6 py-3 bg-pink-600 text-white rounded-xl font-bold flex-1">è½‰ç¹ªåœ–æŒ‡ä»¤</button>}
                            </div>
                        </div>
                    )}

                    {showVisualMode && displayImage && (
                        <div className="fixed inset-0 bg-black/90 z-[150] flex flex-col animate-in fade-in">
                            <div className="p-4 flex justify-between items-center text-white bg-black/50 backdrop-blur-sm z-10"><span className="font-bold">è¦–è¦ºåŒ–æ¨¡å¼ (Visual Mode)</span><div className="flex gap-2"><button onClick={handleSaveVisualImage} className="p-2 bg-blue-600 rounded-full"><Icons.Save className="w-5 h-5"/></button><button onClick={()=>setShowVisualMode(false)} className="p-2 hover:bg-white/10 rounded-full"><Icons.X className="w-6 h-6"/></button></div></div>
                            <div ref={visualContainerRef} className="flex-1 relative overflow-hidden flex items-center justify-center bg-black" onTouchMove={(e)=>e.preventDefault()}>
                                <img src={displayImage} className="max-w-full max-h-full object-contain pointer-events-none select-none" alt="Visual Background" />
                                <div className="absolute visual-text-box border-2 border-white/30 rounded-xl" style={{left:`${visualBox.x}%`, top:`${visualBox.y}%`, width: `${visualBox.w}px`, height: `${visualBox.h}px`, backgroundColor: visualStyle.bg}} onMouseDown={handleVisualDragStart} onTouchStart={handleVisualDragStart} onTouchMove={handleVisualMove} onTouchEnd={handleVisualEnd}>
                                    <div className="w-full h-full overflow-y-auto p-4 custom-scrollbar" style={{fontSize: `${visualFontSize}px`, color: visualStyle.color}}><SafeMarkdown content={translatedText} fontSize={visualFontSize}/></div>
                                    <div className="absolute bottom-0 right-0 w-6 h-6 bg-blue-500/50 cursor-se-resize" onMouseDown={handleVisualResizeStart} onTouchStart={handleVisualResizeStart}></div>
                                </div>
                            </div>
                            <div className="p-4 bg-black/80 backdrop-blur-sm flex gap-4 justify-center items-center pb-8 safe-area-pb z-10">
                                <button onClick={()=>setVisualStyle({...visualStyle, color: visualStyle.color==='white'?'black':'white'})} className="w-8 h-8 rounded-full border border-white" style={{background: visualStyle.color==='white'?'black':'white'}}></button>
                                <button onClick={()=>setVisualStyle({...visualStyle, bg: visualStyle.bg==='rgba(0,0,0,0.6)'?'rgba(255,255,255,0.8)':'rgba(0,0,0,0.6)'})} className="w-8 h-8 rounded-full border border-white" style={{background: visualStyle.bg}}></button>
                            </div>
                        </div>
                    )}

                    {selectionMenu.visible && (
                        <div className="fixed bg-slate-800 text-white rounded-lg shadow-xl flex overflow-hidden z-50 animate-pop-in" style={{ left: selectionMenu.x, top: selectionMenu.y, transform: 'translate(-50%, -100%)' }}>
                            <button onClick={()=>handleSelectionAction('explain')} className="px-3 py-2 hover:bg-slate-700 border-r border-slate-700 text-xs font-bold">è§£é‡‹</button>
                            <button onClick={()=>handleSelectionAction('glossary')} className="px-3 py-2 hover:bg-slate-700 border-r border-slate-700 text-xs font-bold">å­˜è¡“èª</button>
                            <button onClick={()=>handleSelectionAction('speak')} className="px-3 py-2 hover:bg-slate-700 text-xs font-bold">æœ—è®€</button>
                        </div>
                    )}

                    <div className="text-center text-xs text-slate-300 mt-8">Gemini AI Assistant â€¢ Pro v4.4 (Studio)</div>
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<App />);
    </script>
</body>
</html>





